name: Release

on:
  push:
    branches:
      - master  # å½“åˆå¹¶åˆ° master åˆ†æ”¯æ—¶è§¦å‘
      # æ’é™¤ bump-version-* åˆ†æ”¯ï¼Œé¿å…è§¦å‘ release workflow
      - '!bump-version-*'
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘ï¼ˆä»…é master åˆ†æ”¯ï¼‰

# ç»Ÿä¸€ workflow run çš„æ˜¾ç¤ºåç§°
# ç­–ç•¥ï¼šå¯¹äº push äº‹ä»¶ï¼Œå¦‚æœ commit message åŒ…å« "Merge pull request"ï¼ˆPR åˆå¹¶ï¼‰ï¼Œ
# GitHub ä¼šè‡ªåŠ¨ä½¿ç”¨ PR æ ‡é¢˜ä½œä¸ºæ˜¾ç¤ºåç§°ï¼ˆè¿™æ˜¯ GitHub çš„é»˜è®¤è¡Œä¸ºï¼Œä¼˜å…ˆçº§é«˜äº run-nameï¼‰
# å¯¹äº workflow_dispatch æˆ–å…¶ä»–æƒ…å†µï¼Œä½¿ç”¨è‡ªå®šä¹‰åç§°
run-name: ${{ github.event_name == 'workflow_dispatch' && format('Release - {0} (manual)', github.ref_name) || format('Release - {0} ({1})', github.ref_name, github.event_name) }}
permissions:
  contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
  pull-requests: write  # å…è®¸åˆ›å»º PRï¼ˆç”¨äºç‰ˆæœ¬æ›´æ–°ï¼‰
  statuses: write  # å…è®¸åˆ›å»ºçŠ¶æ€æ£€æŸ¥ï¼ˆç”¨äºæ»¡è¶³åˆ†æ”¯ä¿æŠ¤è§„åˆ™ï¼‰

env:
  CARGO_TERM_COLOR: always

jobs:
  # ä»£ç è´¨é‡æ£€æŸ¥ï¼ˆLintï¼‰
  check-lint:
    name: ğŸ” Code Quality Check
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: ğŸ’¾ Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          # ä¼˜åŒ– Windows ä¸Šçš„ç¼“å­˜æ€§èƒ½ï¼šç¦ç”¨è·¨ OS å½’æ¡£å¯ä»¥é¿å… Windows è·¯å¾„é—®é¢˜
          enableCrossOsArchive: false

      - name: âœ¨ Check code formatting
        run: cargo fmt --check

      - name: ğŸ” Run Clippy linter
        run: cargo clippy -- -D warnings

      - name: âœ… Verify compilation
        run: cargo check
  #
  # è¿è¡Œæµ‹è¯•
  tests:
    name: ğŸ§ª Run Tests
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: ğŸ’¾ Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          # ä¼˜åŒ– Windows ä¸Šçš„ç¼“å­˜æ€§èƒ½ï¼šç¦ç”¨è·¨ OS å½’æ¡£å¯ä»¥é¿å… Windows è·¯å¾„é—®é¢˜
          enableCrossOsArchive: false

      - name: ğŸ“¦ Install system dependencies (Linux)
        run: |
          sudo apt-get update
          # å®‰è£… XCB å¼€å‘åº“ï¼ˆclipboard ä¾èµ–ï¼‰
          # xcb crate éœ€è¦ xcb-proto æ¥ç”Ÿæˆä»£ç æ¨¡å—
          sudo apt-get install -y \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev

      - name: ğŸ§ª Run tests
        run: cargo test --verbose
  #
  # ç¡®ä¿æ‰€æœ‰æ£€æŸ¥éƒ½é€šè¿‡ï¼ˆæ±‡æ€» jobï¼‰
  # è¿™ä¸ª job ä¾èµ–äº check-lint å’Œ testsï¼Œæ£€æŸ¥æ‰€æœ‰å¿…éœ€æ£€æŸ¥çš„çŠ¶æ€
  # å¦‚æœä»»ä½•æ£€æŸ¥å¤±è´¥ï¼Œæ­¤ job ä¼šå¤±è´¥ï¼Œä»è€Œé˜»æ­¢åç»­æ“ä½œ
  # æ³¨æ„ï¼šéœ€è¦åœ¨ GitHub ä»“åº“è®¾ç½®ä¸­é…ç½®åˆ†æ”¯ä¿æŠ¤è§„åˆ™ï¼Œå°†æ­¤å·¥ä½œæµè®¾ä¸ºå¿…éœ€çš„çŠ¶æ€æ£€æŸ¥
  check-status:
    name: âœ… Verify All Checks
    runs-on: ubuntu-latest
    needs: [check-lint, tests]
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: Check lint and test status
        run: |
          if [ "${{ needs.check-lint.result }}" != "success" ] || [ "${{ needs.tests.result }}" != "success" ]; then
            echo "âŒ Some checks failed:"
            echo "  Lint: ${{ needs.check-lint.result }}"
            echo "  Test: ${{ needs.tests.result }}"
            echo ""
            echo "Cannot proceed until all checks pass."
            exit 1
          fi
          echo "âœ… All checks passed!"

  # ç”Ÿæˆç‰ˆæœ¬å·å¹¶æ›´æ–° Cargo.toml å’Œ Cargo.lock
  update-version:
    name: ğŸ“¦ Generate Version
    runs-on: ubuntu-latest
    needs: [check-status]
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master') ||
      (github.ref == 'refs/heads/master' && github.event_name == 'push')
    permissions:
      contents: read  # åªéœ€è¦è¯»å–æƒé™
    outputs:
      version: ${{ steps.generate_version.outputs.version }}
      tag: ${{ steps.generate_version.outputs.tag }}
      needs_increment: ${{ steps.generate_version.outputs.needs_increment }}
      is_master_branch: ${{ steps.detect_mode.outputs.is_master_branch }}

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # éœ€è¦å®Œæ•´å†å²è®°å½•æ¥æ£€æŸ¥ tag
          # ä½¿ç”¨é»˜è®¤çš„ GITHUB_TOKENï¼Œæœ‰ contents: write æƒé™ï¼Œå¯ä»¥æ¨é€ tag

      - name: ğŸ” Get latest version from git tags
        id: get_latest_version
        shell: bash
        run: |
          # ä» git tags è·å–æœ€æ–°çš„æ ‡å‡†ç‰ˆæœ¬å·ï¼ˆæ’é™¤ alpha/beta é¢„å‘å¸ƒç‰ˆæœ¬ï¼‰
          # è·å–æ‰€æœ‰æ ‡å‡†ç‰ˆæœ¬ tagï¼ˆæ ¼å¼ï¼švx.x.xï¼‰ï¼ŒæŒ‰ç‰ˆæœ¬å·æ’åº
          LATEST_TAG=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1)

          if [ -z "$LATEST_TAG" ]; then
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†ç‰ˆæœ¬ tagï¼Œä½¿ç”¨é»˜è®¤ç‰ˆæœ¬
            LATEST_VERSION="0.0.0"
            echo "âš ï¸  No standard version tag found, using default: $LATEST_VERSION"
          else
            # ç§»é™¤ v å‰ç¼€
            LATEST_VERSION=${LATEST_TAG#v}
            echo "âœ… Latest standard version from git tags: $LATEST_TAG ($LATEST_VERSION)"
          fi

          echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: ğŸ¯ Detect branch type and trigger mode
        id: detect_mode
        shell: bash
        run: |
          set -e
          # æ£€æµ‹æ˜¯å¦æ˜¯ master åˆ†æ”¯
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            IS_MASTER_BRANCH="true"
          else
            IS_MASTER_BRANCH="false"
          fi

          # æ£€æµ‹è§¦å‘ç±»å‹
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            IS_MANUAL_TRIGGER="true"
          else
            IS_MANUAL_TRIGGER="false"
          fi

          echo "is_master_branch=$IS_MASTER_BRANCH" >> $GITHUB_OUTPUT
          echo "is_manual_trigger=$IS_MANUAL_TRIGGER" >> $GITHUB_OUTPUT

          echo "âœ… Branch detection completed:"
          echo "   Branch: ${{ github.ref }}"
          echo "   Is Master: $IS_MASTER_BRANCH"
          echo "   Event: ${{ github.event_name }}"
          echo "   Is Manual: $IS_MANUAL_TRIGGER"

      - name: ğŸ“¦ Generate version number
        id: generate_version
        shell: bash
        run: |
          set -e
          LATEST_VERSION="${{ steps.get_latest_version.outputs.latest_version }}"
          IS_MASTER="${{ steps.detect_mode.outputs.is_master_branch }}"

          # éªŒè¯ LATEST_VERSION ä¸ä¸ºç©º
          if [ -z "$LATEST_VERSION" ]; then
            echo "âŒ Error: LATEST_VERSION is empty"
            exit 1
          fi

          echo "ğŸ“‹ Version generation inputs:"
          echo "   LATEST_VERSION: $LATEST_VERSION"
          echo "   IS_MASTER: $IS_MASTER"

          if [[ "$IS_MASTER" == "true" ]]; then
            # Master åˆ†æ”¯ï¼šç”Ÿæˆæ ‡å‡†ç‰ˆæœ¬å·
            # è§£ææœ€æ–°ç‰ˆæœ¬å·
            IFS='.' read -ra VERSION_PARTS <<< "$LATEST_VERSION"
            MAJOR="${VERSION_PARTS[0]:-0}"
            MINOR="${VERSION_PARTS[1]:-0}"
            PATCH="${VERSION_PARTS[2]:-0}"

            # é¦–å…ˆæ£€æŸ¥å½“å‰ commit æ˜¯å¦å·²ç»æœ‰ä»»ä½•æ ‡å‡†ç‰ˆæœ¬ tag æŒ‡å‘å®ƒ
            CURRENT_COMMIT_SHA=$(git rev-parse HEAD)
            EXISTING_TAG_ON_COMMIT=$(git tag --points-at HEAD | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1 || true)

            if [ -n "$EXISTING_TAG_ON_COMMIT" ]; then
              # å½“å‰ commit å·²ç»æœ‰ tagï¼Œä½¿ç”¨è¯¥ tag çš„ç‰ˆæœ¬å·
              VERSION=${EXISTING_TAG_ON_COMMIT#v}
              TAG="$EXISTING_TAG_ON_COMMIT"
              NEEDS_INCREMENT="false"
              echo "âœ… Found existing tag $TAG on current commit, reusing it"
            else
              # å½“å‰ commit æ²¡æœ‰ tagï¼Œæ£€æŸ¥ LATEST_VERSION å¯¹åº”çš„ tag æ˜¯å¦å­˜åœ¨
              CURRENT_TAG="v$LATEST_VERSION"
              if git rev-parse "$CURRENT_TAG" >/dev/null 2>&1; then
                # Tag å­˜åœ¨ä½†æŒ‡å‘å…¶ä»– commitï¼Œéœ€è¦é€’å¢ç‰ˆæœ¬å·
                PATCH=$((PATCH + 1))
                VERSION="$MAJOR.$MINOR.$PATCH"
                TAG="v$VERSION"
                NEEDS_INCREMENT="true"
                echo "âœ… Tag $CURRENT_TAG exists but points to different commit, incrementing to $VERSION"
              else
                # Tag ä¸å­˜åœ¨ï¼Œéœ€è¦é€’å¢ç‰ˆæœ¬å·ï¼ˆé¿å…è¿ç»­ release ä½¿ç”¨ç›¸åŒç‰ˆæœ¬å·ï¼‰
                PATCH=$((PATCH + 1))
                VERSION="$MAJOR.$MINOR.$PATCH"
                TAG="v$VERSION"
                NEEDS_INCREMENT="true"
                echo "âœ… Tag $CURRENT_TAG does not exist, incrementing to $VERSION for new release"
              fi
            fi

            echo "âœ… Master branch: Generated version $VERSION ($TAG)"
          else
            # é Master åˆ†æ”¯ï¼šç”Ÿæˆé¢„å‘å¸ƒç‰ˆæœ¬å· (vx.x.x.alpha-xxx)
            # åŸºäºæœ€æ–°ç‰ˆæœ¬å· + 1 çš„ patch ç‰ˆæœ¬
            IFS='.' read -ra VERSION_PARTS <<< "$LATEST_VERSION"
            MAJOR="${VERSION_PARTS[0]:-0}"
            MINOR="${VERSION_PARTS[1]:-0}"
            PATCH="${VERSION_PARTS[2]:-0}"

            # Patch ç‰ˆæœ¬å· + 1
            PATCH=$((PATCH + 1))
            BASE_VERSION="$MAJOR.$MINOR.$PATCH"

            # æŸ¥æ‰¾è¯¥åŸºç¡€ç‰ˆæœ¬çš„æ‰€æœ‰ alpha é¢„å‘å¸ƒç‰ˆæœ¬
            ALPHA_PATTERN="v${BASE_VERSION}.alpha-[0-9]*"
            EXISTING_ALPHAS=$(git tag -l "$ALPHA_PATTERN" | sort -V || true)

            if [ -z "$EXISTING_ALPHAS" ]; then
              # æ²¡æœ‰ç°æœ‰çš„ alpha ç‰ˆæœ¬ï¼Œä» 001 å¼€å§‹
              ALPHA_NUM=1
            else
              # æ‰¾åˆ°æœ€å¤§çš„ alpha ç¼–å·å¹¶é€’å¢
              LAST_ALPHA=$(echo "$EXISTING_ALPHAS" | tail -1)
              ALPHA_NUM=$(echo "$LAST_ALPHA" | grep -oE 'alpha-[0-9]+' | grep -oE '[0-9]+' || echo "0")
              ALPHA_NUM=$((ALPHA_NUM + 1))
            fi

            # æ ¼å¼åŒ– alpha ç¼–å·ä¸º 3 ä½æ•°å­—ï¼ˆ001, 002, ...ï¼‰
            ALPHA_NUM_FORMATTED=$(printf "%03d" $ALPHA_NUM)
            VERSION="${BASE_VERSION}.alpha-${ALPHA_NUM_FORMATTED}"
            TAG="v$VERSION"
            NEEDS_INCREMENT="false"

            echo "âœ… Non-master branch: Generated pre-release version $VERSION ($TAG)"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "needs_increment=$NEEDS_INCREMENT" >> $GITHUB_OUTPUT

      - name: ğŸ”§ Setup Rust toolchain
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true'
        uses: dtolnay/rust-toolchain@stable

      - name: ğŸ“ Update Cargo.toml and Cargo.lock version
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true'
        shell: bash
        run: |
          NEW_VERSION="${{ steps.generate_version.outputs.version }}"

          # æ›´æ–° Cargo.toml ä¸­çš„ç‰ˆæœ¬å·
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          else
            sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          fi

          # éªŒè¯ Cargo.toml æ›´æ–°
          UPDATED_VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "âŒ Error: Failed to update version in Cargo.toml"
            exit 1
          fi

          # æ›´æ–° Cargo.lock ä¸­çš„ç‰ˆæœ¬å·
          if grep -q 'name = "workflow"' Cargo.lock; then
            if [[ "$OSTYPE" == "darwin"* ]]; then
              sed -i '' '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            else
              sed -i '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            fi
          fi

          echo "âœ… Version updated to $NEW_VERSION in Cargo.toml and Cargo.lock"

      - name: ğŸ“¤ Upload updated version files
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: updated-version-files
          path: |
            Cargo.toml
            Cargo.lock
          retention-days: 1

  # æ„å»ºæ‰€æœ‰å¹³å°çš„äºŒè¿›åˆ¶æ–‡ä»¶
  build:
    name: ğŸ”¨ Build Binaries - ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    needs: [check-status, update-version]
    # æ‰‹åŠ¨è§¦å‘/ Master Push: éœ€è¦ä¾èµ–æˆåŠŸ
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master' && needs.check-status.result == 'success' && needs.update-version.result == 'success') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.check-status.result == 'success' && needs.update-version.result == 'success')
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: macOS-Intel
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: macOS-AppleSilicon
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            platform: Linux-x86_64
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            platform: Linux-ARM64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            platform: Linux-x86_64-static
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            platform: Windows-x86_64
          - os: windows-latest
            target: aarch64-pc-windows-msvc
            platform: Windows-ARM64

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¥ Download updated version files
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true'
        uses: actions/download-artifact@v4
        with:
          name: updated-version-files
          path: .

      - name: ğŸ” Get version from update-version job
        id: version
        shell: bash
        run: |
          # ç»Ÿä¸€ä» update-version job çš„ outputs è·å–ç‰ˆæœ¬å·
          if [ -n "${{ needs.update-version.outputs.version }}" ]; then
            VERSION="${{ needs.update-version.outputs.version }}"
            TAG="${{ needs.update-version.outputs.tag }}"
            echo "âœ… Using version from update-version job: $VERSION ($TAG)"
          else
            echo "âŒ Error: Cannot determine version from update-version job"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: $TAG"

      - name: ğŸ”§ Setup Rust for ${{ matrix.target }}
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: ğŸ“¦ Install musl target
        if: contains(matrix.target, 'musl')
        run: |
          rustup target add ${{ matrix.target }}
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: ğŸ“¦ Install cross-compilation toolchain (Linux ARM64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu python3
          # æ³¨æ„ï¼šclipboard åŠŸèƒ½åœ¨ Linux ARM64 ä¸Šå·²ç¦ç”¨ï¼ˆCargo.toml ä¸­é…ç½®ï¼‰
          # å› æ­¤ä¸éœ€è¦å®‰è£… XCB å¼€å‘åº“ï¼Œç®€åŒ–æ„å»ºæµç¨‹
          # ä½†éœ€è¦å®‰è£… Python3 ç”¨äºå¤„ç† Cargo.lock è„šæœ¬

      - name: ğŸ“¦ Install system dependencies (Linux x86_64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'x86_64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          # å®‰è£… XCB å¼€å‘åº“ï¼ˆclipboard ä¾èµ–ï¼‰
          # xcb crate éœ€è¦ xcb-proto æ¥ç”Ÿæˆä»£ç æ¨¡å—ï¼ˆxproto, big_requests, etc.ï¼‰
          # xcb-proto éœ€è¦ Python æ¥è¿è¡Œä»£ç ç”Ÿæˆè„šæœ¬
          sudo apt-get install -y \
            python3 \
            python3-pip \
            python3-xcbgen \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev \
            pkg-config
          # éªŒè¯ xcb-proto åŒ…å’Œ Python å·²æ­£ç¡®å®‰è£…
          echo "ğŸ” Verifying xcb-proto package installation..."
          # xcb-proto ä¸æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºï¼Œè€Œæ˜¯ä¸€ä¸ªåŒ…å«åè®®æè¿°æ–‡ä»¶çš„åŒ…
          if dpkg -l | grep -q "^ii.*xcb-proto"; then
            echo "âœ… xcb-proto package is installed"
            # éªŒè¯åè®®æ–‡ä»¶ç›®å½•å­˜åœ¨
            if [ -d "/usr/share/xcb" ]; then
              echo "âœ… xcb protocol files directory found: /usr/share/xcb"
              # åˆ—å‡ºä¸€äº›åè®®æ–‡ä»¶ä»¥ç¡®è®¤
              PROTO_COUNT=$(find /usr/share/xcb -name "*.xml" 2>/dev/null | wc -l)
              if [ "$PROTO_COUNT" -gt 0 ]; then
                echo "âœ… Found $PROTO_COUNT protocol XML files"
              else
                echo "âš ï¸  Warning: No protocol XML files found in /usr/share/xcb"
              fi
            else
              echo "âš ï¸  Warning: /usr/share/xcb directory not found"
              # å°è¯•æŸ¥æ‰¾å®é™…ä½ç½®
              XCB_PROTO_DIR=$(dpkg -L xcb-proto 2>/dev/null | grep "/usr/share/xcb" | head -1 | xargs dirname 2>/dev/null || echo "")
              if [ -n "$XCB_PROTO_DIR" ] && [ -d "$XCB_PROTO_DIR" ]; then
                echo "âœ… Found xcb protocol directory at: $XCB_PROTO_DIR"
              fi
            fi
          else
            echo "âŒ Error: xcb-proto package is not installed"
            echo "   Please ensure xcb-proto package is installed via apt-get"
            exit 1
          fi
          python3 --version || echo "âš ï¸  Python3 not found"
          # éªŒè¯ xcbgen Python æ¨¡å—æ˜¯å¦å¯ç”¨ï¼ˆxcb crate æ„å»ºè„šæœ¬éœ€è¦ï¼‰
          echo "ğŸ” Checking for xcbgen Python module..."
          if python3 -c "import xcbgen" 2>/dev/null; then
            echo "âœ… xcbgen Python module is importable"
            # æ˜¾ç¤ºæ¨¡å—ä½ç½®
            python3 -c "import xcbgen; print(f'xcbgen location: {xcbgen.__file__}')" 2>/dev/null || true
          else
            echo "âŒ Error: xcbgen Python module is not importable"
            echo "   This is required for xcb crate to build"
            echo "   Please ensure python3-xcbgen package is installed"
            # å°è¯•æŸ¥æ‰¾ xcbgen æ¨¡å—çš„ä½ç½®
            XCBGEN_PATH=$(find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
            if [ -n "$XCBGEN_PATH" ]; then
              echo "   Found xcbgen directory at: $XCBGEN_PATH"
              echo "   Trying to add to PYTHONPATH..."
              export PYTHONPATH="$(dirname $XCBGEN_PATH):${PYTHONPATH:-}"
              echo "   PYTHONPATH: $PYTHONPATH"
              # å†æ¬¡å°è¯•å¯¼å…¥
              if python3 -c "import xcbgen" 2>/dev/null; then
                echo "âœ… xcbgen module is now importable after setting PYTHONPATH"
              else
                echo "âŒ xcbgen still not importable"
                exit 1
              fi
            else
              echo "   xcbgen directory not found"
              exit 1
            fi
          fi
          # éªŒè¯ pkg-config èƒ½æ‰¾åˆ° xcb åº“
          pkg-config --exists xcb && echo "âœ… xcb pkg-config found" || echo "âš ï¸  xcb pkg-config not found"

      - name: ğŸ“¦ Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          # æ£€æŸ¥ pkg-config æ˜¯å¦å·²å®‰è£…ï¼Œé¿å…é‡å¤å®‰è£…è­¦å‘Š
          if ! command -v pkg-config >/dev/null 2>&1; then
            brew install pkg-config
          else
            echo "âœ… pkg-config is already installed"
          fi

      - name: ğŸ” Get Cargo.lock hash
        id: cargo_lock
        shell: bash
        run: |
          if [ -f "Cargo.lock" ]; then
            # macOS ä½¿ç”¨ shasumï¼ŒLinux ä½¿ç”¨ sha256sum
            if command -v shasum >/dev/null 2>&1; then
              HASH=$(shasum -a 256 Cargo.lock | cut -d' ' -f1 | head -c 16)
            else
              HASH=$(sha256sum Cargo.lock | cut -d' ' -f1 | head -c 16)
            fi
            echo "hash=$HASH" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ’¾ Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ steps.cargo_lock.outputs.hash }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          enableCrossOsArchive: false

      - name: ğŸ”¨ Build binaries
        shell: bash
        run: |
          # è®¾ç½®äº¤å‰ç¼–è¯‘ç¯å¢ƒå˜é‡ï¼ˆä»… Linux ARM64ï¼‰
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            echo "ğŸ”§ Cross-compiling for Linux ARM64"
            echo "   CC: $CC_aarch64_unknown_linux_gnu"
            echo "   LINKER: $CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER"
            # éªŒè¯äº¤å‰ç¼–è¯‘å·¥å…·é“¾
            if command -v aarch64-linux-gnu-gcc >/dev/null 2>&1; then
              echo "âœ… aarch64-linux-gnu-gcc found: $(which aarch64-linux-gnu-gcc)"
              aarch64-linux-gnu-gcc --version || true
            else
              echo "âŒ Error: aarch64-linux-gnu-gcc not found"
              exit 1
            fi
          fi

          # å¯¹äº Linux x86_64ï¼Œéœ€è¦è®¾ç½®ç¯å¢ƒå˜é‡ä»¥æ”¯æŒ xcb æ„å»º
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            echo "ğŸ” Pre-build verification for xcb dependencies..."
            # é‡æ–°è®¾ç½®ç¯å¢ƒå˜é‡ï¼ˆå› ä¸ºæ¯ä¸ª step æ˜¯ç‹¬ç«‹çš„ shellï¼‰
            export XCB_PROTO_DIR="${XCB_PROTO_DIR:-/usr/share/xcb}"
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            # ç¡®ä¿ PYTHONPATH åŒ…å« xcbgen æ¨¡å—è·¯å¾„
            if [ -z "$PYTHONPATH" ] || ! python3 -c "import xcbgen" 2>/dev/null; then
              XCBGEN_DIR=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null || find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_DIR" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_DIR):${PYTHONPATH:-}"
              fi
            fi
            # éªŒè¯ xcb-proto åŒ…å·²å®‰è£…
            if dpkg -l | grep -q "^ii.*xcb-proto"; then
              echo "âœ… xcb-proto package is installed"
              # éªŒè¯åè®®æ–‡ä»¶ç›®å½•å­˜åœ¨
              if [ -n "$XCB_PROTO_DIR" ] && [ -d "$XCB_PROTO_DIR" ]; then
                echo "âœ… xcb protocol directory: $XCB_PROTO_DIR"
                # åˆ—å‡ºä¸€äº›åè®®æ–‡ä»¶
                echo "   Protocol files found:"
                ls -1 "$XCB_PROTO_DIR"/*.xml 2>/dev/null | head -5 | xargs -n1 basename || echo "   (none found)"
              else
                echo "âš ï¸  Warning: XCB_PROTO_DIR not set or directory not found"
              fi
            else
              echo "âŒ xcb-proto package is not installed"
              exit 1
            fi
            # éªŒè¯ Python
            if command -v python3 >/dev/null 2>&1; then
              echo "âœ… python3: $(which python3)"
            else
              echo "âŒ python3 not found"
              exit 1
            fi
            # éªŒè¯ xcbgen Python æ¨¡å—ï¼ˆå¿…éœ€ï¼‰
            if python3 -c "import xcbgen" 2>/dev/null; then
              echo "âœ… xcbgen Python module is importable"
              python3 -c "import xcbgen; import os; print(f'   xcbgen location: {os.path.dirname(xcbgen.__file__)}')" 2>/dev/null || true
            else
              echo "âŒ Error: xcbgen module not importable"
              echo "   This is required for xcb crate to build"
              echo "   PYTHONPATH: ${PYTHONPATH:-not set}"
              echo "   Python path: $(python3 -c 'import sys; print(":".join(sys.path))' 2>/dev/null || echo 'unknown')"
              exit 1
            fi
            # éªŒè¯ pkg-config
            if pkg-config --exists xcb; then
              echo "âœ… xcb libraries found via pkg-config"
              pkg-config --modversion xcb
            else
              echo "âš ï¸  Warning: xcb not found via pkg-config"
            fi
            # æ˜¾ç¤ºæœ€ç»ˆç¯å¢ƒå˜é‡
            echo "ğŸ“‹ Environment variables for build:"
            echo "   XCB_PROTO_DIR: ${XCB_PROTO_DIR}"
            echo "   PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
            echo "   PYTHONPATH: ${PYTHONPATH:-not set}"
          fi
          # æ„å»ºé¡¹ç›®
          # å¯¹äº Linux x86_64ï¼Œå¯ç”¨è¯¦ç»†è¾“å‡ºä»¥ä¾¿è°ƒè¯• xcb æ„å»ºé—®é¢˜
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            echo "ğŸ”¨ Building with verbose output for xcb debugging..."
            # ç¡®ä¿ç¯å¢ƒå˜é‡åœ¨æ„å»ºæ—¶å¯ç”¨
            # xcb crate çš„æ„å»ºè„šæœ¬éœ€è¦è¿™äº›ç¯å¢ƒå˜é‡
            export XCB_PROTO_DIR="${XCB_PROTO_DIR:-/usr/share/xcb}"
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            # ç¡®ä¿ PYTHONPATH åŒ…å« xcbgen æ¨¡å—è·¯å¾„
            if [ -z "$PYTHONPATH" ] || ! python3 -c "import xcbgen" 2>/dev/null; then
              XCBGEN_PATH=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null || find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_PATH" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_PATH):${PYTHONPATH:-}"
              fi
            fi
            # æ¸…ç†ä¹‹å‰çš„æ„å»ºç¼“å­˜ï¼Œé¿å…ç¼“å­˜é—®é¢˜
            echo "ğŸ§¹ Cleaning xcb build artifacts..."
            # æ¸…ç† xcb åŒ…çš„æ„å»ºç¼“å­˜
            cargo clean -p xcb 2>/dev/null || true
            # ä¹Ÿæ¸…ç†æ„å»ºè¾“å‡ºç›®å½•ä¸­çš„ xcb ç›¸å…³æ–‡ä»¶
            rm -rf target/${{ matrix.target }}/release/build/xcb-* 2>/dev/null || true
            rm -rf target/${{ matrix.target }}/release/deps/libxcb-* 2>/dev/null || true
            # æ˜¾ç¤ºæœ€ç»ˆçš„ç¯å¢ƒå˜é‡è®¾ç½®
            echo "ğŸ“‹ Final environment variables:"
            echo "   XCB_PROTO_DIR: ${XCB_PROTO_DIR}"
            echo "   PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
            echo "   PYTHONPATH: ${PYTHONPATH:-not set}"
            echo "   Python version: $(python3 --version 2>&1 || echo "unknown")"
            echo "   Python xcbgen: $(python3 -c 'import xcbgen; print("OK")' 2>&1 || echo "FAILED")"
            # éªŒè¯ Python ç‰ˆæœ¬å…¼å®¹æ€§ï¼ˆxcbgen éœ€è¦ Python 3.6+ï¼‰
            PYTHON_VERSION=$(python3 -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")' 2>/dev/null || echo "unknown")
            echo "   Python version check: $PYTHON_VERSION"
            if [ "$PYTHON_VERSION" != "unknown" ]; then
              MAJOR=$(echo "$PYTHON_VERSION" | cut -d. -f1)
              MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f2)
              if [ "$MAJOR" -lt 3 ] || ([ "$MAJOR" -eq 3 ] && [ "$MINOR" -lt 6 ]); then
                echo "âš ï¸  Warning: Python version $PYTHON_VERSION may be too old for xcbgen"
              else
                echo "âœ… Python version $PYTHON_VERSION is compatible"
              fi
            fi
            # æµ‹è¯• xcbgen æ˜¯å¦èƒ½æ­£å¸¸å·¥ä½œ
            echo "ğŸ§ª Testing xcbgen functionality..."
            if python3 -c "import xcbgen; import os; import sys; proto_dir = '${XCB_PROTO_DIR}'; print('âœ… Protocol directory exists:', proto_dir) if os.path.isdir(proto_dir) else (print('âŒ Protocol directory not found:', proto_dir), sys.exit(1)); import xcbgen.state, xcbgen.xtypes; print('âœ… xcbgen modules imported successfully')" 2>/dev/null; then
              echo "âœ… xcbgen test passed"
            else
              echo "âš ï¸  xcbgen test failed, but continuing with build..."
            fi
            # æ„å»º
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install -vv 2>&1 | tee build.log; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
              echo "âŒ Build failed. Checking build log for xcb-related errors..."
              grep -i "xcb\|xproto\|big_requests\|xcbgen\|xc_misc\|render\|shape\|xfixes" build.log || echo "No xcb-related errors found in log"
              # æ˜¾ç¤ºæ„å»ºè„šæœ¬è¾“å‡ºï¼ˆå¦‚æœæœ‰ï¼‰
              echo "ğŸ“‹ Checking for build script errors..."
              grep -i "error\|warning\|failed" build.log | head -20 || true
            fi
          elif [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            # Linux ARM64 äº¤å‰ç¼–è¯‘
            echo "ğŸ”¨ Building for Linux ARM64..."
            # ç¡®ä¿ç¯å¢ƒå˜é‡å·²è®¾ç½®
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
              echo "âŒ Build failed for Linux ARM64"
            fi
          else
            # å…¶ä»–ç›®æ ‡ï¼ˆmacOS, Windows, muslï¼‰
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
            fi
          fi

          # å¦‚æœæ„å»ºå¤±è´¥ï¼Œé€€å‡ºå¹¶è¿”å›é”™è¯¯ç 
          if [ "$BUILD_SUCCESS" != "true" ]; then
            echo "âŒ Build failed"
            exit 1
          fi

      - name: ğŸ“¦ Create package directory for binaries
        shell: bash
        run: |
          mkdir -p package
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cp target/${{ matrix.target }}/release/workflow.exe package/
            cp target/${{ matrix.target }}/release/install.exe package/
            echo "âœ… Copied workflow.exe and install.exe to package/"
          else
            cp target/${{ matrix.target }}/release/workflow package/
            cp target/${{ matrix.target }}/release/install package/
            echo "âœ… Copied workflow and install binaries to package/"
          fi

      - name: ğŸ“¦ Create archive (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $archiveName = "workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          $archivePath = Join-Path $PWD $archiveName
          # è¿›å…¥ package ç›®å½•
          Push-Location package
          try {
            # æ‰“åŒ… workflow.exe å’Œ install.exe ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
            Compress-Archive -Path "workflow.exe", "install.exe" -DestinationPath $archivePath -Force
            # æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
            $fileInfo = Get-Item $archivePath
            Write-Host "ğŸ“¦ Archive created: $archiveName"
            Write-Host "   Size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
            # éªŒè¯æ‰“åŒ…å†…å®¹
            Write-Host "ğŸ“¦ Archive contents:"
            $verifyPath = Join-Path $env:TEMP "workflow-verify"
            Expand-Archive -Path $archivePath -DestinationPath $verifyPath -Force
            Get-ChildItem $verifyPath | ForEach-Object { Write-Host "   $($_.Name)" }
            Remove-Item $verifyPath -Recurse -Force
          } finally {
            Pop-Location
          }

      - name: ğŸ“¦ Create archive (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          cd package
          ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          # æ‰“åŒ… workflow å’Œ install ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
          tar czf "../$ARCHIVE_NAME" workflow install
          cd ..
          ls -lh "$ARCHIVE_NAME"
          # éªŒè¯æ‰“åŒ…å†…å®¹
          echo "ğŸ“¦ Archive contents:"
          tar tzf "$ARCHIVE_NAME"

      - name: ğŸ” Calculate SHA256 checksum for archive
        id: sha256
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          else
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          fi
          if command -v shasum >/dev/null 2>&1; then
            SHA256=$(shasum -a 256 "$ARCHIVE_NAME" | cut -d' ' -f1)
          else
            SHA256=$(sha256sum "$ARCHIVE_NAME" | cut -d' ' -f1)
          fi
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "$SHA256" > "sha256-${{ matrix.platform }}.txt"

      - name: ğŸ“¤ Upload build archive to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}
          path: |
            workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.${{ matrix.os == 'windows-latest' && 'zip' || 'tar.gz' }}
          retention-days: 30

      - name: ğŸ“¤ Upload SHA256 checksum file
        uses: actions/upload-artifact@v4
        with:
          name: sha256-${{ matrix.platform }}
          path: |
            sha256-${{ matrix.platform }}.txt
          retention-days: 30

  # ç”¨æˆ·ç¡®è®¤æ˜¯å¦ç»§ç»­å‘å¸ƒæµç¨‹
  release-confirm:
    name: â¸ï¸ Release Confirmation
    runs-on: ubuntu-latest
    needs: [update-version, build]
    if: |
      needs.update-version.result == 'success' &&
      needs.build.result == 'success'
    environment: release-confirm
    permissions:
      contents: read
    steps:
      - name: â¸ï¸ Wait for approval
        run: |
          echo "âœ… Release confirmation approved"
          echo "   Version: ${{ needs.update-version.outputs.version }}"
          echo "   Tag: ${{ needs.update-version.outputs.tag }}"
          echo "   Build completed successfully"

  # åˆ›å»ºç‰ˆæœ¬æ›´æ–° PRã€åˆå¹¶ PR å¹¶åˆ›å»º tagï¼ˆåˆå¹¶åçš„ jobï¼‰
  create-tag:
    name: ğŸ·ï¸ Create Tag & Merge PR
    runs-on: ubuntu-latest
    needs: [update-version, build, release-confirm]
    if: |
      needs.update-version.result == 'success' &&
      needs.build.result == 'success' &&
      needs.release-confirm.result == 'success'
    permissions:
      contents: write
      pull-requests: write
    outputs:
      tag: ${{ steps.job_outputs.outputs.tag }}
      version: ${{ steps.job_outputs.outputs.version }}
      tag_created: ${{ steps.job_outputs.outputs.tag_created }}
      pr_number: ${{ steps.create_pr.outputs.pr_number }}
      pr_url: ${{ steps.create_pr.outputs.pr_url }}
      pr_merged: ${{ steps.handle_pr_merged.outputs.pr_merged || steps.merge_pr.outputs.pr_merged }}
      merge_commit_sha: ${{ steps.handle_pr_merged.outputs.merge_commit_sha || steps.get_merge_sha.outputs.merge_commit_sha }}
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # ä½¿ç”¨ PAT ä»¥æ”¯æŒæ¨é€æŒ‡å‘ä¿®æ”¹äº† workflow æ–‡ä»¶çš„ commit çš„ tag
          # å½“ tag æŒ‡å‘çš„ commit ä¿®æ”¹äº† workflow æ–‡ä»¶æ—¶ï¼ŒGITHUB_TOKEN æ— æ³•æ¨é€ï¼Œå¿…é¡»ä½¿ç”¨ PAT
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: ğŸ”§ Install jq
        shell: bash
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          else
            echo "âœ… jq is already installed"
          fi
          jq --version

      - name: ğŸ“¥ Download updated version files
        if: needs.update-version.outputs.needs_increment == 'true'
        uses: actions/download-artifact@v4
        with:
          name: updated-version-files
          path: .

      # Step 1: Create version update PR (only if needs_increment is true and master branch)
      - name: âš™ï¸ Configure Git for PR creation
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: ğŸŒ¿ Create version update PR
        id: create_pr
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true'
        shell: bash
        env:
          WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
        run: |

          NEW_VERSION="${{ needs.update-version.outputs.version }}"
          BRANCH_NAME="bump-version-${NEW_VERSION}"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Step 1: Creating version update PR"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºæ–°åˆ†æ”¯
          echo "Step 1.1: Creating branch $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"

          # ç¬¬äºŒæ­¥ï¼šæ·»åŠ æ–‡ä»¶
          echo "Step 1.2: Staging Cargo.toml and Cargo.lock"
          git add Cargo.toml Cargo.lock

          # ç¬¬ä¸‰æ­¥ï¼šæäº¤æ›´æ”¹
          echo "Step 1.3: Committing changes"
          git commit -m "chore: bump version to ${NEW_VERSION}"

          # ç¬¬å››æ­¥ï¼šæ¨é€åˆ°æ–°åˆ†æ”¯
          echo "Step 1.4: Pushing branch to origin"
          git push origin "$BRANCH_NAME"

          # ç¬¬äº”æ­¥ï¼šåˆ›å»º Pull Requestï¼ˆä½¿ç”¨ WORKFLOW_PAT ä»¥è§¦å‘ CIï¼‰
          echo "Step 1.5: Creating Pull Request"
          echo "Branch: $BRANCH_NAME"
          echo "Version: $NEW_VERSION"

          PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $WORKFLOW_PAT" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" \
            -d '{
              "title": "chore: bump version to '"$NEW_VERSION"'",
              "head": "'"$BRANCH_NAME"'",
              "base": "master",
              "body": "Automated version bump to '"$NEW_VERSION"'\n\nThis PR was created automatically by the release workflow.\n\n**Changes:**\n- Updated version in Cargo.toml to '"$NEW_VERSION"'\n- Updated version in Cargo.lock to '"$NEW_VERSION"'\n\n**Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }')

          HTTP_CODE=$(echo "$PR_RESPONSE" | tail -n1)
          PR_BODY=$(echo "$PR_RESPONSE" | head -n-1)

          echo "HTTP Status Code: $HTTP_CODE"

          if [ "$HTTP_CODE" != "201" ]; then
            echo "âš ï¸  Failed to create PR (HTTP $HTTP_CODE)"
            echo "Response body:"
            echo "$PR_BODY" | jq '.' 2>/dev/null || echo "$PR_BODY"

            # å¦‚æœæ˜¯ 422 é”™è¯¯ï¼ˆå·²å­˜åœ¨ PRï¼‰ï¼Œå°è¯•æŸ¥æ‰¾ç°æœ‰çš„ PR
            if [ "$HTTP_CODE" = "422" ]; then
              echo "Checking for existing PR..."
              EXISTING_PR=$(curl -s \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer $WORKFLOW_PAT" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:$BRANCH_NAME&base=master&state=open")

              PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.[0].number // empty' 2>/dev/null)
              if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
                PR_URL=$(echo "$EXISTING_PR" | jq -r '.[0].html_url // empty' 2>/dev/null)
                echo "âœ… Found existing PR #$PR_NUMBER: $PR_URL"
                echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
                echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
              else
                exit 1
              fi
            else
              exit 1
            fi
          else
            # æå– PR ä¿¡æ¯
            PR_NUMBER=$(echo "$PR_BODY" | jq -r '.number // empty' 2>/dev/null || echo "$PR_BODY" | grep -o '"number":[0-9]*' | head -1 | cut -d':' -f2)
            PR_URL=$(echo "$PR_BODY" | jq -r '.html_url // empty' 2>/dev/null || echo "$PR_BODY" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
            echo "âœ… PR #$PR_NUMBER created: $PR_URL"
            echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
          fi

          # ç¡®ä¿ PR_NUMBER å·²è®¾ç½®
          if [ -z "$PR_NUMBER" ]; then
            echo "âŒ Error: PR_NUMBER is not set"
            exit 1
          fi

          echo "âœ… Using WORKFLOW_PAT to create PR, CI will trigger automatically"

      # Step 2: Merge version update PR (only if needs_increment is true and master branch)
      - name: â³ Wait for PR status update
        id: wait_pr_status
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true'
        shell: bash
        run: |
          echo "â³ Waiting 30s for PR status to be updated and CI to complete..."
          sleep 30

      - name: ğŸ” Check PR mergeable status
        id: check_pr_status
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true'
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"

          if [ -z "$PR_NUMBER" ]; then
            echo "âŒ Error: PR_NUMBER is not set"
            exit 1
          fi

          # ä½¿ç”¨ GITHUB_TOKEN æ£€æŸ¥ PR çŠ¶æ€ï¼ˆé»˜è®¤ tokenï¼Œæœ‰ read æƒé™ï¼‰
          PR_STATUS=$(curl -s \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

          MERGED=$(echo "$PR_STATUS" | grep -o '"merged":[^,}]*' | cut -d':' -f2 | tr -d ' "')
          MERGEABLE=$(echo "$PR_STATUS" | grep -o '"mergeable":[^,}]*' | cut -d':' -f2 | tr -d ' "')

          echo "merged=$MERGED" >> $GITHUB_OUTPUT
          echo "mergeable=$MERGEABLE" >> $GITHUB_OUTPUT

      - name: âœ… Handle already merged PR
        id: handle_pr_merged
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          steps.check_pr_status.outputs.merged == 'true'
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          NEW_VERSION="${{ needs.update-version.outputs.version }}"

          echo "âœ… PR already merged"
          echo "pr_merged=true" >> $GITHUB_OUTPUT

          # è·å–åˆå¹¶åçš„ commit SHAï¼ˆä» PR APIï¼‰- ä½¿ç”¨è½®è¯¢æ›¿ä»£å›ºå®šç­‰å¾…
          echo "Step 2.1: Getting merge commit SHA from PR API..."
          MERGE_SHA_MAX_WAIT=10  # æœ€å¤šç­‰å¾… 10 ç§’
          MERGE_SHA_ELAPSED=0
          MERGE_SHA_INTERVAL=1   # æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
          MERGE_COMMIT_SHA=""

          while [ $MERGE_SHA_ELAPSED -lt $MERGE_SHA_MAX_WAIT ] && [ -z "$MERGE_COMMIT_SHA" ]; do
            sleep $MERGE_SHA_INTERVAL
            MERGE_SHA_ELAPSED=$((MERGE_SHA_ELAPSED + MERGE_SHA_INTERVAL))

            PR_INFO=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGE_COMMIT_SHA=$(echo "$PR_INFO" | jq -r '.merge_commit_sha // empty' 2>/dev/null)
            if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
              echo "âœ… Got merge commit SHA: $MERGE_COMMIT_SHA (after ${MERGE_SHA_ELAPSED}s)"
              echo "merge_commit_sha=$MERGE_COMMIT_SHA" >> $GITHUB_OUTPUT
              break
            fi
          done

          if [ -z "$MERGE_COMMIT_SHA" ] || [ "$MERGE_COMMIT_SHA" = "null" ]; then
            echo "âš ï¸  Warning: Could not get merge_commit_sha from PR API after ${MERGE_SHA_MAX_WAIT}s, will use git pull method"
            echo "merge_commit_sha=" >> $GITHUB_OUTPUT
          fi

          # åˆ é™¤è¿œç¨‹åˆ†æ”¯
          echo "Step 2.2: Deleting remote branch"
          BRANCH_NAME="bump-version-${NEW_VERSION}"
          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            git push origin --delete "$BRANCH_NAME" 2>/dev/null || echo "âš ï¸  Failed to delete remote branch (may already be deleted)"
          else
            echo "â„¹ï¸  Remote branch already deleted"
          fi

      - name: â³ Wait for PR to be mergeable
        id: wait_mergeable
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          steps.check_pr_status.outputs.merged != 'true' &&
          (steps.check_pr_status.outputs.mergeable == 'null' || steps.check_pr_status.outputs.mergeable == 'false')
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          MAX_WAIT=300
          INITIAL_CHECK_INTERVAL=3  # å‰ 60 ç§’æ¯ 3 ç§’æ£€æŸ¥ä¸€æ¬¡
          NORMAL_CHECK_INTERVAL=5   # ä¹‹åæ¯ 5 ç§’æ£€æŸ¥ä¸€æ¬¡
          ELAPSED=30  # ä» 30 ç§’å¼€å§‹è®¡æ•°ï¼ˆå·²ç­‰å¾… CI å®Œæˆï¼‰

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # åŠ¨æ€è°ƒæ•´æ£€æŸ¥é—´éš”ï¼ˆå‰ 60 ç§’æ›´é¢‘ç¹æ£€æŸ¥ï¼‰
            if [ $ELAPSED -lt 60 ]; then
              CHECK_INTERVAL=$INITIAL_CHECK_INTERVAL
            else
              CHECK_INTERVAL=$NORMAL_CHECK_INTERVAL
            fi

            # ä½¿ç”¨ GITHUB_TOKEN æ£€æŸ¥ PR çŠ¶æ€ï¼ˆé»˜è®¤ tokenï¼Œæœ‰ read æƒé™ï¼‰
            PR_STATUS=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGED=$(echo "$PR_STATUS" | grep -o '"merged":[^,}]*' | cut -d':' -f2 | tr -d ' "')
            MERGEABLE=$(echo "$PR_STATUS" | grep -o '"mergeable":[^,}]*' | cut -d':' -f2 | tr -d ' "')

            if [ "$MERGED" = "true" ]; then
              echo "âœ… PR already merged"

              # è·å–åˆå¹¶åçš„ commit SHAï¼ˆä» PR APIï¼‰- ä½¿ç”¨è½®è¯¢æ›¿ä»£å›ºå®šç­‰å¾…
              echo "Step 2.1: Getting merge commit SHA from PR API..."
              MERGE_SHA_MAX_WAIT=10  # æœ€å¤šç­‰å¾… 10 ç§’
              MERGE_SHA_ELAPSED=0
              MERGE_SHA_INTERVAL=1   # æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
              MERGE_COMMIT_SHA=""

              while [ $MERGE_SHA_ELAPSED -lt $MERGE_SHA_MAX_WAIT ] && [ -z "$MERGE_COMMIT_SHA" ]; do
                sleep $MERGE_SHA_INTERVAL
                MERGE_SHA_ELAPSED=$((MERGE_SHA_ELAPSED + MERGE_SHA_INTERVAL))

                PR_INFO=$(curl -s \
                  -H "Accept: application/vnd.github+json" \
                  -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

                MERGE_COMMIT_SHA=$(echo "$PR_INFO" | jq -r '.merge_commit_sha // empty' 2>/dev/null)
                if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
                  echo "âœ… Got merge commit SHA: $MERGE_COMMIT_SHA (after ${MERGE_SHA_ELAPSED}s)"
                  echo "merge_commit_sha=$MERGE_COMMIT_SHA" >> $GITHUB_OUTPUT
                  break
                fi
              done

              if [ -z "$MERGE_COMMIT_SHA" ] || [ "$MERGE_COMMIT_SHA" = "null" ]; then
                echo "âš ï¸  Warning: Could not get merge_commit_sha from PR API after ${MERGE_SHA_MAX_WAIT}s, will use git pull method"
                echo "merge_commit_sha=" >> $GITHUB_OUTPUT
              fi

              # åˆ é™¤è¿œç¨‹åˆ†æ”¯
              echo "Step 2.2: Deleting remote branch"
              BRANCH_NAME="bump-version-${NEW_VERSION}"
              if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
                git push origin --delete "$BRANCH_NAME" 2>/dev/null || echo "âš ï¸  Failed to delete remote branch (may already be deleted)"
              else
                echo "â„¹ï¸  Remote branch already deleted"
              fi
              echo "pr_merged=true" >> $GITHUB_OUTPUT
              break
            fi

            # å¦‚æœ mergeable ä¸º nullï¼Œè¯´æ˜ GitHub è¿˜åœ¨è®¡ç®—çŠ¶æ€ï¼Œç»§ç»­ç­‰å¾…
            if [ "$MERGEABLE" = "null" ]; then
              echo "â³ PR mergeable status is still being calculated (elapsed: ${ELAPSED}s), waiting..."
              sleep $CHECK_INTERVAL
              ELAPSED=$((ELAPSED + CHECK_INTERVAL))
              continue
            fi

            # å¦‚æœ mergeable ä¸º falseï¼Œè¯´æ˜ PR æœ‰å†²çªæˆ–æœªé€šè¿‡æ£€æŸ¥ï¼Œè®°å½•å¹¶ç»§ç»­ç­‰å¾…
            if [ "$MERGEABLE" = "false" ]; then
              echo "â³ PR is not mergeable yet (may have conflicts or pending checks, elapsed: ${ELAPSED}s), waiting..."
              sleep $CHECK_INTERVAL
              ELAPSED=$((ELAPSED + CHECK_INTERVAL))
              continue
            fi

            if [ "$MERGEABLE" = "true" ]; then
              echo "âœ… PR is mergeable, proceeding to merge..."
              echo "pr_mergeable=true" >> $GITHUB_OUTPUT
              break
              elif [ "$MERGE_CODE" = "405" ]; then
                # HTTP 405 é€šå¸¸è¡¨ç¤º PR è¿˜æ²¡æœ‰å‡†å¤‡å¥½åˆå¹¶ï¼Œç»§ç»­ç­‰å¾…
                echo "â³ PR not ready to merge yet (HTTP 405), waiting..."
                sleep $CHECK_INTERVAL
                ELAPSED=$((ELAPSED + CHECK_INTERVAL))
                continue
              else
                echo "âš ï¸  Failed to merge PR (HTTP $MERGE_CODE)"
                echo "Response: $MERGE_BODY" | jq '.' 2>/dev/null || echo "$MERGE_BODY"
                echo "Please manually merge: $PR_URL"
                exit 1
              fi
            fi

            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
          done

          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "â° Timeout: PR did not become mergeable within ${MAX_WAIT}s"
            echo "Please manually merge: $PR_URL"
            exit 1
          fi

      - name: ğŸ”€ Merge version update PR
        id: merge_pr
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          steps.check_pr_status.outputs.merged != 'true' &&
          (steps.wait_mergeable.outputs.pr_mergeable == 'true' || steps.check_pr_status.outputs.mergeable == 'true')
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          NEW_VERSION="${{ needs.update-version.outputs.version }}"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Step 2: Merging version update PR"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "â„¹ï¸  Using GITHUB_TOKEN to merge PR (workflow has pull-requests: write permission)"
          echo "ğŸ”€ Attempting to merge PR #$PR_NUMBER..."

          # å°è¯•åˆå¹¶ï¼ˆä½¿ç”¨ GITHUB_TOKENï¼Œworkflow æœ‰ pull-requests: write æƒé™ï¼‰
          MERGE_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/merge" \
            -d '{
              "commit_title": "chore: bump version to '"$NEW_VERSION"'",
              "commit_message": "Automated version bump to '"$NEW_VERSION"'\n\nMerged via GitHub Actions workflow",
              "merge_method": "squash"
            }')

          MERGE_CODE=$(echo "$MERGE_RESPONSE" | tail -n1)
          MERGE_BODY=$(echo "$MERGE_RESPONSE" | head -n-1)

          if [ "$MERGE_CODE" = "200" ]; then
            echo "âœ… PR merged successfully"
            echo "pr_merged=true" >> $GITHUB_OUTPUT
          elif [ "$MERGE_CODE" = "405" ]; then
            echo "âš ï¸  PR not ready to merge yet (HTTP 405), but continuing..."
            echo "pr_merged=false" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to merge PR (HTTP $MERGE_CODE)"
            echo "Response: $MERGE_BODY" | jq '.' 2>/dev/null || echo "$MERGE_BODY"
            exit 1
          fi

      - name: ğŸ” Get merge commit SHA
        id: get_merge_sha
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          (steps.handle_pr_merged.outputs.pr_merged == 'true' || steps.merge_pr.outputs.pr_merged == 'true')
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"

          echo "Step 2.1: Getting merge commit SHA from PR API..."
          MERGE_SHA_MAX_WAIT=10  # æœ€å¤šç­‰å¾… 10 ç§’
          MERGE_SHA_ELAPSED=0
          MERGE_SHA_INTERVAL=1   # æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
          MERGE_COMMIT_SHA=""

          while [ $MERGE_SHA_ELAPSED -lt $MERGE_SHA_MAX_WAIT ] && [ -z "$MERGE_COMMIT_SHA" ]; do
            sleep $MERGE_SHA_INTERVAL
            MERGE_SHA_ELAPSED=$((MERGE_SHA_ELAPSED + MERGE_SHA_INTERVAL))

            PR_INFO=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGE_COMMIT_SHA=$(echo "$PR_INFO" | jq -r '.merge_commit_sha // empty' 2>/dev/null)
            if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
              echo "âœ… Got merge commit SHA: $MERGE_COMMIT_SHA (after ${MERGE_SHA_ELAPSED}s)"
              echo "merge_commit_sha=$MERGE_COMMIT_SHA" >> $GITHUB_OUTPUT
              break
            fi
          done

          if [ -z "$MERGE_COMMIT_SHA" ] || [ "$MERGE_COMMIT_SHA" = "null" ]; then
            echo "âš ï¸  Warning: Could not get merge_commit_sha from PR API after ${MERGE_SHA_MAX_WAIT}s, will use git pull method"
            echo "merge_commit_sha=" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ—‘ï¸ Delete remote branch
        id: delete_branch
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          (steps.handle_pr_merged.outputs.pr_merged == 'true' || steps.merge_pr.outputs.pr_merged == 'true')
        shell: bash
        run: |
          NEW_VERSION="${{ needs.update-version.outputs.version }}"
          BRANCH_NAME="bump-version-${NEW_VERSION}"

          echo "Step 2.2: Deleting remote branch"
          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            git push origin --delete "$BRANCH_NAME" 2>/dev/null || echo "âš ï¸  Failed to delete remote branch (may already be deleted)"
          else
            echo "â„¹ï¸  Remote branch already deleted"
          fi

      # Step 3: Create and push tag
      - name: âš™ï¸ Configure Git for tag creation
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: ğŸ·ï¸ Create and push tag
        shell: bash
        run: |
          TAG="${{ needs.update-version.outputs.tag }}"
          NEW_VERSION="${{ needs.update-version.outputs.version }}"
          IS_MASTER="${{ needs.update-version.outputs.is_master_branch }}"
          NEEDS_INCREMENT="${{ needs.update-version.outputs.needs_increment }}"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Step 3: Creating and pushing tag"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Creating tag: $TAG"

          # Master åˆ†æ”¯ï¼šå¦‚æœ PR å·²åˆå¹¶ï¼Œä½¿ç”¨ merge_commit_sha æˆ–æ‹‰å–æœ€æ–°çš„ master åˆ†æ”¯
          if [ "$IS_MASTER" == "true" ] && [ "$NEEDS_INCREMENT" == "true" ]; then
            MERGE_COMMIT_SHA="${{ steps.handle_pr_merged.outputs.merge_commit_sha || steps.get_merge_sha.outputs.merge_commit_sha }}"

            if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
              # ä½¿ç”¨ä» PR API è·å–çš„ merge_commit_sha
              echo "Step 3.1: Using merge_commit_sha from PR API: $MERGE_COMMIT_SHA"
              TAG_COMMIT_SHA="$MERGE_COMMIT_SHA"

              # éªŒè¯è¯¥ commit æ˜¯å¦å­˜åœ¨
              if git cat-file -e "$TAG_COMMIT_SHA" 2>/dev/null; then
                echo "âœ… Merge commit exists locally"
              else
                echo "Step 3.2: Fetching merge commit from origin..."
                # å°è¯•é€šè¿‡ refs è·å– commit
                git fetch origin "$TAG_COMMIT_SHA" 2>/dev/null || \
                git fetch origin "+refs/heads/*:refs/remotes/origin/*" 2>/dev/null || true
                if ! git cat-file -e "$TAG_COMMIT_SHA" 2>/dev/null; then
                  echo "âš ï¸  Warning: Merge commit not found, falling back to git pull method"
                  TAG_COMMIT_SHA=""
                fi
              fi
            else
              TAG_COMMIT_SHA=""
            fi

            # å¦‚æœæ²¡æœ‰ merge_commit_shaï¼Œä½¿ç”¨ git pull æ–¹æ³•ï¼ˆå›é€€æ–¹æ¡ˆï¼‰
            if [ -z "$TAG_COMMIT_SHA" ]; then
              echo "Step 3.1: Fetching latest changes from origin (after PR merge)..."
              # å°è¯•è·å–é»˜è®¤åˆ†æ”¯åç§°ï¼ˆmaster æˆ– mainï¼‰
              DEFAULT_BRANCH=$(git remote show origin | grep "HEAD branch" | cut -d' ' -f5 || echo "master")
              echo "Detected default branch: $DEFAULT_BRANCH"

              git fetch origin "$DEFAULT_BRANCH:$DEFAULT_BRANCH" 2>/dev/null || true

              echo "Step 3.2: Checking out $DEFAULT_BRANCH branch..."
              git checkout "$DEFAULT_BRANCH" 2>/dev/null || true

              echo "Step 3.3: Pulling latest changes..."
              git pull origin "$DEFAULT_BRANCH" 2>/dev/null || true

              # éªŒè¯å½“å‰æäº¤åŒ…å«ç‰ˆæœ¬æ›´æ–°
              echo "Step 3.4: Verifying current commit..."
              LATEST_COMMIT_MSG=$(git log -1 --format='%s' HEAD)
              TAG_COMMIT_SHA=$(git rev-parse HEAD)
              echo "Latest commit SHA: $TAG_COMMIT_SHA"
              echo "Latest commit message: $LATEST_COMMIT_MSG"

              if [[ "$LATEST_COMMIT_MSG" =~ "bump version" ]] || [[ "$LATEST_COMMIT_MSG" =~ "chore: bump version" ]]; then
                echo "âœ… Found version bump commit on master"
              else
                echo "âš ï¸  Warning: Latest commit may not be the version bump commit"
                echo "   This might happen if PR was merged with a different commit message"
                echo "   Continuing to create tag on current commit..."
              fi
            fi
          else
            # é Master åˆ†æ”¯ï¼šä½¿ç”¨å½“å‰åˆ†æ”¯çš„ commit
            echo "Step 3.1: Using current branch for tag creation (non-master branch)"
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            TAG_COMMIT_SHA=$(git rev-parse HEAD)
            echo "Current branch: $CURRENT_BRANCH"
            echo "Current commit SHA: $TAG_COMMIT_SHA"
          fi

          # æ£€æŸ¥ tag æ˜¯å¦å·²å­˜åœ¨
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            EXISTING_TAG_SHA=$(git rev-parse "$TAG")
            if [ "$EXISTING_TAG_SHA" = "$TAG_COMMIT_SHA" ]; then
              echo "âœ… Tag $TAG already exists and points to the correct commit: $TAG_COMMIT_SHA"
            else
              echo "âš ï¸  Warning: Tag $TAG already exists but points to different commit"
              echo "   Existing tag SHA: $EXISTING_TAG_SHA"
              echo "   Target commit SHA: $TAG_COMMIT_SHA"
              echo "   Deleting existing tag and recreating..."
              git tag -d "$TAG" 2>/dev/null || true
              git push origin ":refs/tags/$TAG" 2>/dev/null || true
            fi
          fi

          # åˆ›å»º tagï¼ˆåŸºäºæŒ‡å®šçš„ commit SHAï¼‰
          echo "Step 3.5: Creating tag $TAG on commit $TAG_COMMIT_SHA..."
          git tag "$TAG" "$TAG_COMMIT_SHA"

          # æ¨é€ tagï¼ˆä½¿ç”¨ PATï¼Œå› ä¸º tag å¯èƒ½æŒ‡å‘ä¿®æ”¹äº† workflow æ–‡ä»¶çš„ commitï¼‰
          # æ³¨æ„ï¼šå½“ tag æŒ‡å‘çš„ commit ä¿®æ”¹äº† workflow æ–‡ä»¶æ—¶ï¼ŒGITHUB_TOKEN æ— æ³•æ¨é€ï¼Œå¿…é¡»ä½¿ç”¨ PAT
          echo "Step 3.6: Pushing tag: $TAG"
          echo "â„¹ï¸  Using WORKFLOW_PAT to push tag (required when tag points to commit that modifies workflow files)"
          if git push origin "$TAG" 2>&1; then
            echo "âœ… Successfully created and pushed tag: $TAG"
          else
            PUSH_ERROR=$?
            echo "âŒ Error: Failed to push tag: $TAG (exit code: $PUSH_ERROR)"
            echo "Checking if tag already exists remotely..."
            if git ls-remote --tags origin "$TAG" | grep -q "$TAG"; then
              REMOTE_TAG_SHA=$(git ls-remote --tags origin "$TAG" | cut -f1)
              if [ "$REMOTE_TAG_SHA" = "$TAG_COMMIT_SHA" ]; then
                echo "âœ… Tag already exists remotely and points to the correct commit"
                echo "   Remote tag SHA: $REMOTE_TAG_SHA"
                echo "   Target commit SHA: $TAG_COMMIT_SHA"
              else
                echo "âš ï¸  Warning: Tag exists remotely but points to different commit"
                echo "   Remote tag SHA: $REMOTE_TAG_SHA"
                echo "   Target commit SHA: $TAG_COMMIT_SHA"
                echo "   This may indicate a conflict. Please check manually."
                exit 1
              fi
            else
              echo "âŒ Tag does not exist remotely. Push failed."
              exit 1
            fi
          fi

      # Step 4: Set job outputs
      - name: ğŸ“Š Set job outputs for downstream jobs
        id: job_outputs
        shell: bash
        run: |
          VERSION="${{ needs.update-version.outputs.version }}"
          TAG="${{ needs.update-version.outputs.tag }}"
          IS_MASTER="${{ needs.update-version.outputs.is_master_branch }}"
          NEEDS_INCREMENT="${{ needs.update-version.outputs.needs_increment }}"

          # æ£€æŸ¥æ˜¯å¦åˆ›å»ºäº†æ–° tag
          if [ "$IS_MASTER" == "true" ]; then
            # Master åˆ†æ”¯ï¼šæ£€æŸ¥æ˜¯å¦åˆ›å»ºäº†æ–° tag
            if [ "$NEEDS_INCREMENT" == "true" ]; then
              # éœ€è¦é€’å¢ç‰ˆæœ¬å·ï¼Œä¼šåˆ›å»ºæ–° tag
              TAG_CREATED="true"
            else
              # æ£€æŸ¥ tag æ˜¯å¦å·²å­˜åœ¨
              if git rev-parse "$TAG" >/dev/null 2>&1; then
                TAG_CREATED="false"
              else
                TAG_CREATED="true"
              fi
            fi
          else
            # é Master åˆ†æ”¯ï¼šæ£€æŸ¥ tag æ˜¯å¦å·²å­˜åœ¨
            if git rev-parse "$TAG" >/dev/null 2>&1; then
              TAG_CREATED="false"
              echo "â„¹ï¸  Tag already exists: $TAG"
            else
              TAG_CREATED="true"
              echo "â„¹ï¸  Created new pre-release tag: $TAG"
            fi
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "tag_created=$TAG_CREATED" >> $GITHUB_OUTPUT
          echo "âœ… Job outputs set: version=$VERSION, tag=$TAG, tag_created=$TAG_CREATED"

  # åˆ›å»º GitHub Release
  release:
    name: ğŸš€ Create Release
    runs-on: ubuntu-latest
    needs: [update-version, create-tag, build, release-confirm]
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master' && needs.update-version.result == 'success' && needs.create-tag.result == 'success' && needs.build.result == 'success' && needs.release-confirm.result == 'success') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.update-version.result == 'success' && needs.create-tag.result == 'success' && needs.build.result == 'success' && needs.release-confirm.result == 'success' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ” Get version and tag from previous jobs
        id: version
        shell: bash
        run: |
          VERSION="${{ needs.update-version.outputs.version }}"
          # å¦‚æœ create-tag job æˆåŠŸè¿è¡Œï¼Œä½¿ç”¨å…¶ outputsï¼›å¦åˆ™ä½¿ç”¨ update-version çš„ outputs
          if [ "${{ needs.create-tag.result }}" == "success" ] && [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
            TAG="${{ needs.create-tag.outputs.tag }}"
            echo "âœ… Using tag from create-tag job: $TAG"
          else
            TAG="${{ needs.update-version.outputs.tag }}"
            echo "âœ… Using tag from update-version job: $TAG"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: $TAG"

      - name: ğŸ“¥ Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: ğŸ“ Prepare release info
        id: release_info
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IS_MASTER="${{ needs.update-version.outputs.is_master_branch }}"

          if [ "$IS_MASTER" == "true" ]; then
            RELEASE_NAME="Release $VERSION"
            RELEASE_BODY="## Release $VERSION

            See the [changelog](https://github.com/${{ github.repository }}/blob/master/CHANGELOG.md) for details."
          else
            RELEASE_NAME="Pre-release $VERSION"
            RELEASE_BODY="## Pre-release $VERSION

            âš ï¸ **This is a pre-release version** (alpha build)

            See the [changelog](https://github.com/${{ github.repository }}/blob/master/CHANGELOG.md) for details."
          fi

          # ä½¿ç”¨å¤šè¡Œè¾“å‡ºï¼ˆä½¿ç”¨ EOF åˆ†éš”ç¬¦ï¼‰
          {
            echo "name<<EOF"
            echo "$RELEASE_NAME"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          {
            echo "body<<EOF"
            echo "$RELEASE_BODY"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "âœ… Release name: $RELEASE_NAME"
          echo "âœ… Is pre-release: $([ "$IS_MASTER" != "true" ] && echo "true" || echo "false")"

      - name: ğŸš€ Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: ${{ steps.release_info.outputs.name }}
          body: ${{ steps.release_info.outputs.body }}
          files: |
            artifacts/**/*
          draft: false
          prerelease: ${{ needs.update-version.outputs.is_master_branch != 'true' }}

  # æ›´æ–° Homebrew Formula
  # æ³¨æ„ï¼šåªåœ¨ master åˆ†æ”¯çš„ push äº‹ä»¶æ—¶æ›´æ–°ï¼Œé master åˆ†æ”¯ä¸æ›´æ–°
  update-homebrew:
    name: ğŸº Update Homebrew Formula
    runs-on: ubuntu-latest
    needs: [update-version, create-tag, build, release]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.update-version.result == 'success' && needs.create-tag.result == 'success' && needs.build.result == 'success' && needs.release.result == 'success' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ” Get version and tag from previous jobs
        id: version
        shell: bash
        run: |
          VERSION="${{ needs.update-version.outputs.version }}"
          # å¦‚æœ create-tag job æˆåŠŸè¿è¡Œï¼Œä½¿ç”¨å…¶ outputsï¼›å¦åˆ™ä½¿ç”¨ update-version çš„ outputs
          if [ "${{ needs.create-tag.result }}" == "success" ] && [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
            TAG="${{ needs.create-tag.outputs.tag }}"
            echo "âœ… Using tag from create-tag job: $TAG"
          else
            TAG="${{ needs.update-version.outputs.tag }}"
            echo "âœ… Using tag from update-version job: $TAG"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: $TAG"

      - name: ğŸ“¥ Checkout homebrew-workflow
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/homebrew-workflow
          token: ${{ secrets.WORKFLOW_PAT }}
          path: homebrew-workflow

      - name: ğŸ“ Generate Formula file
        shell: bash
        run: |
          cd homebrew-workflow

          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          FORMULA_FILE="Formula/workflow.rb"

          # å¤‡ä»½åŸå§‹æ–‡ä»¶
          if [ -f "$FORMULA_FILE" ]; then
            cp "$FORMULA_FILE" "$FORMULA_FILE.bak"
          fi

          # ä»æ¨¡æ¿ç”Ÿæˆ Formula æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨æ¨¡æ¿ï¼‰
          # å¦åˆ™ç›´æ¥æ›´æ–°ç°æœ‰æ–‡ä»¶
          if [ -f "Formula/workflow.rb.template" ]; then
            echo "ğŸ“ Generating Formula file from template..."
            sed -e "s|{{VERSION}}|$VERSION|g" \
                -e "s|{{TAG}}|$TAG|g" \
                "Formula/workflow.rb.template" > "$FORMULA_FILE"
            echo "âœ… Formula file generated from template"
          else
            # ç›´æ¥æ›´æ–°ç°æœ‰æ–‡ä»¶ä¸­çš„ç‰ˆæœ¬å·
            echo "ğŸ“ Updating version in Formula file..."
            # è¿™é‡Œéœ€è¦æ ¹æ®å®é™…çš„ Formula æ–‡ä»¶æ ¼å¼æ¥æ›´æ–°
            # é€šå¸¸éœ€è¦æ›´æ–° version å’Œ url å­—æ®µ
            sed -i.bak "s/version \".*\"/version \"$VERSION\"/" "$FORMULA_FILE" || true
            sed -i.bak "s|url \".*\"|url \"https://github.com/${{ github.repository }}/releases/download/$TAG/workflow-$VERSION-x86_64-apple-darwin.tar.gz\"|" "$FORMULA_FILE" || true
            echo "âœ… Formula file updated"
          fi

          # éªŒè¯æ–‡ä»¶ç»“æ„ï¼ˆç¡®ä¿æ²¡æœ‰è¯­æ³•é”™è¯¯ï¼‰
          echo "ğŸ” Validating Formula file structure..."
          if ! ruby -c "$FORMULA_FILE" 2>/dev/null; then
            echo "âŒ Error: Formula file has syntax errors"
            ruby -c "$FORMULA_FILE" || true
            exit 1
          fi
          echo "âœ… Formula file syntax is valid"

          # æ˜¾ç¤ºç”Ÿæˆçš„ Formula æ–‡ä»¶
          echo ""
          echo "ğŸ“„ Generated Formula file:"
          echo "--- Formula/workflow.rb ---"
          cat "$FORMULA_FILE"
          echo ""

          # æ˜¾ç¤ºæ›´æ”¹ï¼ˆå¦‚æœæœ‰å¤‡ä»½ï¼‰
          if [ -f "$FORMULA_FILE.bak" ]; then
            echo "--- Diff (Before vs After) ---"
            diff "$FORMULA_FILE.bak" "$FORMULA_FILE" || true
          fi

      - name: âš™ï¸ Configure Git for Homebrew update
        shell: bash
        run: |
          cd homebrew-workflow
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: ğŸ“¤ Commit and push changes
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          cd homebrew-workflow

          # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
          git add Formula/workflow.rb

          if git diff --staged --quiet; then
            echo "No changes to commit. Formula file is already up to date."
            exit 0
          fi

          # éªŒè¯ Formula æ–‡ä»¶æ ¼å¼
          if ! brew audit --strict Formula/workflow.rb 2>/dev/null; then
            echo "Warning: brew audit failed, but continuing..."
          fi

          # æäº¤æ›´æ”¹
          git commit -m "Update workflow to ${{ steps.version.outputs.tag }}"

          # æ£€æµ‹å½“å‰åˆ†æ”¯åç§°
          CURRENT_BRANCH=$(git branch --show-current)
          echo "Current branch: $CURRENT_BRANCH"

          # actions/checkout@v4 å·²ç»è®¾ç½®äº†æ­£ç¡®çš„è¿œç¨‹ URLï¼Œç›´æ¥æ¨é€å³å¯
          # æ¨é€æ›´æ”¹åˆ°å½“å‰åˆ†æ”¯
          echo "Pushing to branch: $CURRENT_BRANCH"
          if git push origin "$CURRENT_BRANCH"; then
            echo "âœ… Successfully pushed to $CURRENT_BRANCH branch"
          else
            echo "âŒ Error: Failed to push changes to $CURRENT_BRANCH"
            echo "Remote URL: $(git remote get-url origin | sed 's|://.*@|://***@|')"
            echo "Branch: $CURRENT_BRANCH"
            echo "Git status:"
            git status
            echo "Git log:"
            git log --oneline -5
            echo ""
            echo "Possible issues:"
            echo "1. WORKFLOW_PAT may not have write access to ${{ github.repository_owner }}/homebrew-workflow"
            echo "2. Token may have expired or been revoked"
            echo "3. Repository may not exist or be accessible"
            exit 1
          fi

          echo "âœ… Homebrew Formula updated successfully!"

