name: Release

on:
  push:
    branches:
      - master  # ÂΩìÂêàÂπ∂Âà∞ master ÂàÜÊîØÊó∂Ëß¶Âèë
    tags:
      - 'v*'  # ÂåπÈÖçÊâÄÊúâ‰ª• v ÂºÄÂ§¥ÁöÑ tagÔºåÂ¶Ç v0.1.0, v1.0.0
  workflow_dispatch:  # ÂÖÅËÆ∏ÊâãÂä®Ëß¶Âèë
    inputs:
      version:
        description: 'Version tag (e.g., v0.1.0)'
        required: true

# ÈÖçÁΩÆÂ∑•‰ΩúÊµÅÊùÉÈôêÔºåÂÖÅËÆ∏ÂàõÂª∫ Release ÂíåÊõ¥Êñ∞‰ªìÂ∫ì
permissions:
  contents: write  # ÂÖÅËÆ∏ÂàõÂª∫ Release Âíå‰∏ä‰º†Êñá‰ª∂
  pull-requests: write  # ÂÖÅËÆ∏ÂàõÂª∫ PRÔºàÁî®‰∫éÁâàÊú¨Êõ¥Êñ∞Ôºâ
  statuses: write  # ÂÖÅËÆ∏ÂàõÂª∫Áä∂ÊÄÅÊ£ÄÊü•ÔºàÁî®‰∫éÊª°Ë∂≥ÂàÜÊîØ‰øùÊä§ËßÑÂàôÔºâ

env:
  CARGO_TERM_COLOR: always

jobs:
  # ‰ª£Á†ÅË¥®ÈáèÊ£ÄÊü•ÔºàLintÔºâ
  check-lint:
    name: Run check-lint
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Check code format
        run: cargo fmt --check

      - name: Run Clippy
        run: cargo clippy -- -D warnings

      - name: Run cargo check
        run: cargo check
  #
  # ËøêË°åÊµãËØï
  tests:
    name: Run tests
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install system dependencies (Linux)
        run: |
          sudo apt-get update
          # ÂÆâË£Ö XCB ÂºÄÂèëÂ∫ìÔºàclipboard ‰æùËµñÔºâ
          # xcb crate ÈúÄË¶Å xcb-proto Êù•ÁîüÊàê‰ª£Á†ÅÊ®°Âùó
          sudo apt-get install -y \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev

      - name: Run tests
        run: cargo test --verbose
  #
  # Á°Æ‰øùÊâÄÊúâÊ£ÄÊü•ÈÉΩÈÄöËøáÔºàÊ±áÊÄª jobÔºâ
  # Ëøô‰∏™ job ‰æùËµñ‰∫é check-lint Âíå testsÔºåÊ£ÄÊü•ÊâÄÊúâÂøÖÈúÄÊ£ÄÊü•ÁöÑÁä∂ÊÄÅ
  # Â¶ÇÊûú‰ªª‰ΩïÊ£ÄÊü•Â§±Ë¥•ÔºåÊ≠§ job ‰ºöÂ§±Ë¥•Ôºå‰ªéËÄåÈòªÊ≠¢ÂêéÁª≠Êìç‰Ωú
  # Ê≥®ÊÑèÔºöÈúÄË¶ÅÂú® GitHub ‰ªìÂ∫ìËÆæÁΩÆ‰∏≠ÈÖçÁΩÆÂàÜÊîØ‰øùÊä§ËßÑÂàôÔºåÂ∞ÜÊ≠§Â∑•‰ΩúÊµÅËÆæ‰∏∫ÂøÖÈúÄÁöÑÁä∂ÊÄÅÊ£ÄÊü•
  check-status:
    name: Run check-status
    runs-on: ubuntu-latest
    needs: [check-lint, tests]
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      github.event_name == 'workflow_dispatch'
    steps:
      - name: Check lint and test status
        run: |
          if [ "${{ needs.check-lint.result }}" != "success" ] || [ "${{ needs.tests.result }}" != "success" ]; then
            echo "‚ùå Some checks failed:"
            echo "  Lint: ${{ needs.check-lint.result }}"
            echo "  Test: ${{ needs.tests.result }}"
            echo ""
            echo "Cannot proceed until all checks pass."
            exit 1
          fi
          echo "‚úÖ All checks passed!"

  # ÂΩìÂêàÂπ∂Âà∞ master Êó∂Ëá™Âä®ÂàõÂª∫ tagÔºåÊâãÂä®Ëß¶ÂèëÊó∂‰πüËøêË°åÔºà‰ΩÜ‰∏çÂàõÂª∫ tagÔºâ
  create-tag:
    name: Run create-tag
    runs-on: ubuntu-latest
    needs: [check-status]
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.ref == 'refs/heads/master' && github.event_name == 'push')
    permissions:
      contents: write  # ÂÖÅËÆ∏ÂàõÂª∫ÂíåÊé®ÈÄÅ tag
      pull-requests: write  # ÂÖÅËÆ∏ÂàõÂª∫ÂíåÂêàÂπ∂ PRÔºàÁî®‰∫éÁâàÊú¨Êõ¥Êñ∞Ôºâ
    outputs:
      tag: ${{ steps.job_outputs.outputs.tag }}
      tag_created: ${{ steps.job_outputs.outputs.tag_created }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # ÈúÄË¶ÅÂÆåÊï¥ÂéÜÂè≤ËÆ∞ÂΩïÊù•Ê£ÄÊü• tag
          # ‰ΩøÁî®ÈªòËÆ§ÁöÑ GITHUB_TOKENÔºåÊúâ contents: write ÊùÉÈôêÔºåÂèØ‰ª•Êé®ÈÄÅ tag

      - name: Get version from Cargo.toml
        id: version
        shell: bash
        run: |
          # ‰ªé Cargo.toml ËØªÂèñÁâàÊú¨Âè∑
          VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
          if [ -z "$VERSION" ]; then
            echo "‚ùå Error: Cannot read version from Cargo.toml"
            exit 1
          fi
          TAG="v$VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

      - name: Detect branch type and trigger mode
        id: detect_mode
        shell: bash
        run: |
          # Ê£ÄÊµãÊòØÂê¶ÊòØ feature ÂàÜÊîØ
          if [[ "${{ github.ref }}" == refs/heads/feature/* ]]; then
            IS_FEATURE_BRANCH="true"
          else
            IS_FEATURE_BRANCH="false"
          fi

          # Ê£ÄÊµãËß¶ÂèëÁ±ªÂûã
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            IS_MANUAL_TRIGGER="true"
            INPUT_VERSION="${{ github.event.inputs.version }}"
            INPUT_VERSION=${INPUT_VERSION#v}

            # È™åËØÅÁâàÊú¨Ê†ºÂºè
            if [[ "$IS_FEATURE_BRANCH" == "true" ]]; then
              if [[ ! "$INPUT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.(alpha|beta)-[0-9]+$ ]]; then
                echo "‚ùå Error: Feature branch version must be in format: vx.x.x.alpha-xxx or vx.x.x.beta-xxx"
                exit 1
              fi
            else
              if [[ ! "$INPUT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "‚ùå Error: Master branch version must be in standard format: vx.x.x"
                exit 1
              fi
            fi

            SHOULD_CREATE_TAG="false"
          else
            IS_MANUAL_TRIGGER="false"
            if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
              SHOULD_CREATE_TAG="true"
            else
              SHOULD_CREATE_TAG="false"
            fi
          fi

          echo "is_feature_branch=$IS_FEATURE_BRANCH" >> $GITHUB_OUTPUT
          echo "is_manual_trigger=$IS_MANUAL_TRIGGER" >> $GITHUB_OUTPUT
          echo "should_create_tag=$SHOULD_CREATE_TAG" >> $GITHUB_OUTPUT

      - name: Check if tag exists and increment version if needed
        if: steps.detect_mode.outputs.should_create_tag == 'true'
        id: check_tag
        shell: bash
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"

          if git rev-parse "$TAG" >/dev/null 2>&1; then
            if [ "$(git rev-parse HEAD)" = "$(git rev-parse $TAG)" ]; then
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "needs_increment=false" >> $GITHUB_OUTPUT
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "tag=$TAG" >> $GITHUB_OUTPUT
            else
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "needs_increment=true" >> $GITHUB_OUTPUT

              # Ëá™Âä®ÈÄíÂ¢û patch ÁâàÊú¨Âè∑ (0.0.1 -> 0.0.2)
              IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
              MAJOR="${VERSION_PARTS[0]:-0}"
              MINOR="${VERSION_PARTS[1]:-0}"
              PATCH="${VERSION_PARTS[2]:-0}"

              PATCH=$((PATCH + 1))
              if [ $PATCH -gt 9 ]; then
                PATCH=0
                MINOR=$((MINOR + 1))
              fi

              if [ $MINOR -gt 9 ]; then
                MINOR=0
                MAJOR=$((MAJOR + 1))
              fi

              NEW_VERSION="$MAJOR.$MINOR.$PATCH"
              NEW_TAG="v$NEW_VERSION"

              echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
              echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
              echo "old_version=$VERSION" >> $GITHUB_OUTPUT
              echo "old_tag=$TAG" >> $GITHUB_OUTPUT
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "needs_increment=false" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
          fi

      - name: Setup Rust
        if: steps.check_tag.outputs.needs_increment == 'true'
        uses: dtolnay/rust-toolchain@stable

      - name: Update Cargo.toml and Cargo.lock version
        if: steps.check_tag.outputs.needs_increment == 'true'
        shell: bash
        run: |
          NEW_VERSION="${{ steps.check_tag.outputs.version }}"

          # Êõ¥Êñ∞ Cargo.toml ‰∏≠ÁöÑÁâàÊú¨Âè∑
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          else
            sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          fi

          # È™åËØÅ Cargo.toml Êõ¥Êñ∞
          UPDATED_VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "‚ùå Error: Failed to update version in Cargo.toml"
            exit 1
          fi

          # Êõ¥Êñ∞ Cargo.lock ‰∏≠ÁöÑÁâàÊú¨Âè∑
          if grep -q 'name = "workflow"' Cargo.lock; then
            if [[ "$OSTYPE" == "darwin"* ]]; then
              sed -i '' '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            else
              sed -i '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            fi
          fi

      - name: Create and merge version update pull request
        if: steps.check_tag.outputs.needs_increment == 'true'
        shell: bash
        env:
          # ‰ΩøÁî® WORKFLOW_PAT ÂàõÂª∫ PRÔºåËøôÊ†∑ÂèØ‰ª•Ëß¶ÂèëÂêéÁª≠ÁöÑ workflow
          WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
        run: |
          # ÈÖçÁΩÆ Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          NEW_VERSION="${{ steps.check_tag.outputs.version }}"
          BRANCH_NAME="bump-version-${NEW_VERSION}"

          # Á¨¨‰∏ÄÊ≠•ÔºöÂàõÂª∫Êñ∞ÂàÜÊîØ
          echo "Step 1: Creating branch $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"

          # Á¨¨‰∫åÊ≠•ÔºöÊ∑ªÂä†Êñá‰ª∂
          echo "Step 2: Staging Cargo.toml and Cargo.lock"
          git add Cargo.toml Cargo.lock

          # Á¨¨‰∏âÊ≠•ÔºöÊèê‰∫§Êõ¥Êîπ
          echo "Step 3: Committing changes"
          git commit -m "chore: bump version to ${NEW_VERSION}"

          # Á¨¨ÂõõÊ≠•ÔºöÊé®ÈÄÅÂà∞Êñ∞ÂàÜÊîØ
          echo "Step 4: Pushing branch to origin"
          git push origin "$BRANCH_NAME"

          # Á¨¨‰∫îÊ≠•ÔºöÂàõÂª∫ Pull RequestÔºà‰ΩøÁî® WORKFLOW_PAT ‰ª•Ëß¶Âèë CIÔºâ
          echo "Step 5: Creating Pull Request"
          echo "Branch: $BRANCH_NAME"
          echo "Version: $NEW_VERSION"

          PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $WORKFLOW_PAT" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" \
            -d '{
              "title": "chore: bump version to '"$NEW_VERSION"'",
              "head": "'"$BRANCH_NAME"'",
              "base": "master",
              "body": "Automated version bump to '"$NEW_VERSION"'\n\nThis PR was created automatically by the release workflow.\n\n**Changes:**\n- Updated version in Cargo.toml to '"$NEW_VERSION"'\n- Updated version in Cargo.lock to '"$NEW_VERSION"'\n\n**Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }')

          HTTP_CODE=$(echo "$PR_RESPONSE" | tail -n1)
          PR_BODY=$(echo "$PR_RESPONSE" | head -n-1)

          echo "HTTP Status Code: $HTTP_CODE"

          if [ "$HTTP_CODE" != "201" ]; then
            echo "‚ö†Ô∏è  Failed to create PR (HTTP $HTTP_CODE)"
            echo "Response body:"
            echo "$PR_BODY" | jq '.' 2>/dev/null || echo "$PR_BODY"

            # Â¶ÇÊûúÊòØ 422 ÈîôËØØÔºàÂ∑≤Â≠òÂú® PRÔºâÔºåÂ∞ùËØïÊü•ÊâæÁé∞ÊúâÁöÑ PR
            if [ "$HTTP_CODE" = "422" ]; then
              echo "Checking for existing PR..."
              EXISTING_PR=$(curl -s \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer $WORKFLOW_PAT" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:$BRANCH_NAME&base=master&state=open")

              PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.[0].number // empty' 2>/dev/null)
              if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
                PR_URL=$(echo "$EXISTING_PR" | jq -r '.[0].html_url // empty' 2>/dev/null)
                echo "‚úÖ Found existing PR #$PR_NUMBER: $PR_URL"
                echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
                echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
                # ÁªßÁª≠ÊâßË°åÂêàÂπ∂Ê≠•È™§
              else
                exit 1
              fi
            else
              exit 1
            fi
          else
            # ÊèêÂèñ PR ‰ø°ÊÅØ
            PR_NUMBER=$(echo "$PR_BODY" | jq -r '.number // empty' 2>/dev/null || echo "$PR_BODY" | grep -o '"number":[0-9]*' | head -1 | cut -d':' -f2)
            PR_URL=$(echo "$PR_BODY" | jq -r '.html_url // empty' 2>/dev/null || echo "$PR_BODY" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
            echo "‚úÖ PR #$PR_NUMBER created: $PR_URL"
            echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
          fi

          # Á°Æ‰øù PR_NUMBER Â∑≤ËÆæÁΩÆ
          if [ -z "$PR_NUMBER" ]; then
            echo "‚ùå Error: PR_NUMBER is not set"
            exit 1
          fi

          # ‰ΩøÁî® WORKFLOW_PAT ÂàõÂª∫ PRÔºåCI ‰ºöËá™Âä®Ëß¶Âèë
          echo "‚úÖ Using WORKFLOW_PAT to create PR, CI will trigger automatically"

          # Á¨¨‰∏ÉÊ≠•ÔºöÂêàÂπ∂ Pull RequestÔºà‰ΩøÁî® GITHUB_TOKENÔºâ
          echo "Step 6: Merging Pull Request"
          echo "‚ÑπÔ∏è  Using GITHUB_TOKEN to merge PR (workflow has pull-requests: write permission)"

          # ÂàùÂßãÁ≠âÂæÖÊó∂Èó¥ÔºåËÆ© GitHub ÊúâÊó∂Èó¥Êõ¥Êñ∞ PR Áä∂ÊÄÅÂíåËß¶Âèë CI
          echo "‚è≥ Waiting 30s for PR status to be updated..."
          sleep 30

          # Á≠âÂæÖ PR ÂèØÂêàÂπ∂ÔºàÊúÄÂ§öÁ≠âÂæÖ 5 ÂàÜÈíüÔºåÊØè 5 ÁßíÊ£ÄÊü•‰∏ÄÊ¨°Ôºâ
          MAX_WAIT=300
          CHECK_INTERVAL=5
          ELAPSED=30  # ‰ªé 30 ÁßíÂºÄÂßãËÆ°Êï∞ÔºåÂõ†‰∏∫Â∑≤ÁªèÁ≠âÂæÖ‰∫Ü 30 Áßí

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # ‰ΩøÁî® GITHUB_TOKEN Ê£ÄÊü• PR Áä∂ÊÄÅÔºàÈªòËÆ§ tokenÔºåÊúâ read ÊùÉÈôêÔºâ
            PR_STATUS=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGED=$(echo "$PR_STATUS" | grep -o '"merged":[^,}]*' | cut -d':' -f2 | tr -d ' "')
            MERGEABLE=$(echo "$PR_STATUS" | grep -o '"mergeable":[^,}]*' | cut -d':' -f2 | tr -d ' "')

            if [ "$MERGED" = "true" ]; then
              echo "‚úÖ PR already merged"
              # Á¨¨ÂÖ´Ê≠•ÔºöÂà†Èô§ËøúÁ®ãÂàÜÊîØ
              echo "Step 7: Deleting remote branch $BRANCH_NAME"
              # ÂÖàÂàáÊç¢Âõû master ÂàÜÊîØ
              git checkout master 2>/dev/null || git checkout main 2>/dev/null || true
              # Âà†Èô§ËøúÁ®ãÂàÜÊîØ
              if git push origin --delete "$BRANCH_NAME" 2>/dev/null; then
                echo "‚úÖ Remote branch $BRANCH_NAME deleted successfully"
              else
                echo "‚ö†Ô∏è  Failed to delete remote branch (may already be deleted or protected)"
              fi
              exit 0
            fi

            # Â¶ÇÊûú mergeable ‰∏∫ nullÔºåËØ¥Êòé GitHub ËøòÂú®ËÆ°ÁÆóÁä∂ÊÄÅÔºåÁªßÁª≠Á≠âÂæÖ
            if [ "$MERGEABLE" = "null" ]; then
              echo "‚è≥ PR mergeable status is still being calculated (elapsed: ${ELAPSED}s), waiting..."
              sleep $CHECK_INTERVAL
              ELAPSED=$((ELAPSED + CHECK_INTERVAL))
              continue
            fi

            # Â¶ÇÊûú mergeable ‰∏∫ falseÔºåËØ¥Êòé PR ÊúâÂÜ≤Á™ÅÊàñÊú™ÈÄöËøáÊ£ÄÊü•ÔºåËÆ∞ÂΩïÂπ∂ÁªßÁª≠Á≠âÂæÖ
            if [ "$MERGEABLE" = "false" ]; then
              echo "‚è≥ PR is not mergeable yet (may have conflicts or pending checks, elapsed: ${ELAPSED}s), waiting..."
              sleep $CHECK_INTERVAL
              ELAPSED=$((ELAPSED + CHECK_INTERVAL))
              continue
            fi

            if [ "$MERGEABLE" = "true" ]; then
              echo "üîÄ Attempting to merge PR #$PR_NUMBER..."
              # Â∞ùËØïÂêàÂπ∂Ôºà‰ΩøÁî® GITHUB_TOKENÔºåworkflow Êúâ pull-requests: write ÊùÉÈôêÔºâ
              MERGE_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/merge" \
                -d '{
                  "commit_title": "chore: bump version to '"$NEW_VERSION"'",
                  "commit_message": "Automated version bump to '"$NEW_VERSION"'\n\nMerged via GitHub Actions workflow",
                  "merge_method": "squash"
                }')

              MERGE_CODE=$(echo "$MERGE_RESPONSE" | tail -n1)
              MERGE_BODY=$(echo "$MERGE_RESPONSE" | head -n-1)

              if [ "$MERGE_CODE" = "200" ]; then
                echo "‚úÖ PR merged successfully"
                # Á¨¨ÂÖ´Ê≠•ÔºöÂà†Èô§ËøúÁ®ãÂàÜÊîØ
                echo "Step 7: Deleting remote branch $BRANCH_NAME"
                # ÂÖàÂàáÊç¢Âõû master ÂàÜÊîØ
                git checkout master 2>/dev/null || git checkout main 2>/dev/null || true
                # Âà†Èô§ËøúÁ®ãÂàÜÊîØ
                if git push origin --delete "$BRANCH_NAME" 2>/dev/null; then
                  echo "‚úÖ Remote branch $BRANCH_NAME deleted successfully"
                else
                  echo "‚ö†Ô∏è  Failed to delete remote branch (may already be deleted or protected)"
                fi
                exit 0
              elif [ "$MERGE_CODE" = "405" ]; then
                # HTTP 405 ÈÄöÂ∏∏Ë°®Á§∫ PR ËøòÊ≤°ÊúâÂáÜÂ§áÂ•ΩÂêàÂπ∂ÔºåÁªßÁª≠Á≠âÂæÖ
                echo "‚è≥ PR not ready to merge yet (HTTP 405), waiting..."
                sleep $CHECK_INTERVAL
                ELAPSED=$((ELAPSED + CHECK_INTERVAL))
                continue
              else
                echo "‚ö†Ô∏è  Failed to merge PR (HTTP $MERGE_CODE)"
                echo "Response: $MERGE_BODY" | jq '.' 2>/dev/null || echo "$MERGE_BODY"
                echo "Please manually merge: $PR_URL"
                exit 1
              fi
            fi

            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
          done

          echo "‚è∞ Timeout: PR did not become mergeable within ${MAX_WAIT}s"
          echo "Please manually merge: $PR_URL"
          exit 1

      - name: Create and push tag
        if: |
          steps.detect_mode.outputs.should_create_tag == 'true' &&
          (steps.check_tag.outputs.exists == 'false' || steps.check_tag.outputs.needs_increment == 'true')
        shell: bash
        run: |
          TAG="${{ steps.check_tag.outputs.tag }}"
          echo "Creating tag: $TAG"

          # ÈÖçÁΩÆ Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Á°Æ‰øùÂú®ÊúÄÊñ∞ÁöÑ master ÂàÜÊîØ‰∏äÂàõÂª∫ tagÔºàPR ÂêàÂπ∂ÂêéÔºâ
          echo "üì• Fetching latest changes from origin..."
          git fetch origin master:master 2>/dev/null || git fetch origin main:main 2>/dev/null || true

          # checkout Âà∞ master ÂàÜÊîØ
          echo "üîÑ Checking out master branch..."
          git checkout master 2>/dev/null || git checkout main 2>/dev/null || true

          # ÊãâÂèñÊúÄÊñ∞ÁöÑ‰ª£Á†ÅÔºàÂåÖÂê´ÂêàÂπ∂ÂêéÁöÑÊèê‰∫§Ôºâ
          echo "‚¨áÔ∏è  Pulling latest changes..."
          git pull origin master 2>/dev/null || git pull origin main 2>/dev/null || true

          # È™åËØÅÂΩìÂâçÊèê‰∫§ÂåÖÂê´ÁâàÊú¨Êõ¥Êñ∞
          echo "üîç Verifying current commit..."
          LATEST_COMMIT_MSG=$(git log -1 --format='%s' HEAD)
          LATEST_COMMIT_SHA=$(git rev-parse HEAD)
          echo "Latest commit SHA: $LATEST_COMMIT_SHA"
          echo "Latest commit message: $LATEST_COMMIT_MSG"

          if [[ "$LATEST_COMMIT_MSG" =~ "bump version" ]] || [[ "$LATEST_COMMIT_MSG" =~ "chore: bump version" ]]; then
            echo "‚úÖ Found version bump commit on master"
          else
            echo "‚ö†Ô∏è  Warning: Latest commit may not be the version bump commit"
            echo "   This might happen if PR was merged with a different commit message"
            echo "   Continuing to create tag on current commit..."
          fi

          # ÂàõÂª∫ tagÔºàÂü∫‰∫éÂΩìÂâç HEADÔºåÂç≥ÊúÄÊñ∞ÁöÑ master Êèê‰∫§Ôºâ
          echo "üè∑Ô∏è  Creating tag $TAG on commit $LATEST_COMMIT_SHA..."
          git tag "$TAG"

          # Êé®ÈÄÅ tagÔºà‰ΩøÁî® GITHUB_TOKENÔºåworkflow Êúâ contents: write ÊùÉÈôêÔºâ
          echo "üì§ Pushing tag: $TAG"
          echo "‚ÑπÔ∏è  Using GITHUB_TOKEN to push tag (workflow has contents: write permission)"
          git push origin "$TAG"

          echo "‚úÖ Successfully created and pushed tag: $TAG"
          echo "‚ÑπÔ∏è  This tag push will trigger a new workflow run for building and releasing"

      - name: Set job outputs
        id: job_outputs
        shell: bash
        run: |
          # Â¶ÇÊûúÊòØ feature ÂàÜÊîØÊâãÂä®Ëß¶ÂèëÔºå‰ΩøÁî® version Ê≠•È™§ÁöÑ outputsÔºå‰∏çÂàõÂª∫ tag
          if [[ "${{ steps.detect_mode.outputs.is_feature_branch }}" == "true" && "${{ steps.detect_mode.outputs.is_manual_trigger }}" == "true" ]]; then
            TAG="${{ steps.version.outputs.tag }}"
            TAG_CREATED="false"
            echo "‚ÑπÔ∏è  Feature branch manual trigger: using version from Cargo.toml, tag_created=false"
          elif [[ "${{ steps.detect_mode.outputs.should_create_tag }}" == "true" ]]; then
            # Ê≠£Â∏∏ÊµÅÁ®ãÔºö‰ΩøÁî® check_tag ÁöÑ outputs
            TAG="${{ steps.check_tag.outputs.tag }}"
            TAG_CREATED="false"
            if [ "${{ steps.check_tag.outputs.exists }}" == "false" ] || [ "${{ steps.check_tag.outputs.needs_increment }}" == "true" ]; then
              TAG_CREATED="true"
            fi
          else
            # ÂÖ∂‰ªñÊÉÖÂÜµÔºà‰∏çÂ∫îËØ•Âà∞ËææËøôÈáåÔºå‰ΩÜ‰∏∫‰∫ÜÂÆâÂÖ®Ôºâ
            TAG="${{ steps.version.outputs.tag }}"
            TAG_CREATED="false"
            echo "‚ö†Ô∏è  Unexpected condition, using version from Cargo.toml"
          fi

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "tag_created=$TAG_CREATED" >> $GITHUB_OUTPUT
          echo "‚úÖ Job outputs set: tag=$TAG, tag_created=$TAG_CREATED"

      - name: Skip tag creation
        if: |
          steps.detect_mode.outputs.should_create_tag == 'true' &&
          steps.check_tag.outputs.exists == 'true' &&
          steps.check_tag.outputs.needs_increment == 'false'
        shell: bash
        run: |
          echo "‚è≠Ô∏è  Skipping tag creation: tag ${{ steps.check_tag.outputs.tag }} already exists and points to current commit"

      - name: Skip tag creation (feature branch)
        if: |
          steps.detect_mode.outputs.is_feature_branch == 'true' &&
          steps.detect_mode.outputs.is_manual_trigger == 'true'
        shell: bash
        run: |
          echo "‚ÑπÔ∏è  Feature branch manual trigger: skipping tag creation"
          echo "   Branch: ${{ github.ref }}"
          echo "   Version: ${{ steps.version.outputs.version }}"
          echo "   Tag: ${{ steps.version.outputs.tag }}"

  # ÊûÑÂª∫ÊâÄÊúâÂπ≥Âè∞ÁöÑ‰∫åËøõÂà∂Êñá‰ª∂
  build:
    runs-on: ${{ matrix.os }}
    needs: [check-status, create-tag]
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true')
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: macOS-Intel
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: macOS-AppleSilicon
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            platform: Linux-x86_64
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            platform: Linux-ARM64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            platform: Linux-x86_64-static
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            platform: Windows-x86_64
          - os: windows-latest
            target: aarch64-pc-windows-msvc
            platform: Windows-ARM64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Â¶ÇÊûúÊòØ master push ‰∏î create-tag ÂàõÂª∫‰∫ÜÊñ∞ tagÔºåcheckout ËØ• tagÔºàÂåÖÂê´Êõ¥Êñ∞ÂêéÁöÑ Cargo.tomlÔºâ
          # Âê¶Âàô checkout ÂéüÂßãÁöÑ refÔºàtag push Êàñ workflow_dispatch ÁöÑÊÉÖÂÜµÔºâ
          ref: ${{ (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true' && needs.create-tag.outputs.tag) || github.ref }}

      - name: Get version from tag
        id: version
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            # ÁßªÈô§ v ÂâçÁºÄÔºàÂ¶ÇÊûúÊúâÔºâ
            VERSION=${VERSION#v}
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # ‰ªéÊ†áÁ≠æËé∑ÂèñÁâàÊú¨Âè∑
            VERSION=${GITHUB_REF#refs/tags/}
            # ÁßªÈô§ v ÂâçÁºÄÔºàÂ¶ÇÊûúÊúâÔºâ
            VERSION=${VERSION#v}
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            # ‰ªé create-tag job ÁöÑ outputs Ëé∑ÂèñÁâàÊú¨Âè∑
            if [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
              VERSION="${{ needs.create-tag.outputs.tag }}"
              # ÁßªÈô§ v ÂâçÁºÄÔºàÂ¶ÇÊûúÊúâÔºâ
              VERSION=${VERSION#v}
            else
              # Â¶ÇÊûú outputs ‰∏çÂèØÁî®Ôºå‰ªé Cargo.toml ËØªÂèñ
              VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
              if [ -z "$VERSION" ]; then
                echo "‚ùå Error: Cannot read version from Cargo.toml"
                exit 1
              fi
            fi
          else
            echo "‚ùå Error: Cannot determine version from context"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo "‚úÖ Version: $VERSION"
          echo "‚úÖ Tag: v$VERSION"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install musl target (if needed)
        if: contains(matrix.target, 'musl')
        run: |
          rustup target add ${{ matrix.target }}
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: Install cross-compilation toolchain (Linux ARM64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu python3
          # Ê≥®ÊÑèÔºöclipboard ÂäüËÉΩÂú® Linux ARM64 ‰∏äÂ∑≤Á¶ÅÁî®ÔºàCargo.toml ‰∏≠ÈÖçÁΩÆÔºâ
          # Âõ†Ê≠§‰∏çÈúÄË¶ÅÂÆâË£Ö XCB ÂºÄÂèëÂ∫ìÔºåÁÆÄÂåñÊûÑÂª∫ÊµÅÁ®ã
          # ‰ΩÜÈúÄË¶ÅÂÆâË£Ö Python3 Áî®‰∫éÂ§ÑÁêÜ Cargo.lock ËÑöÊú¨

      - name: Install system dependencies (Linux x86_64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'x86_64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          # ÂÆâË£Ö XCB ÂºÄÂèëÂ∫ìÔºàclipboard ‰æùËµñÔºâ
          # xcb crate ÈúÄË¶Å xcb-proto Êù•ÁîüÊàê‰ª£Á†ÅÊ®°ÂùóÔºàxproto, big_requests, etc.Ôºâ
          # xcb-proto ÈúÄË¶Å Python Êù•ËøêË°å‰ª£Á†ÅÁîüÊàêËÑöÊú¨
          sudo apt-get install -y \
            python3 \
            python3-pip \
            python3-xcbgen \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev \
            pkg-config
          # È™åËØÅ xcb-proto ÂåÖÂíå Python Â∑≤Ê≠£Á°ÆÂÆâË£Ö
          echo "üîç Verifying xcb-proto package installation..."
          # xcb-proto ‰∏çÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÁ®ãÂ∫èÔºåËÄåÊòØ‰∏Ä‰∏™ÂåÖÂê´ÂçèËÆÆÊèèËø∞Êñá‰ª∂ÁöÑÂåÖ
          if dpkg -l | grep -q "^ii.*xcb-proto"; then
            echo "‚úÖ xcb-proto package is installed"
            # È™åËØÅÂçèËÆÆÊñá‰ª∂ÁõÆÂΩïÂ≠òÂú®
            if [ -d "/usr/share/xcb" ]; then
              echo "‚úÖ xcb protocol files directory found: /usr/share/xcb"
              # ÂàóÂá∫‰∏Ä‰∫õÂçèËÆÆÊñá‰ª∂‰ª•Á°ÆËÆ§
              PROTO_COUNT=$(find /usr/share/xcb -name "*.xml" 2>/dev/null | wc -l)
              if [ "$PROTO_COUNT" -gt 0 ]; then
                echo "‚úÖ Found $PROTO_COUNT protocol XML files"
              else
                echo "‚ö†Ô∏è  Warning: No protocol XML files found in /usr/share/xcb"
              fi
            else
              echo "‚ö†Ô∏è  Warning: /usr/share/xcb directory not found"
              # Â∞ùËØïÊü•ÊâæÂÆûÈôÖ‰ΩçÁΩÆ
              XCB_PROTO_DIR=$(dpkg -L xcb-proto 2>/dev/null | grep "/usr/share/xcb" | head -1 | xargs dirname 2>/dev/null || echo "")
              if [ -n "$XCB_PROTO_DIR" ] && [ -d "$XCB_PROTO_DIR" ]; then
                echo "‚úÖ Found xcb protocol directory at: $XCB_PROTO_DIR"
              fi
            fi
          else
            echo "‚ùå Error: xcb-proto package is not installed"
            echo "   Please ensure xcb-proto package is installed via apt-get"
            exit 1
          fi
          python3 --version || echo "‚ö†Ô∏è  Python3 not found"
          # È™åËØÅ xcbgen Python Ê®°ÂùóÊòØÂê¶ÂèØÁî®Ôºàxcb crate ÊûÑÂª∫ËÑöÊú¨ÈúÄË¶ÅÔºâ
          echo "üîç Checking for xcbgen Python module..."
          if python3 -c "import xcbgen" 2>/dev/null; then
            echo "‚úÖ xcbgen Python module is importable"
            # ÊòæÁ§∫Ê®°Âùó‰ΩçÁΩÆ
            python3 -c "import xcbgen; print(f'xcbgen location: {xcbgen.__file__}')" 2>/dev/null || true
          else
            echo "‚ùå Error: xcbgen Python module is not importable"
            echo "   This is required for xcb crate to build"
            echo "   Please ensure python3-xcbgen package is installed"
            # Â∞ùËØïÊü•Êâæ xcbgen Ê®°ÂùóÁöÑ‰ΩçÁΩÆ
            XCBGEN_PATH=$(find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
            if [ -n "$XCBGEN_PATH" ]; then
              echo "   Found xcbgen directory at: $XCBGEN_PATH"
              echo "   Trying to add to PYTHONPATH..."
              export PYTHONPATH="$(dirname $XCBGEN_PATH):${PYTHONPATH:-}"
              echo "   PYTHONPATH: $PYTHONPATH"
              # ÂÜçÊ¨°Â∞ùËØïÂØºÂÖ•
              if python3 -c "import xcbgen" 2>/dev/null; then
                echo "‚úÖ xcbgen module is now importable after setting PYTHONPATH"
              else
                echo "‚ùå xcbgen still not importable"
                exit 1
              fi
            else
              echo "   xcbgen directory not found"
              exit 1
            fi
          fi
          # È™åËØÅ pkg-config ËÉΩÊâæÂà∞ xcb Â∫ì
          pkg-config --exists xcb && echo "‚úÖ xcb pkg-config found" || echo "‚ö†Ô∏è  xcb pkg-config not found"

      - name: Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          # Ê£ÄÊü• pkg-config ÊòØÂê¶Â∑≤ÂÆâË£ÖÔºåÈÅøÂÖçÈáçÂ§çÂÆâË£ÖË≠¶Âëä
          if ! command -v pkg-config >/dev/null 2>&1; then
            brew install pkg-config
          else
            echo "‚úÖ pkg-config is already installed"
          fi

      - name: Get Cargo.lock hash
        id: cargo_lock
        shell: bash
        run: |
          if [ -f "Cargo.lock" ]; then
            # macOS ‰ΩøÁî® shasumÔºåLinux ‰ΩøÁî® sha256sum
            if command -v shasum >/dev/null 2>&1; then
              HASH=$(shasum -a 256 Cargo.lock | cut -d' ' -f1 | head -c 16)
            else
              HASH=$(sha256sum Cargo.lock | cut -d' ' -f1 | head -c 16)
            fi
            echo "hash=$HASH" >> $GITHUB_OUTPUT
          else
            echo "hash=no-lock" >> $GITHUB_OUTPUT
          fi

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build release binaries
        shell: bash
        env:
          CARGO_BUILD_TARGET: ${{ matrix.target }}
        run: |
          # ‰∏∫ Linux x86_64 ËÆæÁΩÆ xcb ÊûÑÂª∫ÁéØÂ¢É
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            echo "üîç Setting up xcb build environment..."
            # xcb-proto ‰∏çÊòØ‰∏Ä‰∏™ÂèØÊâßË°åÁ®ãÂ∫èÔºåËÄåÊòØ‰∏Ä‰∏™ÂåÖÂê´ÂçèËÆÆÊèèËø∞Êñá‰ª∂ÁöÑÂåÖ
            # xcb crate ÁöÑÊûÑÂª∫ËÑöÊú¨‰ΩøÁî® Python ÁöÑ xcbgen Ê®°ÂùóÊù•ËØªÂèñËøô‰∫õÊñá‰ª∂
            # È™åËØÅ xcb-proto ÂåÖÂ∑≤ÂÆâË£ÖÔºàÂçèËÆÆÊñá‰ª∂Ôºâ
            if dpkg -l | grep -q "^ii.*xcb-proto"; then
              echo "‚úÖ xcb-proto package is installed"
              # Êü•ÊâæÂçèËÆÆÊñá‰ª∂ÁõÆÂΩïÔºàÈÄöÂ∏∏Âú® /usr/share/xcb/Ôºâ
              XCB_PROTO_DIR="/usr/share/xcb"
              if [ -d "$XCB_PROTO_DIR" ]; then
                echo "‚úÖ xcb protocol files found at: $XCB_PROTO_DIR"
                # ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáèÊåáÂêëÂçèËÆÆÊñá‰ª∂ÁõÆÂΩïÔºàÂ¶ÇÊûú xcb crate ÈúÄË¶ÅÔºâ
                export XCB_PROTO_DIR="$XCB_PROTO_DIR"
              else
                # Â∞ùËØïÊü•ÊâæÂÆûÈôÖ‰ΩçÁΩÆ
                XCB_PROTO_DIR=$(dpkg -L xcb-proto 2>/dev/null | grep "/usr/share/xcb" | head -1 | xargs dirname 2>/dev/null || echo "")
                if [ -n "$XCB_PROTO_DIR" ] && [ -d "$XCB_PROTO_DIR" ]; then
                  echo "‚úÖ xcb protocol files found at: $XCB_PROTO_DIR"
                  export XCB_PROTO_DIR="$XCB_PROTO_DIR"
                else
                  echo "‚ö†Ô∏è  Warning: xcb protocol directory not found, but package is installed"
                fi
              fi
            else
              echo "‚ùå Error: xcb-proto package is not installed"
              exit 1
            fi
            # ËÆæÁΩÆ PKG_CONFIG_PATH Á°Æ‰øùËÉΩÊâæÂà∞ xcb Â∫ì
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            echo "‚úÖ PKG_CONFIG_PATH set to: $PKG_CONFIG_PATH"
            # Á°Æ‰øù PYTHONPATH ÂåÖÂê´ xcbgen Ê®°ÂùóË∑ØÂæÑ
            echo "üîç Checking for xcbgen Python module..."
            # È¶ñÂÖàÂ∞ùËØïÁõ¥Êé•ÂØºÂÖ•
            if python3 -c "import xcbgen" 2>/dev/null; then
              echo "‚úÖ xcbgen module is importable"
              # ÊòæÁ§∫Ê®°Âùó‰ΩçÁΩÆ‰ª•‰æøË∞ÉËØï
              python3 -c "import xcbgen; import os; print(f'xcbgen location: {os.path.dirname(xcbgen.__file__)}')" 2>/dev/null || true
              # Á°Æ‰øù PYTHONPATH ÂåÖÂê´Ê®°ÂùóË∑ØÂæÑ
              XCBGEN_DIR=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null)
              if [ -n "$XCBGEN_DIR" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_DIR):${PYTHONPATH:-}"
                echo "‚úÖ PYTHONPATH set to include xcbgen: $PYTHONPATH"
              fi
            else
              echo "‚ö†Ô∏è  xcbgen not directly importable, trying to locate..."
              # Â∞ùËØïÊü•ÊâæÂπ∂Ê∑ªÂä† xcbgen Ë∑ØÂæÑ
              XCBGEN_PATH=$(find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_PATH" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_PATH):${PYTHONPATH:-}"
                echo "   Found xcbgen at: $XCBGEN_PATH"
                echo "   PYTHONPATH set to: $PYTHONPATH"
                # ÂÜçÊ¨°È™åËØÅ
                if python3 -c "import xcbgen" 2>/dev/null; then
                  echo "‚úÖ xcbgen module is now importable"
                else
                  echo "‚ùå xcbgen still not importable after setting PYTHONPATH"
                  echo "   Trying alternative method..."
                  # Â∞ùËØïÈÄöËøá pip ÂÆâË£ÖÔºàÂ¶ÇÊûúÂèØÁî®Ôºâ
                  python3 -m pip install --user xcbgen 2>/dev/null || true
                  if python3 -c "import xcbgen" 2>/dev/null; then
                    echo "‚úÖ xcbgen installed via pip"
                  else
                    echo "‚ùå xcbgen installation failed"
                    exit 1
                  fi
                fi
              else
                echo "   xcbgen module directory not found"
                echo "   Checking installed packages..."
                dpkg -l | grep -i xcb || echo "   No xcb packages found"
                echo "   Attempting to install python3-xcbgen..."
                sudo apt-get install -y python3-xcbgen || {
                  echo "‚ùå Failed to install python3-xcbgen"
                  exit 1
                }
                # ÂÜçÊ¨°Â∞ùËØï
                if python3 -c "import xcbgen" 2>/dev/null; then
                  echo "‚úÖ xcbgen module is now importable after installation"
                else
                  echo "‚ùå xcbgen still not importable"
                  exit 1
                fi
              fi
            fi
          fi
          # ËÆæÁΩÆ‰∫§ÂèâÁºñËØëÁéØÂ¢ÉÂèòÈáèÔºà‰ªÖ Linux ARM64Ôºâ
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            echo "üîß Cross-compiling for Linux ARM64"
            echo "‚ÑπÔ∏è  Note: clipboard feature is disabled for Linux ARM64 (XCB libraries not available in Ubuntu sources)"
            # ÊµãËØïÔºöÊ≥®ÈáäÊéâ remove_xcb_deps.py ËÑöÊú¨Ë∞ÉÁî®
            # ÁêÜËÆ∫‰∏äÔºåCargo.toml ‰∏≠ÁöÑÊù°‰ª∂ÁºñËØëÂ∫îËØ•Â∑≤ÁªèÁ¶ÅÁî®‰∫Ü clipboard ‰æùËµñ
            # Â¶ÇÊûúÊûÑÂª∫Â§±Ë¥•ÔºåËØ¥Êòé‰ªçÁÑ∂ÈúÄË¶ÅËøô‰∏™ËÑöÊú¨ÔºåÈúÄË¶ÅÂèñÊ∂àÊ≥®Èáä‰∏ãÈù¢ÁöÑ‰ª£Á†Å
            echo "üß™ Testing: Skipping Cargo.lock modification (relying on conditional compilation in Cargo.toml)"
            echo "‚ÑπÔ∏è  If build fails, the remove_xcb_deps.py script may still be needed"
            # ÂØπ‰∫é Linux ARM64ÔºåÊàë‰ª¨ÈúÄË¶ÅÁ°Æ‰øù Cargo ‰∏ç‰ºöÂ∞ùËØïÁºñËØë xcb
            # Áî±‰∫éÊù°‰ª∂ÁºñËØëÈÖçÁΩÆÔºåclipboard ‰æùËµñÂ∫îËØ•Ë¢´ÊéíÈô§Ôºå‰ΩÜ Cargo.lock ÂèØËÉΩ‰ªçÁÑ∂ÂåÖÂê´ÂÆÉ
            # Ëß£ÂÜ≥ÊñπÊ°àÔºö‰∏¥Êó∂‰ªé Cargo.lock ‰∏≠ÁßªÈô§Ëøô‰∫õ‰æùËµñÔºåÊûÑÂª∫ÂêéÂÜçÊÅ¢Â§ç
            # if [ -f "Cargo.lock" ]; then
            #   # Ê£ÄÊü• Python3 ÊòØÂê¶ÂèØÁî®
            #   if ! command -v python3 >/dev/null 2>&1; then
            #     echo "‚ùå python3 is required but not found"
            #     exit 1
            #   fi
            #   cp Cargo.lock Cargo.lock.backup
            #   echo "üìù Backed up Cargo.lock"
            #   # ‰ΩøÁî® Python ËÑöÊú¨Âà†Èô§ clipboard„ÄÅx11-clipboard„ÄÅxcb Âíå clipboard-win ÁöÑÂåÖÊù°ÁõÆ
            #   # ‰ª•Âèä‰ªéÂÖ∂‰ªñÂåÖÁöÑ dependencies ‰∏≠ÁßªÈô§ÂØπËøô‰∫õÂåÖÁöÑÂºïÁî®
            #   # Python ËÑöÊú¨Êõ¥ÂèØÈù†ÔºåËÉΩÊõ¥Â•ΩÂú∞Â§ÑÁêÜ TOML Ê†ºÂºè
            #   # Ê∑ªÂä†Ë∂ÖÊó∂Êú∫Âà∂Ôºà120ÁßíÔºâÔºåÈò≤Ê≠¢ËÑöÊú¨Âç°‰Ωè
            #   echo "üîÑ Processing Cargo.lock to remove xcb dependencies..."
            #   timeout 120 python3 .github/scripts/remove_xcb_deps.py || {
            #     EXIT_CODE=$?
            #     if [ $EXIT_CODE -eq 124 ]; then
            #       echo "‚ùå Script timed out after 120 seconds"
            #       echo "‚ö†Ô∏è  This may indicate a performance issue with the script"
            #     else
            #       echo "‚ùå Script failed with exit code $EXIT_CODE"
            #     fi
            #     exit $EXIT_CODE
            #   }
            #
            #   if [ $? -ne 0 ]; then
            #     echo "‚ö†Ô∏è  Failed to process Cargo.lock, restoring backup"
            #     if [ -f "Cargo.lock.backup" ]; then
            #       mv Cargo.lock.backup Cargo.lock
            #       echo "‚úÖ Restored Cargo.lock from backup"
            #     fi
            #     echo "‚ùå Cannot proceed without removing xcb dependencies"
            #     exit 1
            #   fi
            #
            #   # È™åËØÅ Cargo.lock ‰ªçÁÑ∂ÊúâÊïàÔºàËá≥Â∞ëÂ∫îËØ•ËÉΩËß£ÊûêÂü∫Êú¨ÁªìÊûÑÔºâ
            #   if ! grep -q '^\[\[package\]\]' Cargo.lock; then
            #     echo "‚ùå Cargo.lock appears corrupted after processing"
            #     if [ -f "Cargo.lock.backup" ]; then
            #       mv Cargo.lock.backup Cargo.lock
            #       echo "‚úÖ Restored Cargo.lock from backup"
            #     fi
            #     exit 1
            #   fi
            # fi
          fi
          # ÊûÑÂª∫ÂâçÈ™åËØÅÔºà‰ªÖ Linux x86_64Ôºâ
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            echo "üîç Pre-build verification for xcb dependencies..."
            # ÈáçÊñ∞ËÆæÁΩÆÁéØÂ¢ÉÂèòÈáèÔºàÂõ†‰∏∫ÊØè‰∏™ step ÊòØÁã¨Á´ãÁöÑ shellÔºâ
            export XCB_PROTO_DIR="${XCB_PROTO_DIR:-/usr/share/xcb}"
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            # Á°Æ‰øù PYTHONPATH ÂåÖÂê´ xcbgen Ê®°ÂùóË∑ØÂæÑ
            if [ -z "$PYTHONPATH" ] || ! python3 -c "import xcbgen" 2>/dev/null; then
              XCBGEN_DIR=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null || find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_DIR" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_DIR):${PYTHONPATH:-}"
              fi
            fi
            # È™åËØÅ xcb-proto ÂåÖÂ∑≤ÂÆâË£Ö
            if dpkg -l | grep -q "^ii.*xcb-proto"; then
              echo "‚úÖ xcb-proto package is installed"
              # È™åËØÅÂçèËÆÆÊñá‰ª∂ÁõÆÂΩïÂ≠òÂú®
              if [ -n "$XCB_PROTO_DIR" ] && [ -d "$XCB_PROTO_DIR" ]; then
                echo "‚úÖ xcb protocol directory: $XCB_PROTO_DIR"
                # ÂàóÂá∫‰∏Ä‰∫õÂçèËÆÆÊñá‰ª∂
                echo "   Protocol files found:"
                ls -1 "$XCB_PROTO_DIR"/*.xml 2>/dev/null | head -5 | xargs -n1 basename || echo "   (none found)"
              else
                echo "‚ö†Ô∏è  Warning: XCB_PROTO_DIR not set or directory not found"
              fi
            else
              echo "‚ùå xcb-proto package is not installed"
              exit 1
            fi
            # È™åËØÅ Python
            if command -v python3 >/dev/null 2>&1; then
              echo "‚úÖ python3: $(which python3)"
            else
              echo "‚ùå python3 not found"
              exit 1
            fi
            # È™åËØÅ xcbgen Python Ê®°ÂùóÔºàÂøÖÈúÄÔºâ
            if python3 -c "import xcbgen" 2>/dev/null; then
              echo "‚úÖ xcbgen Python module is importable"
              python3 -c "import xcbgen; import os; print(f'   xcbgen location: {os.path.dirname(xcbgen.__file__)}')" 2>/dev/null || true
            else
              echo "‚ùå Error: xcbgen module not importable"
              echo "   This is required for xcb crate to build"
              echo "   PYTHONPATH: ${PYTHONPATH:-not set}"
              echo "   Python path: $(python3 -c 'import sys; print(":".join(sys.path))' 2>/dev/null || echo 'unknown')"
              exit 1
            fi
            # È™åËØÅ pkg-config
            if pkg-config --exists xcb; then
              echo "‚úÖ xcb libraries found via pkg-config"
              pkg-config --modversion xcb
            else
              echo "‚ö†Ô∏è  Warning: xcb not found via pkg-config"
            fi
            # ÊòæÁ§∫ÊúÄÁªàÁéØÂ¢ÉÂèòÈáè
            echo "üìã Environment variables for build:"
            echo "   XCB_PROTO_DIR: ${XCB_PROTO_DIR}"
            echo "   PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
            echo "   PYTHONPATH: ${PYTHONPATH:-not set}"
          fi
          # ÊûÑÂª∫È°πÁõÆ
          # ÂØπ‰∫é Linux x86_64ÔºåÂêØÁî®ËØ¶ÁªÜËæìÂá∫‰ª•‰æøË∞ÉËØï xcb ÊûÑÂª∫ÈóÆÈ¢ò
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            echo "üî® Building with verbose output for xcb debugging..."
            # Á°Æ‰øùÁéØÂ¢ÉÂèòÈáèÂú®ÊûÑÂª∫Êó∂ÂèØÁî®
            # xcb crate ÁöÑÊûÑÂª∫ËÑöÊú¨ÈúÄË¶ÅËøô‰∫õÁéØÂ¢ÉÂèòÈáè
            export XCB_PROTO_DIR="${XCB_PROTO_DIR:-/usr/share/xcb}"
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            # Á°Æ‰øù PYTHONPATH ÂåÖÂê´ xcbgen Ê®°ÂùóË∑ØÂæÑ
            if [ -z "$PYTHONPATH" ] || ! python3 -c "import xcbgen" 2>/dev/null; then
              XCBGEN_PATH=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null || find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_PATH" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_PATH):${PYTHONPATH:-}"
              fi
            fi
            # Ê∏ÖÁêÜ‰πãÂâçÁöÑÊûÑÂª∫ÁºìÂ≠òÔºåÈÅøÂÖçÁºìÂ≠òÈóÆÈ¢ò
            echo "üßπ Cleaning xcb build artifacts..."
            # Ê∏ÖÁêÜ xcb ÂåÖÁöÑÊûÑÂª∫ÁºìÂ≠ò
            cargo clean -p xcb 2>/dev/null || true
            # ‰πüÊ∏ÖÁêÜÊûÑÂª∫ËæìÂá∫ÁõÆÂΩï‰∏≠ÁöÑ xcb Áõ∏ÂÖ≥Êñá‰ª∂
            rm -rf target/${{ matrix.target }}/release/build/xcb-* 2>/dev/null || true
            rm -rf target/${{ matrix.target }}/release/deps/libxcb-* 2>/dev/null || true
            # ÊòæÁ§∫ÊúÄÁªàÁöÑÁéØÂ¢ÉÂèòÈáèËÆæÁΩÆ
            echo "üìã Final environment variables:"
            echo "   XCB_PROTO_DIR: ${XCB_PROTO_DIR}"
            echo "   PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
            echo "   PYTHONPATH: ${PYTHONPATH:-not set}"
            echo "   Python version: $(python3 --version 2>&1 || echo "unknown")"
            echo "   Python xcbgen: $(python3 -c 'import xcbgen; print("OK")' 2>&1 || echo "FAILED")"
            # È™åËØÅ Python ÁâàÊú¨ÂÖºÂÆπÊÄßÔºàxcbgen ÈúÄË¶Å Python 3.6+Ôºâ
            PYTHON_VERSION=$(python3 -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")' 2>/dev/null || echo "unknown")
            echo "   Python version check: $PYTHON_VERSION"
            if [ "$PYTHON_VERSION" != "unknown" ]; then
              MAJOR=$(echo "$PYTHON_VERSION" | cut -d. -f1)
              MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f2)
              if [ "$MAJOR" -lt 3 ] || ([ "$MAJOR" -eq 3 ] && [ "$MINOR" -lt 6 ]); then
                echo "‚ö†Ô∏è  Warning: Python version $PYTHON_VERSION may be too old for xcbgen"
              else
                echo "‚úÖ Python version $PYTHON_VERSION is compatible"
              fi
            fi
            # ÊµãËØï xcbgen ÊòØÂê¶ËÉΩÊ≠£Â∏∏Â∑•‰Ωú
            echo "üß™ Testing xcbgen functionality..."
            if python3 -c "import xcbgen; import os; import sys; proto_dir = '${XCB_PROTO_DIR}'; print('‚úÖ Protocol directory exists:', proto_dir) if os.path.isdir(proto_dir) else (print('‚ùå Protocol directory not found:', proto_dir), sys.exit(1)); import xcbgen.state, xcbgen.xtypes; print('‚úÖ xcbgen modules imported successfully')" 2>/dev/null; then
              echo "‚úÖ xcbgen test passed"
            else
              echo "‚ö†Ô∏è  xcbgen test failed, but continuing with build..."
            fi
            # ÊûÑÂª∫
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install -vv 2>&1 | tee build.log; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
              echo "‚ùå Build failed. Checking build log for xcb-related errors..."
              grep -i "xcb\|xproto\|big_requests\|xcbgen\|xc_misc\|render\|shape\|xfixes" build.log || echo "No xcb-related errors found in log"
              # ÊòæÁ§∫ÊûÑÂª∫ËÑöÊú¨ËæìÂá∫ÔºàÂ¶ÇÊûúÊúâÔºâ
              echo "üìã Checking for build script errors..."
              grep -i "error\|warning\|failed" build.log | head -20 || true
            fi
          else
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
            fi
          fi

          # ÊÅ¢Â§ç Cargo.lockÔºàÂ¶ÇÊûúÂ§á‰ªΩÂ≠òÂú®ÔºåÊó†ËÆ∫ÊûÑÂª∫ÊàêÂäü‰∏éÂê¶ÈÉΩË¶ÅÊÅ¢Â§çÔºâ
          # ÊµãËØïÔºöÊ≥®ÈáäÊéâÊÅ¢Â§çÈÄªËæëÔºåÂõ†‰∏∫‰∏çÂÜçÂàõÂª∫Â§á‰ªΩ
          # if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]] && [ -f "Cargo.lock.backup" ]; then
          #   mv Cargo.lock.backup Cargo.lock
          #   echo "‚úÖ Restored Cargo.lock from backup"
          # fi

          # Â¶ÇÊûúÊûÑÂª∫Â§±Ë¥•ÔºåÈÄÄÂá∫Âπ∂ËøîÂõûÈîôËØØÁ†Å
          if [ "$BUILD_SUCCESS" != "true" ]; then
            echo "‚ùå Build failed"
            exit 1
          fi

      - name: Create package directory
        shell: bash
        run: |
          mkdir -p package
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cp target/${{ matrix.target }}/release/workflow.exe package/
            cp target/${{ matrix.target }}/release/install.exe package/
            echo "‚úÖ Copied workflow.exe and install.exe to package/"
          else
            cp target/${{ matrix.target }}/release/workflow package/
            cp target/${{ matrix.target }}/release/install package/
            echo "‚úÖ Copied workflow and install binaries to package/"
          fi

      - name: Create archive (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $archiveName = "workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          $archivePath = Join-Path $PWD $archiveName
          # ËøõÂÖ• package ÁõÆÂΩï
          Push-Location package
          try {
            # ÊâìÂåÖ workflow.exe Âíå install.exe ‰∏§‰∏™‰∫åËøõÂà∂Êñá‰ª∂
            Compress-Archive -Path "workflow.exe", "install.exe" -DestinationPath $archivePath -Force
            # ÊòæÁ§∫Êñá‰ª∂‰ø°ÊÅØ
            $fileInfo = Get-Item $archivePath
            Write-Host "üì¶ Archive created: $archiveName"
            Write-Host "   Size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
            # È™åËØÅÊâìÂåÖÂÜÖÂÆπ
            Write-Host "üì¶ Archive contents:"
            $verifyPath = Join-Path $env:TEMP "workflow-verify"
            Expand-Archive -Path $archivePath -DestinationPath $verifyPath -Force
            Get-ChildItem $verifyPath | ForEach-Object { Write-Host "   $($_.Name)" }
            Remove-Item $verifyPath -Recurse -Force
          } finally {
            Pop-Location
          }

      - name: Create archive (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          cd package
          ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          # ÊâìÂåÖ workflow Âíå install ‰∏§‰∏™‰∫åËøõÂà∂Êñá‰ª∂
          tar czf "../$ARCHIVE_NAME" workflow install
          cd ..
          ls -lh "$ARCHIVE_NAME"
          # È™åËØÅÊâìÂåÖÂÜÖÂÆπ
          echo "üì¶ Archive contents:"
          tar tzf "$ARCHIVE_NAME"

      - name: Calculate SHA256
        id: sha256
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          else
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          fi
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            SHA256=$(shasum -a 256 "$ARCHIVE_NAME" | cut -d' ' -f1)
          elif [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            # Windows: ‰ΩøÁî® PowerShell ËÆ°ÁÆó SHA256
            SHA256=$(powershell -Command "(Get-FileHash -Path '$ARCHIVE_NAME' -Algorithm SHA256).Hash")
          else
            SHA256=$(sha256sum "$ARCHIVE_NAME" | cut -d' ' -f1)
          fi
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "platform=${{ matrix.platform }}" >> $GITHUB_OUTPUT
          echo "archive=$ARCHIVE_NAME" >> $GITHUB_OUTPUT
          echo "SHA256 for ${{ matrix.platform }}: $SHA256"

      - name: Save SHA256 to file
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          else
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          fi
          echo "${{ steps.sha256.outputs.sha256 }}" > sha256-${{ matrix.platform }}.txt
          echo "${{ matrix.platform }}" >> sha256-${{ matrix.platform }}.txt
          echo "$ARCHIVE_NAME" >> sha256-${{ matrix.platform }}.txt

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}
          path: |
            workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.${{ matrix.os == 'windows-latest' && 'zip' || 'tar.gz' }}
          retention-days: 30

      - name: Upload SHA256
        uses: actions/upload-artifact@v4
        with:
          name: sha256-${{ matrix.platform }}
          path: |
            sha256-${{ matrix.platform }}.txt
          retention-days: 30

  # ÂàõÂª∫ GitHub Release Âπ∂‰∏ä‰º†ÊâÄÊúâ‰∫åËøõÂà∂Êñá‰ª∂
  release:
    name: Run create-release
    needs: [create-tag, build]
    runs-on: ubuntu-latest
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write  # ÂÖÅËÆ∏ÂàõÂª∫ Release Âíå‰∏ä‰º†Êñá‰ª∂
      pull-requests: read  # ËØªÂèñ PRÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version from tag
        id: version
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            # ÁßªÈô§ v ÂâçÁºÄÔºàÂ¶ÇÊûúÊúâÔºâ
            VERSION=${VERSION#v}
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # ‰ªéÊ†áÁ≠æËé∑ÂèñÁâàÊú¨Âè∑
            VERSION=${GITHUB_REF#refs/tags/}
            # ÁßªÈô§ v ÂâçÁºÄÔºàÂ¶ÇÊûúÊúâÔºâ
            VERSION=${VERSION#v}
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            # ‰ªé create-tag job ÁöÑ outputs Ëé∑ÂèñÁâàÊú¨Âè∑
            if [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
              VERSION="${{ needs.create-tag.outputs.tag }}"
              # ÁßªÈô§ v ÂâçÁºÄÔºàÂ¶ÇÊûúÊúâÔºâ
              VERSION=${VERSION#v}
            else
              # Â¶ÇÊûú outputs ‰∏çÂèØÁî®Ôºå‰ªé Cargo.toml ËØªÂèñ
              VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
              if [ -z "$VERSION" ]; then
                echo "‚ùå Error: Cannot read version from Cargo.toml"
                exit 1
              fi
            fi
          else
            echo "‚ùå Error: Cannot determine version from context"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo "‚úÖ Version: $VERSION"
          echo "‚úÖ Tag: v$VERSION"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        shell: bash
        run: |
          mkdir -p release-assets
          # Â§çÂà∂ÂéãÁº©ÂåÖÊñá‰ª∂
          find artifacts -name "workflow-*.tar.gz" -exec cp {} release-assets/ \;
          find artifacts -name "workflow-*.zip" -exec cp {} release-assets/ \;

          # ‰∏∫ÊØè‰∏™ÂéãÁº©ÂåÖÂàõÂª∫ÂØπÂ∫îÁöÑ .sha256 Êñá‰ª∂
          cd release-assets
          for archive in workflow-*.tar.gz workflow-*.zip; do
            if [ -f "$archive" ]; then
              # ‰ªéÊñá‰ª∂ÂêçÊèêÂèñÂπ≥Âè∞‰ø°ÊÅØÔºà‰æãÂ¶ÇÔºöworkflow-1.3.4-macOS-AppleSilicon.tar.gz -> macOS-AppleSiliconÔºâ
              PLATFORM=$(echo "$archive" | sed -E 's/workflow-[0-9]+\.[0-9]+\.[0-9]+-(.+)\.(tar\.gz|zip)/\1/')

              # Êü•ÊâæÂØπÂ∫îÁöÑ SHA256 Êñá‰ª∂Ôºàartifacts ÁõÆÂΩïÁªìÊûÑÔºöartifacts/sha256-{platform}/sha256-{platform}.txtÔºâ
              SHA256_FILE=$(find ../artifacts -path "*/sha256-$PLATFORM/sha256-$PLATFORM.txt" | head -1)

              if [ -f "$SHA256_FILE" ]; then
                # ÊèêÂèñÁ¨¨‰∏ÄË°åÔºàÂìàÂ∏åÂÄºÔºâ
                SHA256_HASH=$(head -n 1 "$SHA256_FILE")
                # ÂàõÂª∫ .sha256 Êñá‰ª∂ÔºàÂè™ÂåÖÂê´ÂìàÂ∏åÂÄºÔºåÁ¨¶Âêà parse_hash_from_content ÁöÑÊúüÊúõÊ†ºÂºèÔºâ
                echo "$SHA256_HASH" > "${archive}.sha256"
                echo "‚úÖ Created ${archive}.sha256: $SHA256_HASH"
              else
                echo "‚ö†Ô∏è  Warning: SHA256 file not found for $archive (platform: $PLATFORM)"
                echo "   Searched in: $(find ../artifacts -name "*$PLATFORM*" -type f 2>/dev/null | head -5)"
              fi
            fi
          done
          cd ..

          if [ -z "$(ls -A release-assets)" ]; then
            echo "Error: No release assets found!"
            exit 1
          fi
          echo "üì¶ Release assets prepared:"
          ls -lh release-assets/

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Release ${{ steps.version.outputs.tag }}
          make_latest: true
          body: |
            ## Release ${{ steps.version.outputs.tag }}

            ### Downloads

            #### macOS
            - **macOS Intel**: [workflow-${{ steps.version.outputs.version }}-macOS-Intel.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-Intel.tar.gz)
            - **macOS Apple Silicon**: [workflow-${{ steps.version.outputs.version }}-macOS-AppleSilicon.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-AppleSilicon.tar.gz)

            #### Linux
            - **Linux x86_64 (glibc)**: [workflow-${{ steps.version.outputs.version }}-Linux-x86_64.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-x86_64.tar.gz) - For most Linux distributions (Ubuntu, Debian, Fedora, CentOS, etc.)
            - **Linux ARM64**: [workflow-${{ steps.version.outputs.version }}-Linux-ARM64.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-ARM64.tar.gz) - For ARM64 servers (AWS Graviton, Raspberry Pi 4+, etc.)
            - **Linux x86_64 (static/musl)**: [workflow-${{ steps.version.outputs.version }}-Linux-x86_64-static.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-x86_64-static.tar.gz) - Static binary for Alpine Linux, Docker containers, or older distributions

            #### Windows
            - **Windows x86_64**: [workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip) - For Windows 10/11 (64-bit, Intel/AMD)
            - **Windows ARM64**: [workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip) - For Windows on ARM devices (Surface Pro X, Surface Laptop Studio, etc.)

            ### Installation

            #### macOS

            ```bash
            # Download and extract
            # For Intel Mac
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-Intel.tar.gz
            # For Apple Silicon Mac
            # curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-AppleSilicon.tar.gz
            tar xzf workflow-${{ steps.version.outputs.version }}-*.tar.gz

            # Install binaries and completions
            ./install
            ```

            #### Linux

            **For most Linux distributions (Ubuntu, Debian, Fedora, CentOS, etc.):**
            ```bash
            # Download and extract x86_64 version
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-x86_64.tar.gz
            tar xzf workflow-${{ steps.version.outputs.version }}-Linux-x86_64.tar.gz
            ./install
            ```

            **For ARM64 servers (AWS Graviton, Raspberry Pi 4+, etc.):**
            ```bash
            # Download and extract ARM64 version
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-ARM64.tar.gz
            tar xzf workflow-${{ steps.version.outputs.version }}-Linux-ARM64.tar.gz
            ./install
            ```

            **For Alpine Linux, Docker containers, or older distributions:**
            ```bash
            # Download and extract static version (musl)
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-x86_64-static.tar.gz
            tar xzf workflow-${{ steps.version.outputs.version }}-Linux-x86_64-static.tar.gz
            ./install
            ```

            #### Windows

            **For Windows x86_64 (Intel/AMD):**

            **Using PowerShell:**
            ```powershell
            # Download and extract
            Invoke-WebRequest -Uri "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip" -OutFile "workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip"
            Expand-Archive -Path "workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip" -DestinationPath "."

            # Install binaries and completions
            .\install.exe
            ```

            **For Windows ARM64 (Surface Pro X, Surface Laptop Studio, etc.):**

            **Using PowerShell:**
            ```powershell
            # Download and extract
            Invoke-WebRequest -Uri "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip" -OutFile "workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip"
            Expand-Archive -Path "workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip" -DestinationPath "."

            # Install binaries and completions
            .\install.exe
            ```

            **Using Command Prompt (x86_64):**
            ```cmd
            # Download using curl (if available) or use a browser
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip

            # Extract using PowerShell (or use 7-Zip/WinRAR)
            powershell -Command "Expand-Archive -Path 'workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip' -DestinationPath '.'"

            # Install binaries and completions
            install.exe
            ```

            **Note:** After installation, you may need to add `%LOCALAPPDATA%\Programs\workflow\bin` to your PATH environment variable.

            ### Homebrew (macOS only)

            Install via Homebrew:
            ```bash
            brew tap ${{ github.repository_owner }}/workflow
            brew install workflow
            ```
          files: release-assets/*
          draft: false
          prerelease: false

  # Ëá™Âä®Êõ¥Êñ∞ Homebrew Formula
  update-homebrew:
    name: Run update-homebrew
    needs: [create-tag, build, release]
    runs-on: ubuntu-latest
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write  # ÂÖÅËÆ∏Êé®ÈÄÅÂà∞ homebrew-workflow ‰ªìÂ∫ì

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version and detect install type
        id: version
        shell: bash
        run: |
          # Ê£ÄÊµãÊòØ tag ËøòÊòØ branch
          # ‰ºòÂÖàÊ£ÄÊü•ÊòØÂê¶ÊòØ‰ªé create-tag job ÂàõÂª∫ÁöÑ tagÔºàÂú® master push Êó∂Ôºâ
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            # Âú® master push Êó∂ÔºåÂ¶ÇÊûú create-tag job ÂàõÂª∫‰∫Ü tagÔºåÂ∫îËØ•‰ΩøÁî® tag
            if [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
              INSTALL_TYPE="tag"
              VERSION_REF="${{ needs.create-tag.outputs.tag }}"
              VERSION="${VERSION_REF#v}"  # ÁßªÈô§ v ÂâçÁºÄ
              echo "‚úÖ Detected as TAG from create-tag job: $VERSION_REF"
            else
              # Â¶ÇÊûúÊ≤°ÊúâÂàõÂª∫ tagÔºåÂàô‰ΩøÁî® branch
              INSTALL_TYPE="branch"
              VERSION_REF="${GITHUB_REF#refs/heads/}"
              VERSION="0.0.0-dev"
              echo "‚úÖ Detected as BRANCH: $VERSION_REF"
              echo "‚ÑπÔ∏è  Using default version for branch: $VERSION"
            fi
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # ÊòØ tag push Ëß¶ÂèëÁöÑ workflow
            INSTALL_TYPE="tag"
            VERSION_REF="${GITHUB_REF#refs/tags/}"
            VERSION="${VERSION_REF#v}"  # ÁßªÈô§ v ÂâçÁºÄ
            echo "‚úÖ Detected as TAG: $VERSION_REF"
          elif [[ "${{ github.ref }}" == refs/heads/* ]]; then
            # ÊòØ branch push Ëß¶ÂèëÁöÑ workflowÔºàÈùû masterÔºåÊàñ master ‰ΩÜÊ≤°ÊúâÂàõÂª∫ tagÔºâ
            INSTALL_TYPE="branch"
            VERSION_REF="${GITHUB_REF#refs/heads/}"
            # ÂØπ‰∫é branchÔºåÁâàÊú¨Âè∑ÂèØ‰ª•‰ªé workflow_dispatch input Êàñ‰ΩøÁî®ÈªòËÆ§ÁâàÊú¨
            if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              VERSION="${{ github.event.inputs.version }}"
            else
              # ÂØπ‰∫é branchÔºå‰ΩøÁî®ÈªòËÆ§ÁâàÊú¨Âè∑ÔºàÂõ†‰∏∫ branch ÂêçÂèØËÉΩÂåÖÂê´ÁâπÊÆäÂ≠óÁ¨¶Ôºå‰∏çÈÄÇÂêà‰Ωú‰∏∫ versionÔºâ
              # ÂèØ‰ª•Â∞Ü branch ÂêçËΩ¨Êç¢‰∏∫ÊúâÊïàÁöÑÁâàÊú¨Âè∑Ê†ºÂºèÔºåÊàñ‰ΩøÁî®Âõ∫ÂÆöÁöÑÂºÄÂèëÁâàÊú¨Âè∑
              # ‰æãÂ¶ÇÔºözw/update-completions -> 0.0.0-dev (ÊàñËÄÖ‰ΩøÁî®Êó•ÊúüÁ≠â)
              VERSION="0.0.0-dev"
            fi
            echo "‚úÖ Detected as BRANCH: $VERSION_REF"
            echo "‚ÑπÔ∏è  Using default version for branch: $VERSION"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # ÊâãÂä®Ëß¶ÂèëÔºåÈªòËÆ§‰ΩøÁî® tag
            INSTALL_TYPE="tag"
            VERSION_REF="${{ github.event.inputs.version }}"
            VERSION="${VERSION_REF#v}"
            echo "‚úÖ Manual trigger, using as TAG: $VERSION_REF"
          else
            echo "‚ùå Error: Cannot determine install type from ${{ github.ref }}"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "install_type=$INSTALL_TYPE" >> $GITHUB_OUTPUT
          echo "version_ref=$VERSION_REF" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo ""
          echo "Install Type: $INSTALL_TYPE"
          echo "Version Ref: $VERSION_REF"
          echo "Version: $VERSION"

      # Ê≥®ÊÑèÔºö‰ΩøÁî® git tag ÊñπÂºèÊó∂Ôºå‰∏çÈúÄË¶Å SHA256 Ê†°È™å
      # Âõ†‰∏∫ Homebrew ‰ºöÁõ¥Êé•‰ªé git ‰ªìÂ∫ì checkout ÊåáÂÆöÁöÑ tag

      - name: Check WORKFLOW_PAT
        id: check_token
        shell: bash
        env:
          WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
        run: |
          if [ -z "$WORKFLOW_PAT" ]; then
            echo "‚ùå Error: WORKFLOW_PAT secret is not configured"
            echo ""
            echo "Please configure WORKFLOW_PAT secret:"
            echo "1. Go to: Settings ‚Üí Secrets and variables ‚Üí Actions"
            echo "2. Click 'New repository secret'"
            echo "3. Name: WORKFLOW_PAT"
            echo "4. Value: Your Personal Access Token (PAT) with 'repo' scope"
            echo ""
            echo "To create a PAT:"
            echo "1. Go to: https://github.com/settings/tokens"
            echo "2. Click 'Generate new token (classic)'"
            echo "3. Select 'repo' scope (full control of private repositories)"
            echo "4. Copy the token and add it as WORKFLOW_PAT secret"
            exit 1
          else
            echo "‚úÖ WORKFLOW_PAT is configured"
          fi

      - name: Checkout homebrew-workflow
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/homebrew-workflow
          path: homebrew-workflow
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: Update Formula from template
        shell: bash
        run: |
          # Ê®°ÊùøÊñá‰ª∂ÂíåÁõÆÊ†áÊñá‰ª∂Ë∑ØÂæÑ
          TEMPLATE_FILE="homebrew/Formula.template"
          FORMULA_FILE="homebrew-workflow/Formula/workflow.rb"

          # Ê£ÄÊü•Ê®°ÊùøÊñá‰ª∂ÊòØÂê¶Â≠òÂú®
          if [ ! -f "$TEMPLATE_FILE" ]; then
            echo "‚ùå Error: Template file not found at $TEMPLATE_FILE"
            echo "Make sure homebrew/Formula.template exists in the source repository"
            exit 1
          fi

          # Á°Æ‰øù homebrew-workflow/Formula ÁõÆÂΩïÂ≠òÂú®
          mkdir -p homebrew-workflow/Formula

          # Â§á‰ªΩÁé∞ÊúâÁöÑ Formula Êñá‰ª∂ÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
          if [ -f "$FORMULA_FILE" ]; then
            cp "$FORMULA_FILE" "$FORMULA_FILE.bak"
            echo "üì¶ Backed up existing Formula file"
          fi

          # ‰ªéÊ®°ÊùøÁîüÊàê URL Ë°å
          INSTALL_TYPE="${{ steps.version.outputs.install_type }}"
          VERSION_REF="${{ steps.version.outputs.version_ref }}"

          if [[ "$INSTALL_TYPE" == "tag" ]]; then
            URL_LINE="url \"https://github.com/${{ github.repository }}.git\", tag: \"$VERSION_REF\""
          elif [[ "$INSTALL_TYPE" == "branch" ]]; then
            URL_LINE="url \"https://github.com/${{ github.repository }}.git\", branch: \"$VERSION_REF\""
          else
            echo "‚ùå Error: Invalid install type: $INSTALL_TYPE"
            exit 1
          fi

          echo "üîß Generated URL line: $URL_LINE"

          # ‰ªéÊ®°ÊùøÁîüÊàê Formula Êñá‰ª∂
          echo "üìù Generating Formula file from template..."
          sed -e "s|{{VERSION}}|${{ steps.version.outputs.version }}|g" \
              -e "s|{{INSTALL_TYPE}}|$INSTALL_TYPE|g" \
              -e "s|{{VERSION_REF}}|$VERSION_REF|g" \
              -e "s|{{URL_LINE}}|$URL_LINE|g" \
              "$TEMPLATE_FILE" > "$FORMULA_FILE"

          echo "‚úÖ Formula file generated from template"

          cd homebrew-workflow

          # Êõ¥Êñ∞‰∏∫Áõ∏ÂØπ‰∫é homebrew-workflow ÁõÆÂΩïÁöÑË∑ØÂæÑ
          FORMULA_FILE="Formula/workflow.rb"

          # È™åËØÅÊñá‰ª∂ÁªìÊûÑÔºàÁ°Æ‰øùÊ≤°ÊúâËØ≠Ê≥ïÈîôËØØÔºâ
          echo "üîç Validating Formula file structure..."
          if ! ruby -c "$FORMULA_FILE" 2>/dev/null; then
            echo "‚ùå Error: Formula file has syntax errors"
            ruby -c "$FORMULA_FILE" || true
            exit 1
          fi
          echo "‚úÖ Formula file syntax is valid"

          # ÊòæÁ§∫ÁîüÊàêÁöÑ Formula Êñá‰ª∂
          echo ""
          echo "üìÑ Generated Formula file:"
          echo "--- Formula/workflow.rb ---"
          cat "$FORMULA_FILE"
          echo ""

          # ÊòæÁ§∫Êõ¥ÊîπÔºàÂ¶ÇÊûúÊúâÂ§á‰ªΩÔºâ
          if [ -f "$FORMULA_FILE.bak" ]; then
            echo "--- Diff (Before vs After) ---"
            diff "$FORMULA_FILE.bak" "$FORMULA_FILE" || true
          fi

      - name: Commit and push changes
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          cd homebrew-workflow

          # ÈÖçÁΩÆ Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Ê£ÄÊü•ÊòØÂê¶ÊúâÊõ¥Êîπ
          git add Formula/workflow.rb

          if git diff --staged --quiet; then
            echo "No changes to commit. Formula file is already up to date."
            exit 0
          fi

          # È™åËØÅ Formula Êñá‰ª∂Ê†ºÂºè
          if ! brew audit --strict Formula/workflow.rb 2>/dev/null; then
            echo "Warning: brew audit failed, but continuing..."
          fi

          # Êèê‰∫§Êõ¥Êîπ
          git commit -m "Update workflow to ${{ steps.version.outputs.tag }}"

          # Ê£ÄÊµãÂΩìÂâçÂàÜÊîØÂêçÁß∞
          CURRENT_BRANCH=$(git branch --show-current)
          echo "Current branch: $CURRENT_BRANCH"

          # actions/checkout@v4 Â∑≤ÁªèËÆæÁΩÆ‰∫ÜÊ≠£Á°ÆÁöÑËøúÁ®ã URLÔºåÁõ¥Êé•Êé®ÈÄÅÂç≥ÂèØ
          # Êé®ÈÄÅÊõ¥ÊîπÂà∞ÂΩìÂâçÂàÜÊîØ
          echo "Pushing to branch: $CURRENT_BRANCH"
          if git push origin "$CURRENT_BRANCH"; then
            echo "‚úÖ Successfully pushed to $CURRENT_BRANCH branch"
          else
            echo "‚ùå Error: Failed to push changes to $CURRENT_BRANCH"
            echo "Remote URL: $(git remote get-url origin | sed 's|://.*@|://***@|')"
            echo "Branch: $CURRENT_BRANCH"
            echo "Git status:"
            git status
            echo "Git log:"
            git log --oneline -5
            echo ""
            echo "Possible issues:"
            echo "1. WORKFLOW_PAT may not have write access to ${{ github.repository_owner }}/homebrew-workflow"
            echo "2. Token may have expired or been revoked"
            echo "3. Repository may not exist or be accessible"
            exit 1
          fi

          echo "‚úÖ Homebrew Formula updated successfully!"
