name: Release

on:
  push:
    branches:
      - master  # å½“åˆå¹¶åˆ° master åˆ†æ”¯æ—¶è§¦å‘
    tags:
      - 'v*'  # åŒ¹é…æ‰€æœ‰ä»¥ v å¼€å¤´çš„ tagï¼Œå¦‚ v0.1.0, v1.0.0
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
    inputs:
      version:
        description: 'Version tag (e.g., v0.1.0)'
        required: true

# é…ç½®å·¥ä½œæµæƒé™ï¼Œå…è®¸åˆ›å»º Release å’Œæ›´æ–°ä»“åº“
permissions:
  contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
  pull-requests: read  # è¯»å– PRï¼ˆå¦‚æœéœ€è¦ï¼‰

env:
  CARGO_TERM_COLOR: always

jobs:
  # å½“åˆå¹¶åˆ° master æ—¶è‡ªåŠ¨åˆ›å»º tag
  create-tag:
    name: Create Tag
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    permissions:
      contents: write  # å…è®¸åˆ›å»ºå’Œæ¨é€ tag
    outputs:
      tag: ${{ steps.job_outputs.outputs.tag }}
      tag_created: ${{ steps.job_outputs.outputs.tag_created }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # éœ€è¦å®Œæ•´å†å²è®°å½•æ¥æ£€æŸ¥ tag
          token: ${{ secrets.GITHUB_TOKEN }}  # ç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„ token

      - name: Get version from Cargo.toml
        id: version
        shell: bash
        run: |
          # ä» Cargo.toml è¯»å–ç‰ˆæœ¬å·
          VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
          if [ -z "$VERSION" ]; then
            echo "âŒ Error: Cannot read version from Cargo.toml"
            exit 1
          fi
          TAG="v$VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version from Cargo.toml: $VERSION"
          echo "âœ… Tag to create: $TAG"

      - name: Detect version bump type from commit messages
        id: detect_bump_type
        shell: bash
        run: |
          # è·å–æœ€æ–°çš„ tagï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -z "$LATEST_TAG" ]; then
            # å¦‚æœæ²¡æœ‰ tagï¼Œæ£€æŸ¥ä»åˆå§‹ commit åˆ°å½“å‰çš„æ‰€æœ‰ commits
            COMMITS=$(git log --pretty=format:"%s" HEAD)
            echo "â„¹ï¸  No previous tag found, analyzing all commits"
          else
            # è·å–ä»æœ€æ–° tag åˆ°å½“å‰ commit çš„æ‰€æœ‰ commit messages
            COMMITS=$(git log --pretty=format:"%s" ${LATEST_TAG}..HEAD)
            echo "â„¹ï¸  Analyzing commits since ${LATEST_TAG}"
          fi

          if [ -z "$COMMITS" ]; then
            echo "â„¹ï¸  No new commits found, using patch bump"
            BUMP_TYPE="patch"
          else
            # æ£€æµ‹ç‰ˆæœ¬æ›´æ–°ç±»å‹
            # BREAKING CHANGE æˆ– ! åœ¨ç±»å‹å â†’ major
            # feat: æˆ– feature: â†’ minor
            # å…¶ä»– â†’ patch

            BUMP_TYPE="patch"

            # æ£€æŸ¥æ˜¯å¦æœ‰ BREAKING CHANGE
            if echo "$COMMITS" | grep -qiE "(BREAKING CHANGE|BREAKING:|!.*:)" || \
               echo "$COMMITS" | grep -qiE "^[^:]*!:"; then
              BUMP_TYPE="major"
              echo "ğŸ”´ Detected BREAKING CHANGE, will bump MAJOR version"
            # æ£€æŸ¥æ˜¯å¦æœ‰ feat: æˆ– feature:
            elif echo "$COMMITS" | grep -qiE "^(feat|feature):"; then
              BUMP_TYPE="minor"
              echo "ğŸŸ¡ Detected feature commit, will bump MINOR version"
            else
              echo "ğŸŸ¢ No breaking changes or features detected, will bump PATCH version"
            fi

            # æ˜¾ç¤ºæ£€æµ‹åˆ°çš„ commitsï¼ˆç”¨äºè°ƒè¯•ï¼‰
            echo ""
            echo "ğŸ“ Commits analyzed:"
            echo "$COMMITS" | head -10 | while read -r commit; do
              echo "  - $commit"
            done
            if [ $(echo "$COMMITS" | wc -l) -gt 10 ]; then
              echo "  ... and $(( $(echo "$COMMITS" | wc -l) - 10 )) more commits"
            fi
          fi

          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo ""
          echo "âœ… Version bump type: $BUMP_TYPE"

      - name: Check if tag exists and increment version if needed
        id: check_tag
        shell: bash
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"
          BUMP_TYPE="${{ steps.detect_bump_type.outputs.bump_type }}"

          # è§£æç‰ˆæœ¬å·
          IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
          MAJOR="${VERSION_PARTS[0]:-0}"
          MINOR="${VERSION_PARTS[1]:-0}"
          PATCH="${VERSION_PARTS[2]:-0}"

          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "âš ï¸  Tag $TAG already exists"
            echo "Current commit: $(git rev-parse HEAD)"
            echo "Tag commit: $(git rev-parse $TAG)"

            if [ "$(git rev-parse HEAD)" = "$(git rev-parse $TAG)" ]; then
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "needs_increment=false" >> $GITHUB_OUTPUT
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "tag=$TAG" >> $GITHUB_OUTPUT
              echo "âœ… Tag points to current commit, skipping tag creation"
            else
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "needs_increment=true" >> $GITHUB_OUTPUT
              echo "âš ï¸  Tag points to different commit, auto-incrementing version based on commit messages"

              # æ ¹æ®æ£€æµ‹åˆ°çš„ bump_type é€’å¢ç‰ˆæœ¬å·
              case "$BUMP_TYPE" in
                major)
                  MAJOR=$((MAJOR + 1))
                  MINOR=0
                  PATCH=0
                  echo "ğŸ”´ Bumping MAJOR version"
                  ;;
                minor)
                  MINOR=$((MINOR + 1))
                  PATCH=0
                  echo "ğŸŸ¡ Bumping MINOR version"
                  ;;
                patch)
                  PATCH=$((PATCH + 1))
                  echo "ğŸŸ¢ Bumping PATCH version"
                  ;;
                *)
                  # é»˜è®¤ä½¿ç”¨ patch
                  PATCH=$((PATCH + 1))
                  echo "âš ï¸  Unknown bump type '$BUMP_TYPE', defaulting to PATCH"
                  ;;
              esac

              NEW_VERSION="$MAJOR.$MINOR.$PATCH"
              NEW_TAG="v$NEW_VERSION"

              echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
              echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
              echo "old_version=$VERSION" >> $GITHUB_OUTPUT
              echo "old_tag=$TAG" >> $GITHUB_OUTPUT
              echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT

              echo "âœ… Auto-incremented version: $VERSION -> $NEW_VERSION ($BUMP_TYPE)"
              echo "âœ… New tag: $NEW_TAG"
            fi
          else
            # Tag ä¸å­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ ¹æ® commit messages æ›´æ–°ç‰ˆæœ¬
            echo "âœ… Tag $TAG does not exist"

            # è·å–æœ€æ–°çš„ tagï¼ˆç”¨äºè®¡ç®—æœŸæœ›çš„ç‰ˆæœ¬å·ï¼‰
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

            if [ -n "$LATEST_TAG" ]; then
              # æœ‰ä¹‹å‰çš„ tagï¼Œè®¡ç®—åŸºäº commit messages çš„æœŸæœ›ç‰ˆæœ¬å·
              LATEST_VERSION="${LATEST_TAG#v}"  # ç§»é™¤ v å‰ç¼€
              IFS='.' read -ra LATEST_PARTS <<< "$LATEST_VERSION"
              LATEST_MAJOR="${LATEST_PARTS[0]:-0}"
              LATEST_MINOR="${LATEST_PARTS[1]:-0}"
              LATEST_PATCH="${LATEST_PARTS[2]:-0}"

              # æ ¹æ® bump_type è®¡ç®—æœŸæœ›ç‰ˆæœ¬
              case "$BUMP_TYPE" in
                major)
                  EXPECTED_MAJOR=$((LATEST_MAJOR + 1))
                  EXPECTED_MINOR=0
                  EXPECTED_PATCH=0
                  ;;
                minor)
                  EXPECTED_MAJOR=$LATEST_MAJOR
                  EXPECTED_MINOR=$((LATEST_MINOR + 1))
                  EXPECTED_PATCH=0
                  ;;
                patch)
                  EXPECTED_MAJOR=$LATEST_MAJOR
                  EXPECTED_MINOR=$LATEST_MINOR
                  EXPECTED_PATCH=$((LATEST_PATCH + 1))
                  ;;
              esac

              EXPECTED_VERSION="$EXPECTED_MAJOR.$EXPECTED_MINOR.$EXPECTED_PATCH"

              # å¦‚æœ Cargo.toml ä¸­çš„ç‰ˆæœ¬ä¸æœŸæœ›ç‰ˆæœ¬ä¸ä¸€è‡´ï¼Œéœ€è¦æ›´æ–°
              if [ "$VERSION" != "$EXPECTED_VERSION" ]; then
                echo "â„¹ï¸  Cargo.toml version ($VERSION) doesn't match expected version ($EXPECTED_VERSION) based on commits"
                echo "â„¹ï¸  Will update to expected version based on commit messages ($BUMP_TYPE bump)"

                echo "exists=false" >> $GITHUB_OUTPUT
                echo "needs_increment=true" >> $GITHUB_OUTPUT
                echo "version=$EXPECTED_VERSION" >> $GITHUB_OUTPUT
                echo "tag=v$EXPECTED_VERSION" >> $GITHUB_OUTPUT
                echo "old_version=$VERSION" >> $GITHUB_OUTPUT
                echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT

                echo "âœ… Will create tag: v$EXPECTED_VERSION (based on $BUMP_TYPE bump from $LATEST_TAG)"
              else
                echo "exists=false" >> $GITHUB_OUTPUT
                echo "needs_increment=false" >> $GITHUB_OUTPUT
                echo "version=$VERSION" >> $GITHUB_OUTPUT
                echo "tag=$TAG" >> $GITHUB_OUTPUT
                echo "âœ… Tag $TAG does not exist, will create it (version matches expected)"
              fi
            else
              # æ²¡æœ‰ä¹‹å‰çš„ tagï¼Œç›´æ¥ä½¿ç”¨ Cargo.toml ä¸­çš„ç‰ˆæœ¬
              echo "exists=false" >> $GITHUB_OUTPUT
              echo "needs_increment=false" >> $GITHUB_OUTPUT
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "tag=$TAG" >> $GITHUB_OUTPUT
              echo "âœ… Tag $TAG does not exist, will create it (no previous tag found)"
            fi
          fi

      - name: Setup Rust
        if: steps.check_tag.outputs.needs_increment == 'true'
        uses: dtolnay/rust-toolchain@stable

      - name: Update Cargo.toml and Cargo.lock version
        if: steps.check_tag.outputs.needs_increment == 'true'
        shell: bash
        run: |
          NEW_VERSION="${{ steps.check_tag.outputs.version }}"
          echo "Updating Cargo.toml and Cargo.lock version to $NEW_VERSION"

          # 1. æ›´æ–° Cargo.toml ä¸­çš„ç‰ˆæœ¬å·
          if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            sed -i '' "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          else
            # Linux
            sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          fi

          # éªŒè¯ Cargo.toml æ›´æ–°
          UPDATED_VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "âŒ Error: Failed to update version in Cargo.toml"
            exit 1
          fi
          echo "âœ… Cargo.toml updated: version = \"$NEW_VERSION\""

          # 2. è¿è¡Œ cargo build æˆ– cargo check æ¥è‡ªåŠ¨æ›´æ–° Cargo.lock
          echo "Updating Cargo.lock to reflect new version in Cargo.toml..."
          cargo build --quiet || cargo check --quiet || true

          # 3. éªŒè¯ Cargo.lock ä¸­çš„ç‰ˆæœ¬æ˜¯å¦å·²æ›´æ–°
          if grep -q 'name = "workflow"' Cargo.lock; then
            LOCK_VERSION=$(grep -A 2 'name = "workflow"' Cargo.lock | grep 'version' | head -1 | sed -E 's/.*version = "([^"]+)".*/\1/')
            if [ "$LOCK_VERSION" = "$NEW_VERSION" ]; then
              echo "âœ… Cargo.lock updated: version = \"$LOCK_VERSION\""
            else
              echo "âš ï¸  Warning: Cargo.lock version ($LOCK_VERSION) does not match expected version ($NEW_VERSION)"
              echo "Attempting to manually update Cargo.lock..."
              # æ‰‹åŠ¨æ›´æ–° Cargo.lock ä¸­çš„ç‰ˆæœ¬å·
              # ä½¿ç”¨ sed åœ¨ workflow åŒ…çš„ [[package]] å—ä¸­æ›´æ–°ç‰ˆæœ¬å·
              if [[ "$OSTYPE" == "darwin"* ]]; then
                # macOS: ä½¿ç”¨ sed æ›´æ–° workflow åŒ…çš„ç‰ˆæœ¬å·
                sed -i '' '/^name = "workflow"$/,/^version = /{
                  /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
                }' Cargo.lock
              else
                # Linux: ä½¿ç”¨ sed æ›´æ–°
                sed -i '/^name = "workflow"$/,/^version = /{
                  /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
                }' Cargo.lock
              fi
              # å†æ¬¡éªŒè¯
              LOCK_VERSION=$(grep -A 2 'name = "workflow"' Cargo.lock | grep 'version' | head -1 | sed -E 's/.*version = "([^"]+)".*/\1/')
              if [ "$LOCK_VERSION" = "$NEW_VERSION" ]; then
                echo "âœ… Cargo.lock manually updated: version = \"$LOCK_VERSION\""
              else
                echo "âš ï¸  Warning: Could not update Cargo.lock version. It will be updated on next build."
              fi
            fi
          else
            echo "âš ï¸  Warning: Could not find workflow package in Cargo.lock"
          fi

      - name: Commit version update
        if: steps.check_tag.outputs.needs_increment == 'true'
        shell: bash
        run: |
          # é…ç½® Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # æäº¤æ›´æ”¹ï¼ˆåŒæ—¶æäº¤ Cargo.toml å’Œ Cargo.lockï¼‰
          git add Cargo.toml Cargo.lock

          # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹éœ€è¦æäº¤
          if git diff --staged --quiet; then
            echo "No changes to commit. Files are already up to date."
          else
            # æ„å»º commit messageï¼ŒåŒ…å«ç‰ˆæœ¬æ›´æ–°ç±»å‹
            OLD_VERSION="${{ steps.check_tag.outputs.old_version }}"
            NEW_VERSION="${{ steps.check_tag.outputs.version }}"
            BUMP_TYPE="${{ steps.check_tag.outputs.bump_type }}"

            if [ -n "$BUMP_TYPE" ] && [ "$BUMP_TYPE" != "patch" ]; then
              COMMIT_MSG="chore: bump version to $NEW_VERSION ($BUMP_TYPE bump from $OLD_VERSION)"
            else
              COMMIT_MSG="chore: bump version to $NEW_VERSION"
            fi

            git commit -m "$COMMIT_MSG"

            # æ¨é€åˆ° master
            echo "Pushing version update to master"
            git push origin master

            echo "âœ… Version update committed and pushed"
          fi

      - name: Create and push tag
        if: steps.check_tag.outputs.exists == 'false' || steps.check_tag.outputs.needs_increment == 'true'
        shell: bash
        run: |
          TAG="${{ steps.check_tag.outputs.tag }}"
          echo "Creating tag: $TAG"

          # é…ç½® Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # åˆ›å»º tag
          git tag "$TAG"

          # æ¨é€ tag
          echo "Pushing tag: $TAG"
          git push origin "$TAG"

          echo "âœ… Successfully created and pushed tag: $TAG"
          echo "â„¹ï¸  This tag push should trigger a new workflow run for building and releasing"

      - name: Set job outputs
        id: job_outputs
        shell: bash
        run: |
          TAG="${{ steps.check_tag.outputs.tag }}"
          TAG_CREATED="false"
          if [ "${{ steps.check_tag.outputs.exists }}" == "false" ] || [ "${{ steps.check_tag.outputs.needs_increment }}" == "true" ]; then
            TAG_CREATED="true"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "tag_created=$TAG_CREATED" >> $GITHUB_OUTPUT
          echo "âœ… Job outputs set: tag=$TAG, tag_created=$TAG_CREATED"

      - name: Skip tag creation
        if: steps.check_tag.outputs.exists == 'true' && steps.check_tag.outputs.needs_increment == 'false'
        shell: bash
        run: |
          echo "â­ï¸  Skipping tag creation: tag ${{ steps.check_tag.outputs.tag }} already exists and points to current commit"

  # æ„å»ºæ‰€æœ‰å¹³å°çš„äºŒè¿›åˆ¶æ–‡ä»¶
  build:
    runs-on: ${{ matrix.os }}
    needs: create-tag
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true')
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: macOS-Intel
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: macOS-AppleSilicon
          # æš‚æ—¶è·³è¿‡ Linux æ„å»º
          # - os: ubuntu-latest
          #   target: x86_64-unknown-linux-gnu
          #   platform: x86_64-unknown-linux-gnu

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version from tag
        id: version
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
            VERSION=${VERSION#v}
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # ä»æ ‡ç­¾è·å–ç‰ˆæœ¬å·
            VERSION=${GITHUB_REF#refs/tags/}
            # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
            VERSION=${VERSION#v}
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            # ä» create-tag job çš„ outputs è·å–ç‰ˆæœ¬å·
            if [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
              VERSION="${{ needs.create-tag.outputs.tag }}"
              # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
              VERSION=${VERSION#v}
            else
              # å¦‚æœ outputs ä¸å¯ç”¨ï¼Œä» Cargo.toml è¯»å–
              VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
              if [ -z "$VERSION" ]; then
                echo "âŒ Error: Cannot read version from Cargo.toml"
                exit 1
              fi
            fi
          else
            echo "âŒ Error: Cannot determine version from context"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          brew install pkg-config || true

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ matrix.target }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ matrix.target }}-

      - name: Build release binaries
        run: |
          cargo build --release --target ${{ matrix.target }} --bin workflow --bin pr --bin qk
        env:
          CARGO_BUILD_TARGET: ${{ matrix.target }}

      - name: Create package directory
        run: |
          mkdir -p package
          cp target/${{ matrix.target }}/release/workflow package/
          cp target/${{ matrix.target }}/release/pr package/
          cp target/${{ matrix.target }}/release/qk package/

      - name: Create archive
        shell: bash
        run: |
          cd package
          ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          tar czf "../$ARCHIVE_NAME" workflow pr qk
          cd ..
          ls -lh "$ARCHIVE_NAME"

      - name: Calculate SHA256
        id: sha256
        shell: bash
        run: |
          ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            SHA256=$(shasum -a 256 "$ARCHIVE_NAME" | cut -d' ' -f1)
          else
            SHA256=$(sha256sum "$ARCHIVE_NAME" | cut -d' ' -f1)
          fi
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "platform=${{ matrix.platform }}" >> $GITHUB_OUTPUT
          echo "archive=$ARCHIVE_NAME" >> $GITHUB_OUTPUT
          echo "SHA256 for ${{ matrix.platform }}: $SHA256"

      - name: Save SHA256 to file
        shell: bash
        run: |
          ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          echo "${{ steps.sha256.outputs.sha256 }}" > sha256-${{ matrix.platform }}.txt
          echo "${{ matrix.platform }}" >> sha256-${{ matrix.platform }}.txt
          echo "$ARCHIVE_NAME" >> sha256-${{ matrix.platform }}.txt

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}
          path: |
            workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz
          retention-days: 30

      - name: Upload SHA256
        uses: actions/upload-artifact@v4
        with:
          name: sha256-${{ matrix.platform }}
          path: |
            sha256-${{ matrix.platform }}.txt
          retention-days: 30

  # åˆ›å»º GitHub Release å¹¶ä¸Šä¼ æ‰€æœ‰äºŒè¿›åˆ¶æ–‡ä»¶
  release:
    name: Create Release
    needs: [create-tag, build]
    runs-on: ubuntu-latest
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
      pull-requests: read  # è¯»å– PRï¼ˆå¦‚æœéœ€è¦ï¼‰

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version from tag
        id: version
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
            VERSION=${VERSION#v}
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # ä»æ ‡ç­¾è·å–ç‰ˆæœ¬å·
            VERSION=${GITHUB_REF#refs/tags/}
            # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
            VERSION=${VERSION#v}
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            # ä» create-tag job çš„ outputs è·å–ç‰ˆæœ¬å·
            if [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
              VERSION="${{ needs.create-tag.outputs.tag }}"
              # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
              VERSION=${VERSION#v}
            else
              # å¦‚æœ outputs ä¸å¯ç”¨ï¼Œä» Cargo.toml è¯»å–
              VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
              if [ -z "$VERSION" ]; then
                echo "âŒ Error: Cannot read version from Cargo.toml"
                exit 1
              fi
            fi
          else
            echo "âŒ Error: Cannot determine version from context"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        shell: bash
        run: |
          mkdir -p release-assets
          find artifacts -name "workflow-*.tar.gz" -exec cp {} release-assets/ \;
          if [ -z "$(ls -A release-assets)" ]; then
            echo "Error: No release assets found!"
            exit 1
          fi
          ls -lh release-assets/

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Release ${{ steps.version.outputs.tag }}
          make_latest: true
          body: |
            ## Release ${{ steps.version.outputs.tag }}

            ### Downloads

            - **macOS Intel**: [workflow-${{ steps.version.outputs.version }}-macOS-Intel.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-Intel.tar.gz)
            - **macOS Apple Silicon**: [workflow-${{ steps.version.outputs.version }}-macOS-AppleSilicon.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-AppleSilicon.tar.gz)

            ### Installation

            ```bash
            # Download and extract (macOS)
            # For Intel Mac
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-Intel.tar.gz
            # For Apple Silicon Mac
            # curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-AppleSilicon.tar.gz
            tar xzf workflow-${{ steps.version.outputs.version }}-*.tar.gz
            sudo mv workflow pr qk /usr/local/bin/
            ```

            ### Homebrew

            Install via Homebrew:
            ```bash
            brew tap zevwings/workflow
            brew install workflow
            ```
          files: release-assets/*
          draft: false
          prerelease: false

  # è‡ªåŠ¨æ›´æ–° Homebrew Formula
  update-homebrew:
    name: Update Homebrew Formula
    needs: [create-tag, build, release]
    runs-on: ubuntu-latest
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write  # å…è®¸æ¨é€åˆ° homebrew-workflow ä»“åº“

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version and detect install type
        id: version
        shell: bash
        run: |
          # æ£€æµ‹æ˜¯ tag è¿˜æ˜¯ branch
          # ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯ä» create-tag job åˆ›å»ºçš„ tagï¼ˆåœ¨ master push æ—¶ï¼‰
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            # åœ¨ master push æ—¶ï¼Œå¦‚æœ create-tag job åˆ›å»ºäº† tagï¼Œåº”è¯¥ä½¿ç”¨ tag
            if [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
              INSTALL_TYPE="tag"
              VERSION_REF="${{ needs.create-tag.outputs.tag }}"
              VERSION="${VERSION_REF#v}"  # ç§»é™¤ v å‰ç¼€
              echo "âœ… Detected as TAG from create-tag job: $VERSION_REF"
            else
              # å¦‚æœæ²¡æœ‰åˆ›å»º tagï¼Œåˆ™ä½¿ç”¨ branch
              INSTALL_TYPE="branch"
              VERSION_REF="${GITHUB_REF#refs/heads/}"
              VERSION="0.0.0-dev"
              echo "âœ… Detected as BRANCH: $VERSION_REF"
              echo "â„¹ï¸  Using default version for branch: $VERSION"
            fi
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # æ˜¯ tag push è§¦å‘çš„ workflow
            INSTALL_TYPE="tag"
            VERSION_REF="${GITHUB_REF#refs/tags/}"
            VERSION="${VERSION_REF#v}"  # ç§»é™¤ v å‰ç¼€
            echo "âœ… Detected as TAG: $VERSION_REF"
          elif [[ "${{ github.ref }}" == refs/heads/* ]]; then
            # æ˜¯ branch push è§¦å‘çš„ workflowï¼ˆé masterï¼Œæˆ– master ä½†æ²¡æœ‰åˆ›å»º tagï¼‰
            INSTALL_TYPE="branch"
            VERSION_REF="${GITHUB_REF#refs/heads/}"
            # å¯¹äº branchï¼Œç‰ˆæœ¬å·å¯ä»¥ä» workflow_dispatch input æˆ–ä½¿ç”¨é»˜è®¤ç‰ˆæœ¬
            if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              VERSION="${{ github.event.inputs.version }}"
            else
              # å¯¹äº branchï¼Œä½¿ç”¨é»˜è®¤ç‰ˆæœ¬å·ï¼ˆå› ä¸º branch åå¯èƒ½åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼Œä¸é€‚åˆä½œä¸º versionï¼‰
              # å¯ä»¥å°† branch åè½¬æ¢ä¸ºæœ‰æ•ˆçš„ç‰ˆæœ¬å·æ ¼å¼ï¼Œæˆ–ä½¿ç”¨å›ºå®šçš„å¼€å‘ç‰ˆæœ¬å·
              # ä¾‹å¦‚ï¼šzw/update-completions -> 0.0.0-dev (æˆ–è€…ä½¿ç”¨æ—¥æœŸç­‰)
              VERSION="0.0.0-dev"
            fi
            echo "âœ… Detected as BRANCH: $VERSION_REF"
            echo "â„¹ï¸  Using default version for branch: $VERSION"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # æ‰‹åŠ¨è§¦å‘ï¼Œé»˜è®¤ä½¿ç”¨ tag
            INSTALL_TYPE="tag"
            VERSION_REF="${{ github.event.inputs.version }}"
            VERSION="${VERSION_REF#v}"
            echo "âœ… Manual trigger, using as TAG: $VERSION_REF"
          else
            echo "âŒ Error: Cannot determine install type from ${{ github.ref }}"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "install_type=$INSTALL_TYPE" >> $GITHUB_OUTPUT
          echo "version_ref=$VERSION_REF" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo ""
          echo "Install Type: $INSTALL_TYPE"
          echo "Version Ref: $VERSION_REF"
          echo "Version: $VERSION"

      # æ³¨æ„ï¼šä½¿ç”¨ git tag æ–¹å¼æ—¶ï¼Œä¸éœ€è¦ SHA256 æ ¡éªŒ
      # å› ä¸º Homebrew ä¼šç›´æ¥ä» git ä»“åº“ checkout æŒ‡å®šçš„ tag

      - name: Check HOMEBREW_TAP_TOKEN
        id: check_token
        shell: bash
        run: |
          if [ -z "${{ secrets.HOMEBREW_TAP_TOKEN }}" ]; then
            echo "âŒ Error: HOMEBREW_TAP_TOKEN secret is not configured"
            echo ""
            echo "Please configure HOMEBREW_TAP_TOKEN secret:"
            echo "1. Go to: Settings â†’ Secrets and variables â†’ Actions"
            echo "2. Click 'New repository secret'"
            echo "3. Name: HOMEBREW_TAP_TOKEN"
            echo "4. Value: Your Personal Access Token (PAT) with 'repo' scope"
            echo ""
            echo "To create a PAT:"
            echo "1. Go to: https://github.com/settings/tokens"
            echo "2. Click 'Generate new token (classic)'"
            echo "3. Select 'repo' scope (full control of private repositories)"
            echo "4. Copy the token and add it as HOMEBREW_TAP_TOKEN secret"
            exit 1
          else
            echo "âœ… HOMEBREW_TAP_TOKEN is configured"
            echo ""
            echo "Validating token..."
            # éªŒè¯ token æ˜¯å¦æœ‰æ•ˆ
            RESPONSE=$(curl -s -w "\n%{http_code}" \
              -H "Authorization: token ${{ secrets.HOMEBREW_TAP_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/user)

            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')

            if [ "$HTTP_CODE" != "200" ]; then
              echo "âŒ Error: Token validation failed (HTTP $HTTP_CODE)"
              echo ""
              echo "Possible issues:"
              echo "1. Token is invalid or expired"
              echo "2. Token has been revoked"
              echo "3. Token format is incorrect"
              echo ""
              echo "Response: $BODY"
              echo ""
              echo "Please:"
              echo "1. Go to: https://github.com/settings/tokens"
              echo "2. Check if the token exists and is valid"
              echo "3. If expired/revoked, create a new token with 'repo' scope"
              echo "4. Update HOMEBREW_TAP_TOKEN secret with the new token"
              exit 1
            fi

            # éªŒè¯ token æ˜¯å¦æœ‰è®¿é—®ç›®æ ‡ä»“åº“çš„æƒé™
            REPO_RESPONSE=$(curl -s -w "\n%{http_code}" \
              -H "Authorization: token ${{ secrets.HOMEBREW_TAP_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              https://api.github.com/repos/zevwings/homebrew-workflow)

            REPO_HTTP_CODE=$(echo "$REPO_RESPONSE" | tail -n1)
            REPO_BODY=$(echo "$REPO_RESPONSE" | sed '$d')

            if [ "$REPO_HTTP_CODE" != "200" ]; then
              echo "âŒ Error: Cannot access repository zevwings/homebrew-workflow (HTTP $REPO_HTTP_CODE)"
              echo ""
              echo "Possible issues:"
              echo "1. Token does not have 'repo' scope"
              echo "2. Token belongs to a different account without access"
              echo "3. Repository is private and token lacks access"
              echo ""
              echo "Response: $REPO_BODY"
              echo ""
              echo "Please ensure:"
              echo "1. Token has 'repo' scope (full control of private repositories)"
              echo "2. Token belongs to an account with access to zevwings/homebrew-workflow"
              echo "3. If repository is private, token must have access permissions"
              exit 1
            fi

            echo "âœ… Token is valid and has access to the repository"
          fi

      - name: Checkout homebrew-workflow
        uses: actions/checkout@v4
        with:
          repository: zevwings/homebrew-workflow
          path: homebrew-workflow
          token: ${{ secrets.HOMEBREW_TAP_TOKEN }}

      - name: Update Formula from template
        shell: bash
        run: |
          # æ¨¡æ¿æ–‡ä»¶å’Œç›®æ ‡æ–‡ä»¶è·¯å¾„
          TEMPLATE_FILE="homebrew/Formula.template"
          FORMULA_FILE="homebrew-workflow/Formula/workflow.rb"

          # æ£€æŸ¥æ¨¡æ¿æ–‡ä»¶æ˜¯å¦å­˜åœ¨
          if [ ! -f "$TEMPLATE_FILE" ]; then
            echo "âŒ Error: Template file not found at $TEMPLATE_FILE"
            echo "Make sure homebrew/Formula.template exists in the source repository"
            exit 1
          fi

          # ç¡®ä¿ homebrew-workflow/Formula ç›®å½•å­˜åœ¨
          mkdir -p homebrew-workflow/Formula

          # å¤‡ä»½ç°æœ‰çš„ Formula æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          if [ -f "$FORMULA_FILE" ]; then
            cp "$FORMULA_FILE" "$FORMULA_FILE.bak"
            echo "ğŸ“¦ Backed up existing Formula file"
          fi

          # ä»æ¨¡æ¿ç”Ÿæˆ URL è¡Œ
          INSTALL_TYPE="${{ steps.version.outputs.install_type }}"
          VERSION_REF="${{ steps.version.outputs.version_ref }}"

          if [[ "$INSTALL_TYPE" == "tag" ]]; then
            URL_LINE="url \"https://github.com/zevwings/workflow.rs.git\", tag: \"$VERSION_REF\""
          elif [[ "$INSTALL_TYPE" == "branch" ]]; then
            URL_LINE="url \"https://github.com/zevwings/workflow.rs.git\", branch: \"$VERSION_REF\""
          else
            echo "âŒ Error: Invalid install type: $INSTALL_TYPE"
            exit 1
          fi

          echo "ğŸ”§ Generated URL line: $URL_LINE"

          # ä»æ¨¡æ¿ç”Ÿæˆ Formula æ–‡ä»¶
          echo "ğŸ“ Generating Formula file from template..."
          sed -e "s|{{VERSION}}|${{ steps.version.outputs.version }}|g" \
              -e "s|{{INSTALL_TYPE}}|$INSTALL_TYPE|g" \
              -e "s|{{VERSION_REF}}|$VERSION_REF|g" \
              -e "s|{{URL_LINE}}|$URL_LINE|g" \
              "$TEMPLATE_FILE" > "$FORMULA_FILE"

          echo "âœ… Formula file generated from template"

          cd homebrew-workflow

          # æ›´æ–°ä¸ºç›¸å¯¹äº homebrew-workflow ç›®å½•çš„è·¯å¾„
          FORMULA_FILE="Formula/workflow.rb"

          # éªŒè¯æ–‡ä»¶ç»“æ„ï¼ˆç¡®ä¿æ²¡æœ‰è¯­æ³•é”™è¯¯ï¼‰
          echo "ğŸ” Validating Formula file structure..."
          if ! ruby -c "$FORMULA_FILE" 2>/dev/null; then
            echo "âŒ Error: Formula file has syntax errors"
            ruby -c "$FORMULA_FILE" || true
            exit 1
          fi
          echo "âœ… Formula file syntax is valid"

          # æ˜¾ç¤ºç”Ÿæˆçš„ Formula æ–‡ä»¶
          echo ""
          echo "ğŸ“„ Generated Formula file:"
          echo "--- Formula/workflow.rb ---"
          cat "$FORMULA_FILE"
          echo ""

          # æ˜¾ç¤ºæ›´æ”¹ï¼ˆå¦‚æœæœ‰å¤‡ä»½ï¼‰
          if [ -f "$FORMULA_FILE.bak" ]; then
            echo "--- Diff (Before vs After) ---"
            diff "$FORMULA_FILE.bak" "$FORMULA_FILE" || true
          fi

      - name: Commit and push changes
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          cd homebrew-workflow

          # é…ç½® Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
          git add Formula/workflow.rb

          if git diff --staged --quiet; then
            echo "No changes to commit. Formula file is already up to date."
            exit 0
          fi

          # éªŒè¯ Formula æ–‡ä»¶æ ¼å¼
          if ! brew audit --strict Formula/workflow.rb 2>/dev/null; then
            echo "Warning: brew audit failed, but continuing..."
          fi

          # æäº¤æ›´æ”¹
          git commit -m "Update workflow to ${{ steps.version.outputs.tag }}"

          # æ£€æµ‹å½“å‰åˆ†æ”¯åç§°
          CURRENT_BRANCH=$(git branch --show-current)
          echo "Current branch: $CURRENT_BRANCH"

          # actions/checkout@v4 å·²ç»è®¾ç½®äº†æ­£ç¡®çš„è¿œç¨‹ URLï¼Œç›´æ¥æ¨é€å³å¯
          # æ¨é€æ›´æ”¹åˆ°å½“å‰åˆ†æ”¯
          echo "Pushing to branch: $CURRENT_BRANCH"
          if git push origin "$CURRENT_BRANCH"; then
            echo "âœ… Successfully pushed to $CURRENT_BRANCH branch"
          else
            echo "âŒ Error: Failed to push changes to $CURRENT_BRANCH"
            echo "Remote URL: $(git remote get-url origin | sed 's|://.*@|://***@|')"
            echo "Branch: $CURRENT_BRANCH"
            echo "Git status:"
            git status
            echo "Git log:"
            git log --oneline -5
            echo ""
            echo "Possible issues:"
            echo "1. HOMEBREW_TAP_TOKEN may not have write access to zevwings/homebrew-workflow"
            echo "2. Token may have expired or been revoked"
            echo "3. Repository may not exist or be accessible"
            exit 1
          fi

          echo "âœ… Homebrew Formula updated successfully!"



