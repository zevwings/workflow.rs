name: Release

on:
  push:
    branches:
      - master  # å½“åˆå¹¶åˆ° master åˆ†æ”¯æ—¶è§¦å‘
    tags:
      - 'v*'  # åŒ¹é…æ‰€æœ‰ä»¥ v å¼€å¤´çš„ tagï¼Œå¦‚ v0.1.0, v1.0.0
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘
    inputs:
      version:
        description: 'Version tag (e.g., v0.1.0)'
        required: true

# é…ç½®å·¥ä½œæµæƒé™ï¼Œå…è®¸åˆ›å»º Release å’Œæ›´æ–°ä»“åº“
permissions:
  contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
  pull-requests: write  # å…è®¸åˆ›å»º PRï¼ˆç”¨äºç‰ˆæœ¬æ›´æ–°ï¼‰
  statuses: write  # å…è®¸åˆ›å»ºçŠ¶æ€æ£€æŸ¥ï¼ˆç”¨äºæ»¡è¶³åˆ†æ”¯ä¿æŠ¤è§„åˆ™ï¼‰

env:
  CARGO_TERM_COLOR: always

jobs:
  # ä»£ç è´¨é‡æ£€æŸ¥ï¼ˆLintï¼‰
  # TODO: åç»­ä¼šæ‰“å¼€
  # check-lint:
  #   name: Run check-lint
  #   runs-on: ubuntu-latest
  #   if: github.ref == 'refs/heads/master' && github.event_name == 'push'
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Setup Rust
  #       uses: dtolnay/rust-toolchain@stable
  #       with:
  #         components: rustfmt, clippy
  #
  #     - name: Cache cargo registry
  #       uses: actions/cache@v4
  #       with:
  #         path: |
  #           ~/.cargo/bin/
  #           ~/.cargo/registry/index/
  #           ~/.cargo/registry/cache/
  #           ~/.cargo/git/db/
  #           target/
  #         key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
  #         restore-keys: |
  #           ${{ runner.os }}-cargo-
  #
  #     - name: Check code format
  #       run: cargo fmt --check
  #
  #     - name: Run Clippy
  #       run: cargo clippy -- -D warnings
  #
  #     - name: Run cargo check
  #       run: cargo check
  #
  # # è¿è¡Œæµ‹è¯•
  # tests:
  #   name: Run tests
  #   runs-on: ubuntu-latest
  #   if: github.ref == 'refs/heads/master' && github.event_name == 'push'
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #
  #     - name: Setup Rust
  #       uses: dtolnay/rust-toolchain@stable
  #
  #     - name: Cache cargo registry
  #       uses: actions/cache@v4
  #       with:
  #         path: |
  #           ~/.cargo/bin/
  #           ~/.cargo/registry/index/
  #           ~/.cargo/registry/cache/
  #           ~/.cargo/git/db/
  #           target/
  #         key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
  #         restore-keys: |
  #           ${{ runner.os }}-cargo-
  #
  #     - name: Install system dependencies (Linux)
  #       run: |
  #         sudo apt-get update
  #         # å®‰è£… XCB å¼€å‘åº“ï¼ˆclipboard ä¾èµ–ï¼‰
  #         # xcb crate éœ€è¦ xcb-proto æ¥ç”Ÿæˆä»£ç æ¨¡å—
  #         sudo apt-get install -y \
  #           libxcb1-dev \
  #           libxcb-render0-dev \
  #           libxcb-shape0-dev \
  #           libxcb-xfixes0-dev \
  #           xcb-proto \
  #           libxcb-keysyms1-dev \
  #           libxcb-image0-dev \
  #           libxcb-util-dev \
  #           libxcb-icccm4-dev \
  #           libxcb-sync-dev \
  #           libxcb-xinerama0-dev \
  #           libxcb-randr0-dev \
  #           libxcb-xinput-dev \
  #           libxcb-dri3-dev \
  #           libxcb-present-dev \
  #           libxcb-xv0-dev \
  #           libxcb-glx0-dev \
  #           libxcb-shm0-dev \
  #           libxcb-composite0-dev \
  #           libxcb-damage0-dev \
  #           libxcb-record0-dev \
  #           libxcb-screensaver0-dev \
  #           libxcb-res0-dev \
  #           libxkbcommon-dev \
  #           libxkbcommon-x11-dev
  #
  #     - name: Run tests
  #       run: cargo test --verbose
  #
  # ç¡®ä¿æ‰€æœ‰æ£€æŸ¥éƒ½é€šè¿‡ï¼ˆæ±‡æ€» jobï¼‰
  # è¿™ä¸ª job ä¾èµ–äº check-lint å’Œ testsï¼Œæ£€æŸ¥æ‰€æœ‰å¿…éœ€æ£€æŸ¥çš„çŠ¶æ€
  # å¦‚æœä»»ä½•æ£€æŸ¥å¤±è´¥ï¼Œæ­¤ job ä¼šå¤±è´¥ï¼Œä»è€Œé˜»æ­¢åç»­æ“ä½œ
  # æ³¨æ„ï¼šéœ€è¦åœ¨ GitHub ä»“åº“è®¾ç½®ä¸­é…ç½®åˆ†æ”¯ä¿æŠ¤è§„åˆ™ï¼Œå°†æ­¤å·¥ä½œæµè®¾ä¸ºå¿…éœ€çš„çŠ¶æ€æ£€æŸ¥
  # TODO: åç»­ä¼šæ‰“å¼€
  # check-status:
  #   name: Run check-status
  #   runs-on: ubuntu-latest
  #   needs: [check-lint, tests]
  #   if: github.ref == 'refs/heads/master' && github.event_name == 'push'
  #   steps:
  #     - name: Check lint and test status
  #       run: |
  #         if [ "${{ needs.check-lint.result }}" != "success" ] || [ "${{ needs.tests.result }}" != "success" ]; then
  #           echo "âŒ Some checks failed:"
  #           echo "  Lint: ${{ needs.check-lint.result }}"
  #           echo "  Test: ${{ needs.tests.result }}"
  #           echo ""
  #           echo "Cannot proceed until all checks pass."
  #           exit 1
  #         fi
  #         echo "âœ… All checks passed!"

  # å½“åˆå¹¶åˆ° master æ—¶è‡ªåŠ¨åˆ›å»º tagï¼Œæˆ–æ‰‹åŠ¨è§¦å‘æ—¶ä¹Ÿè¿è¡Œï¼ˆæä¾› outputsï¼‰
  create-tag:
    name: Run create-tag
    runs-on: ubuntu-latest
    # needs: [check-status]  # check-lintã€tests å’Œ check-status å·²æš‚æ—¶å±è”½
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.ref == 'refs/heads/master' && github.event_name == 'push')
    permissions:
      contents: write  # å…è®¸åˆ›å»ºå’Œæ¨é€ tag
      pull-requests: write  # å…è®¸åˆ›å»ºå’Œåˆå¹¶ PRï¼ˆç”¨äºç‰ˆæœ¬æ›´æ–°ï¼‰
    outputs:
      tag: ${{ steps.job_outputs.outputs.tag }}
      tag_created: ${{ steps.job_outputs.outputs.tag_created }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # éœ€è¦å®Œæ•´å†å²è®°å½•æ¥æ£€æŸ¥ tag
          token: ${{ secrets.GITHUB_TOKEN }}  # ç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„ token

      - name: Get version from Cargo.toml
        id: version
        shell: bash
        run: |
          # ä» Cargo.toml è¯»å–ç‰ˆæœ¬å·
          VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
          if [ -z "$VERSION" ]; then
            echo "âŒ Error: Cannot read version from Cargo.toml"
            exit 1
          fi
          TAG="v$VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version from Cargo.toml: $VERSION"
          echo "âœ… Tag to create: $TAG"

      - name: Detect branch type and trigger mode
        id: detect_mode
        shell: bash
        run: |
          # æ£€æµ‹æ˜¯å¦æ˜¯ feature åˆ†æ”¯
          if [[ "${{ github.ref }}" == refs/heads/feature/* ]]; then
            IS_FEATURE_BRANCH="true"
            echo "âœ… Detected feature branch: ${{ github.ref }}"
          else
            IS_FEATURE_BRANCH="false"
          fi

          # æ£€æµ‹è§¦å‘ç±»å‹
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            IS_MANUAL_TRIGGER="true"
            echo "âœ… Manual trigger detected"

            # å¦‚æœæ˜¯ feature åˆ†æ”¯æ‰‹åŠ¨è§¦å‘ï¼ŒéªŒè¯ç‰ˆæœ¬æ ¼å¼å¹¶è·³è¿‡ tag åˆ›å»º
            if [[ "$IS_FEATURE_BRANCH" == "true" ]]; then
              INPUT_VERSION="${{ github.event.inputs.version }}"
              # ç§»é™¤ v å‰ç¼€
              INPUT_VERSION=${INPUT_VERSION#v}

              # éªŒè¯ feature åˆ†æ”¯çš„ç‰ˆæœ¬æ ¼å¼å¿…é¡»åŒ…å« alpha æˆ– beta åç¼€
              if [[ ! "$INPUT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.(alpha|beta)-[0-9]+$ ]]; then
                echo "âŒ Error: Feature branch version must be in format: vx.x.x.alpha-xxx or vx.x.x.beta-xxx"
                echo "   Provided: ${{ github.event.inputs.version }}"
                echo "   Example: v0.0.1.alpha-001 or v0.0.1.beta-001"
                exit 1
              fi

              SHOULD_CREATE_TAG="false"
              echo "â„¹ï¸  Feature branch manual trigger: will skip tag creation"
              echo "   Version format validated: ${{ github.event.inputs.version }}"
            else
              # master åˆ†æ”¯æ‰‹åŠ¨è§¦å‘ï¼ŒéªŒè¯ç‰ˆæœ¬æ ¼å¼ä¸ºæ ‡å‡†æ ¼å¼ï¼ˆä¸å« alpha/betaï¼‰
              INPUT_VERSION="${{ github.event.inputs.version }}"
              INPUT_VERSION=${INPUT_VERSION#v}

              if [[ ! "$INPUT_VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                echo "âŒ Error: Master branch version must be in standard format: vx.x.x"
                echo "   Provided: ${{ github.event.inputs.version }}"
                echo "   Example: v0.1.0"
                exit 1
              fi

              SHOULD_CREATE_TAG="true"
              echo "â„¹ï¸  Master branch manual trigger: will create tag if needed"
            fi
          else
            # push äº‹ä»¶ï¼Œåªåœ¨ master åˆ†æ”¯åˆ›å»º tag
            IS_MANUAL_TRIGGER="false"
            if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
              SHOULD_CREATE_TAG="true"
              echo "â„¹ï¸  Master branch push: will create tag if needed"
            else
              SHOULD_CREATE_TAG="false"
              echo "â„¹ï¸  Non-master branch push: will skip tag creation"
            fi
          fi

          echo "is_feature_branch=$IS_FEATURE_BRANCH" >> $GITHUB_OUTPUT
          echo "is_manual_trigger=$IS_MANUAL_TRIGGER" >> $GITHUB_OUTPUT
          echo "should_create_tag=$SHOULD_CREATE_TAG" >> $GITHUB_OUTPUT

      - name: Check if tag exists and increment version if needed
        if: steps.detect_mode.outputs.should_create_tag == 'true'
        id: check_tag
        shell: bash
        run: |
          TAG="${{ steps.version.outputs.tag }}"
          VERSION="${{ steps.version.outputs.version }}"

          if git rev-parse "$TAG" >/dev/null 2>&1; then
            echo "âš ï¸  Tag $TAG already exists"
            echo "Current commit: $(git rev-parse HEAD)"
            echo "Tag commit: $(git rev-parse $TAG)"

            if [ "$(git rev-parse HEAD)" = "$(git rev-parse $TAG)" ]; then
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "needs_increment=false" >> $GITHUB_OUTPUT
              echo "version=$VERSION" >> $GITHUB_OUTPUT
              echo "tag=$TAG" >> $GITHUB_OUTPUT
              echo "âœ… Tag points to current commit, skipping tag creation"
            else
              echo "exists=true" >> $GITHUB_OUTPUT
              echo "needs_increment=true" >> $GITHUB_OUTPUT
              echo "âš ï¸  Tag points to different commit, auto-incrementing patch version"

              # è‡ªåŠ¨é€’å¢ patch ç‰ˆæœ¬å· (0.0.1 -> 0.0.2)
              IFS='.' read -ra VERSION_PARTS <<< "$VERSION"
              MAJOR="${VERSION_PARTS[0]:-0}"
              MINOR="${VERSION_PARTS[1]:-0}"
              PATCH="${VERSION_PARTS[2]:-0}"

              # é€’å¢ patch ç‰ˆæœ¬
              PATCH=$((PATCH + 1))
              if [ $PATCH -gt 9 ]; then
                PATCH=0
                MINOR=$((MINOR + 1))
              fi

              if [ $MINOR -gt 9 ]; then
                MINOR=0
                MAJOR=$((MAJOR + 1))
              fi

              NEW_VERSION="$MAJOR.$MINOR.$PATCH"
              NEW_TAG="v$NEW_VERSION"

              echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
              echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
              echo "old_version=$VERSION" >> $GITHUB_OUTPUT
              echo "old_tag=$TAG" >> $GITHUB_OUTPUT

              echo "âœ… Auto-incremented version: $VERSION -> $NEW_VERSION"
              echo "âœ… New tag: $NEW_TAG"
            fi
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "needs_increment=false" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT
            echo "âœ… Tag $TAG does not exist, will create it"
          fi

      - name: Setup Rust
        if: steps.check_tag.outputs.needs_increment == 'true'
        uses: dtolnay/rust-toolchain@stable

      - name: Update Cargo.toml and Cargo.lock version
        if: steps.check_tag.outputs.needs_increment == 'true'
        shell: bash
        run: |
          NEW_VERSION="${{ steps.check_tag.outputs.version }}"
          echo "Updating Cargo.toml and Cargo.lock version to $NEW_VERSION"

          # 1. æ›´æ–° Cargo.toml ä¸­çš„ç‰ˆæœ¬å·
          if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS
            sed -i '' "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          else
            # Linux
            sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          fi

          # éªŒè¯ Cargo.toml æ›´æ–°
          UPDATED_VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "âŒ Error: Failed to update version in Cargo.toml"
            exit 1
          fi
          echo "âœ… Cargo.toml updated: version = \"$NEW_VERSION\""

          # 2. ç›´æ¥æ‰‹åŠ¨æ›´æ–° Cargo.lock ä¸­çš„ç‰ˆæœ¬å·ï¼ˆé¿å…ç¼–è¯‘ä¾èµ–é—®é¢˜ï¼‰
          echo "Updating Cargo.lock to reflect new version in Cargo.toml..."

          # 3. æ‰‹åŠ¨æ›´æ–° Cargo.lock ä¸­çš„ç‰ˆæœ¬å·
          if grep -q 'name = "workflow"' Cargo.lock; then
            # ä½¿ç”¨ sed åœ¨ workflow åŒ…çš„ [[package]] å—ä¸­æ›´æ–°ç‰ˆæœ¬å·
            if [[ "$OSTYPE" == "darwin"* ]]; then
              # macOS: ä½¿ç”¨ sed æ›´æ–° workflow åŒ…çš„ç‰ˆæœ¬å·
              sed -i '' '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            else
              # Linux: ä½¿ç”¨ sed æ›´æ–°
              sed -i '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            fi
            # éªŒè¯æ›´æ–°
            LOCK_VERSION=$(grep -A 2 'name = "workflow"' Cargo.lock | grep 'version' | head -1 | sed -E 's/.*version = "([^"]+)".*/\1/')
            if [ "$LOCK_VERSION" = "$NEW_VERSION" ]; then
              echo "âœ… Cargo.lock updated: version = \"$LOCK_VERSION\""
            else
              echo "âš ï¸  Warning: Could not update Cargo.lock version. It will be updated on next build."
            fi
          else
            echo "âš ï¸  Warning: Could not find workflow package in Cargo.lock"
          fi

      - name: Create and merge version update pull request
        if: steps.check_tag.outputs.needs_increment == 'true'
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # é…ç½® Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          NEW_VERSION="${{ steps.check_tag.outputs.version }}"
          BRANCH_NAME="bump-version-${NEW_VERSION}"

          # ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºæ–°åˆ†æ”¯
          echo "Step 1: Creating branch $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"

          # ç¬¬äºŒæ­¥ï¼šæ·»åŠ æ–‡ä»¶
          echo "Step 2: Staging Cargo.toml and Cargo.lock"
          git add Cargo.toml Cargo.lock

          # ç¬¬ä¸‰æ­¥ï¼šæäº¤æ›´æ”¹
          echo "Step 3: Committing changes"
          git commit -m "chore: bump version to ${NEW_VERSION} [skip ci]"

          # ç¬¬å››æ­¥ï¼šæ¨é€åˆ°æ–°åˆ†æ”¯
          echo "Step 4: Pushing branch to origin"
          git push origin "$BRANCH_NAME"

          # ç¬¬äº”æ­¥ï¼šåˆ›å»º Pull Request
          echo "Step 5: Creating Pull Request"
          echo "Branch: $BRANCH_NAME"
          echo "Version: $NEW_VERSION"

          PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" \
            -d '{
              "title": "chore: bump version to '"$NEW_VERSION"'",
              "head": "'"$BRANCH_NAME"'",
              "base": "master",
              "body": "Automated version bump to '"$NEW_VERSION"'\n\nThis PR was created automatically by the release workflow.\n\n**Changes:**\n- Updated version in Cargo.toml to '"$NEW_VERSION"'\n- Updated version in Cargo.lock to '"$NEW_VERSION"'\n\n**Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }')

          HTTP_CODE=$(echo "$PR_RESPONSE" | tail -n1)
          PR_BODY=$(echo "$PR_RESPONSE" | head -n-1)

          echo "HTTP Status Code: $HTTP_CODE"

          if [ "$HTTP_CODE" != "201" ]; then
            echo "âš ï¸  Failed to create PR (HTTP $HTTP_CODE)"
            echo "Response body:"
            echo "$PR_BODY" | jq '.' 2>/dev/null || echo "$PR_BODY"

            # å¦‚æœæ˜¯ 422 é”™è¯¯ï¼ˆå·²å­˜åœ¨ PRï¼‰ï¼Œå°è¯•æŸ¥æ‰¾ç°æœ‰çš„ PR
            if [ "$HTTP_CODE" = "422" ]; then
              echo "Checking for existing PR..."
              EXISTING_PR=$(curl -s \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:$BRANCH_NAME&base=master&state=open")

              PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.[0].number // empty' 2>/dev/null)
              if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
                PR_URL=$(echo "$EXISTING_PR" | jq -r '.[0].html_url // empty' 2>/dev/null)
                echo "âœ… Found existing PR #$PR_NUMBER: $PR_URL"
                echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
                echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
                # ç»§ç»­æ‰§è¡Œåˆå¹¶æ­¥éª¤
              else
                exit 1
              fi
            else
              exit 1
            fi
          else
            # æå– PR ä¿¡æ¯
            PR_NUMBER=$(echo "$PR_BODY" | jq -r '.number // empty' 2>/dev/null || echo "$PR_BODY" | grep -o '"number":[0-9]*' | head -1 | cut -d':' -f2)
            PR_URL=$(echo "$PR_BODY" | jq -r '.html_url // empty' 2>/dev/null || echo "$PR_BODY" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
            echo "âœ… PR #$PR_NUMBER created: $PR_URL"
            echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
          fi

          # ç¡®ä¿ PR_NUMBER å·²è®¾ç½®
          if [ -z "$PR_NUMBER" ]; then
            echo "âŒ Error: PR_NUMBER is not set"
            exit 1
          fi

          # ç¬¬å…­æ­¥ï¼šåˆå¹¶ Pull Request
          echo "Step 6: Merging Pull Request"

          # ç­‰å¾… PR å¯åˆå¹¶ï¼ˆæœ€å¤šç­‰å¾… 2 åˆ†é’Ÿï¼Œæ¯ 5 ç§’æ£€æŸ¥ä¸€æ¬¡ï¼‰
          MAX_WAIT=120
          CHECK_INTERVAL=5
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            PR_STATUS=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGED=$(echo "$PR_STATUS" | grep -o '"merged":[^,}]*' | cut -d':' -f2 | tr -d ' "')
            MERGEABLE=$(echo "$PR_STATUS" | grep -o '"mergeable":[^,}]*' | cut -d':' -f2 | tr -d ' "')

            if [ "$MERGED" = "true" ]; then
              echo "âœ… PR already merged"
              # ç¬¬ä¸ƒæ­¥ï¼šåˆ é™¤è¿œç¨‹åˆ†æ”¯
              echo "Step 7: Deleting remote branch $BRANCH_NAME"
              # å…ˆåˆ‡æ¢å› master åˆ†æ”¯
              git checkout master 2>/dev/null || git checkout main 2>/dev/null || true
              # åˆ é™¤è¿œç¨‹åˆ†æ”¯
              if git push origin --delete "$BRANCH_NAME" 2>/dev/null; then
                echo "âœ… Remote branch $BRANCH_NAME deleted successfully"
              else
                echo "âš ï¸  Failed to delete remote branch (may already be deleted or protected)"
              fi
              exit 0
            fi

            if [ "$MERGEABLE" = "true" ]; then
              # å°è¯•åˆå¹¶
              MERGE_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer $GITHUB_TOKEN" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/merge" \
                -d '{
                  "commit_title": "chore: bump version to '"$NEW_VERSION"' [skip ci]",
                  "commit_message": "Automated version bump to '"$NEW_VERSION"'\n\nMerged via GitHub Actions workflow [skip ci]",
                  "merge_method": "squash"
                }')

              MERGE_CODE=$(echo "$MERGE_RESPONSE" | tail -n1)
              if [ "$MERGE_CODE" = "200" ]; then
                echo "âœ… PR merged successfully"
                # ç¬¬ä¸ƒæ­¥ï¼šåˆ é™¤è¿œç¨‹åˆ†æ”¯
                echo "Step 7: Deleting remote branch $BRANCH_NAME"
                # å…ˆåˆ‡æ¢å› master åˆ†æ”¯
                git checkout master 2>/dev/null || git checkout main 2>/dev/null || true
                # åˆ é™¤è¿œç¨‹åˆ†æ”¯
                if git push origin --delete "$BRANCH_NAME" 2>/dev/null; then
                  echo "âœ… Remote branch $BRANCH_NAME deleted successfully"
                else
                  echo "âš ï¸  Failed to delete remote branch (may already be deleted or protected)"
                fi
                exit 0
              else
                echo "âš ï¸  Failed to merge PR (HTTP $MERGE_CODE)"
                echo "Please manually merge: $PR_URL"
                exit 1
              fi
            fi

            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
          done

          echo "â° Timeout: PR did not become mergeable within ${MAX_WAIT}s"
          echo "Please manually merge: $PR_URL"
          exit 1

      - name: Create and push tag
        if: |
          steps.detect_mode.outputs.should_create_tag == 'true' &&
          (steps.check_tag.outputs.exists == 'false' || steps.check_tag.outputs.needs_increment == 'true')
        shell: bash
        run: |
          TAG="${{ steps.check_tag.outputs.tag }}"
          echo "Creating tag: $TAG"

          # é…ç½® Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # åˆ›å»º tag
          git tag "$TAG"

          # æ¨é€ tag
          echo "Pushing tag: $TAG"
          git push origin "$TAG"

          echo "âœ… Successfully created and pushed tag: $TAG"
          echo "â„¹ï¸  This tag push should trigger a new workflow run for building and releasing"

      - name: Set job outputs
        id: job_outputs
        shell: bash
        run: |
          # å¦‚æœæ˜¯ feature åˆ†æ”¯æ‰‹åŠ¨è§¦å‘ï¼Œä½¿ç”¨ version æ­¥éª¤çš„ outputsï¼Œä¸åˆ›å»º tag
          if [[ "${{ steps.detect_mode.outputs.is_feature_branch }}" == "true" && "${{ steps.detect_mode.outputs.is_manual_trigger }}" == "true" ]]; then
            TAG="${{ steps.version.outputs.tag }}"
            TAG_CREATED="false"
            echo "â„¹ï¸  Feature branch manual trigger: using version from Cargo.toml, tag_created=false"
          elif [[ "${{ steps.detect_mode.outputs.should_create_tag }}" == "true" ]]; then
            # æ­£å¸¸æµç¨‹ï¼šä½¿ç”¨ check_tag çš„ outputs
            TAG="${{ steps.check_tag.outputs.tag }}"
            TAG_CREATED="false"
            if [ "${{ steps.check_tag.outputs.exists }}" == "false" ] || [ "${{ steps.check_tag.outputs.needs_increment }}" == "true" ]; then
              TAG_CREATED="true"
            fi
          else
            # å…¶ä»–æƒ…å†µï¼ˆä¸åº”è¯¥åˆ°è¾¾è¿™é‡Œï¼Œä½†ä¸ºäº†å®‰å…¨ï¼‰
            TAG="${{ steps.version.outputs.tag }}"
            TAG_CREATED="false"
            echo "âš ï¸  Unexpected condition, using version from Cargo.toml"
          fi

          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "tag_created=$TAG_CREATED" >> $GITHUB_OUTPUT
          echo "âœ… Job outputs set: tag=$TAG, tag_created=$TAG_CREATED"

      - name: Skip tag creation
        if: |
          steps.detect_mode.outputs.should_create_tag == 'true' &&
          steps.check_tag.outputs.exists == 'true' &&
          steps.check_tag.outputs.needs_increment == 'false'
        shell: bash
        run: |
          echo "â­ï¸  Skipping tag creation: tag ${{ steps.check_tag.outputs.tag }} already exists and points to current commit"

      - name: Skip tag creation (feature branch)
        if: |
          steps.detect_mode.outputs.is_feature_branch == 'true' &&
          steps.detect_mode.outputs.is_manual_trigger == 'true'
        shell: bash
        run: |
          echo "â„¹ï¸  Feature branch manual trigger: skipping tag creation"
          echo "   Branch: ${{ github.ref }}"
          echo "   Version: ${{ steps.version.outputs.version }}"
          echo "   Tag: ${{ steps.version.outputs.tag }}"

  # æ„å»ºæ‰€æœ‰å¹³å°çš„äºŒè¿›åˆ¶æ–‡ä»¶
  build:
    runs-on: ${{ matrix.os }}
    needs: create-tag
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true')
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: macOS-Intel
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: macOS-AppleSilicon
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            platform: Linux-x86_64
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            platform: Linux-ARM64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            platform: Linux-x86_64-static
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            platform: Windows-x86_64
          - os: windows-latest
            target: aarch64-pc-windows-msvc
            platform: Windows-ARM64

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # å¦‚æœ create-tag job åˆ›å»ºäº†æ–° tagï¼Œcheckout è¯¥ tagï¼ˆåŒ…å«æ›´æ–°åçš„ Cargo.tomlï¼‰
          # å¦åˆ™ checkout åŸå§‹çš„ refï¼ˆtag push æˆ– workflow_dispatch çš„æƒ…å†µï¼‰
          ref: ${{ (needs.create-tag.outputs.tag_created == 'true' && needs.create-tag.outputs.tag) || github.ref }}

      - name: Get version from tag
        id: version
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
            VERSION=${VERSION#v}
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # ä»æ ‡ç­¾è·å–ç‰ˆæœ¬å·
            VERSION=${GITHUB_REF#refs/tags/}
            # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
            VERSION=${VERSION#v}
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            # ä» create-tag job çš„ outputs è·å–ç‰ˆæœ¬å·
            if [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
              VERSION="${{ needs.create-tag.outputs.tag }}"
              # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
              VERSION=${VERSION#v}
            else
              # å¦‚æœ outputs ä¸å¯ç”¨ï¼Œä» Cargo.toml è¯»å–
              VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
              if [ -z "$VERSION" ]; then
                echo "âŒ Error: Cannot read version from Cargo.toml"
                exit 1
              fi
            fi
          else
            echo "âŒ Error: Cannot determine version from context"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: v$VERSION"

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install musl target (if needed)
        if: contains(matrix.target, 'musl')
        run: |
          rustup target add ${{ matrix.target }}
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: Install cross-compilation toolchain (Linux ARM64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu python3
          # æ³¨æ„ï¼šclipboard åŠŸèƒ½åœ¨ Linux ARM64 ä¸Šå·²ç¦ç”¨ï¼ˆCargo.toml ä¸­é…ç½®ï¼‰
          # å› æ­¤ä¸éœ€è¦å®‰è£… XCB å¼€å‘åº“ï¼Œç®€åŒ–æ„å»ºæµç¨‹
          # ä½†éœ€è¦å®‰è£… Python3 ç”¨äºå¤„ç† Cargo.lock è„šæœ¬

      - name: Install system dependencies (Linux x86_64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'x86_64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          # å®‰è£… XCB å¼€å‘åº“ï¼ˆclipboard ä¾èµ–ï¼‰
          # xcb crate éœ€è¦ xcb-proto æ¥ç”Ÿæˆä»£ç æ¨¡å—ï¼ˆxproto, big_requests, etc.ï¼‰
          # xcb-proto éœ€è¦ Python æ¥è¿è¡Œä»£ç ç”Ÿæˆè„šæœ¬
          sudo apt-get install -y \
            python3 \
            python3-pip \
            python3-xcbgen \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev \
            pkg-config
          # éªŒè¯ xcb-proto åŒ…å’Œ Python å·²æ­£ç¡®å®‰è£…
          echo "ğŸ” Verifying xcb-proto package installation..."
          # xcb-proto ä¸æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºï¼Œè€Œæ˜¯ä¸€ä¸ªåŒ…å«åè®®æè¿°æ–‡ä»¶çš„åŒ…
          if dpkg -l | grep -q "^ii.*xcb-proto"; then
            echo "âœ… xcb-proto package is installed"
            # éªŒè¯åè®®æ–‡ä»¶ç›®å½•å­˜åœ¨
            if [ -d "/usr/share/xcb" ]; then
              echo "âœ… xcb protocol files directory found: /usr/share/xcb"
              # åˆ—å‡ºä¸€äº›åè®®æ–‡ä»¶ä»¥ç¡®è®¤
              PROTO_COUNT=$(find /usr/share/xcb -name "*.xml" 2>/dev/null | wc -l)
              if [ "$PROTO_COUNT" -gt 0 ]; then
                echo "âœ… Found $PROTO_COUNT protocol XML files"
              else
                echo "âš ï¸  Warning: No protocol XML files found in /usr/share/xcb"
              fi
            else
              echo "âš ï¸  Warning: /usr/share/xcb directory not found"
              # å°è¯•æŸ¥æ‰¾å®é™…ä½ç½®
              XCB_PROTO_DIR=$(dpkg -L xcb-proto 2>/dev/null | grep "/usr/share/xcb" | head -1 | xargs dirname 2>/dev/null || echo "")
              if [ -n "$XCB_PROTO_DIR" ] && [ -d "$XCB_PROTO_DIR" ]; then
                echo "âœ… Found xcb protocol directory at: $XCB_PROTO_DIR"
              fi
            fi
          else
            echo "âŒ Error: xcb-proto package is not installed"
            echo "   Please ensure xcb-proto package is installed via apt-get"
            exit 1
          fi
          python3 --version || echo "âš ï¸  Python3 not found"
          # éªŒè¯ xcbgen Python æ¨¡å—æ˜¯å¦å¯ç”¨ï¼ˆxcb crate æ„å»ºè„šæœ¬éœ€è¦ï¼‰
          echo "ğŸ” Checking for xcbgen Python module..."
          if python3 -c "import xcbgen" 2>/dev/null; then
            echo "âœ… xcbgen Python module is importable"
            # æ˜¾ç¤ºæ¨¡å—ä½ç½®
            python3 -c "import xcbgen; print(f'xcbgen location: {xcbgen.__file__}')" 2>/dev/null || true
          else
            echo "âŒ Error: xcbgen Python module is not importable"
            echo "   This is required for xcb crate to build"
            echo "   Please ensure python3-xcbgen package is installed"
            # å°è¯•æŸ¥æ‰¾ xcbgen æ¨¡å—çš„ä½ç½®
            XCBGEN_PATH=$(find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
            if [ -n "$XCBGEN_PATH" ]; then
              echo "   Found xcbgen directory at: $XCBGEN_PATH"
              echo "   Trying to add to PYTHONPATH..."
              export PYTHONPATH="$(dirname $XCBGEN_PATH):${PYTHONPATH:-}"
              echo "   PYTHONPATH: $PYTHONPATH"
              # å†æ¬¡å°è¯•å¯¼å…¥
              if python3 -c "import xcbgen" 2>/dev/null; then
                echo "âœ… xcbgen module is now importable after setting PYTHONPATH"
              else
                echo "âŒ xcbgen still not importable"
                exit 1
              fi
            else
              echo "   xcbgen directory not found"
              exit 1
            fi
          fi
          # éªŒè¯ pkg-config èƒ½æ‰¾åˆ° xcb åº“
          pkg-config --exists xcb && echo "âœ… xcb pkg-config found" || echo "âš ï¸  xcb pkg-config not found"

      - name: Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          # æ£€æŸ¥ pkg-config æ˜¯å¦å·²å®‰è£…ï¼Œé¿å…é‡å¤å®‰è£…è­¦å‘Š
          if ! command -v pkg-config >/dev/null 2>&1; then
            brew install pkg-config
          else
            echo "âœ… pkg-config is already installed"
          fi

      - name: Get Cargo.lock hash
        id: cargo_lock
        shell: bash
        run: |
          if [ -f "Cargo.lock" ]; then
            # macOS ä½¿ç”¨ shasumï¼ŒLinux ä½¿ç”¨ sha256sum
            if command -v shasum >/dev/null 2>&1; then
              HASH=$(shasum -a 256 Cargo.lock | cut -d' ' -f1 | head -c 16)
            else
              HASH=$(sha256sum Cargo.lock | cut -d' ' -f1 | head -c 16)
            fi
            echo "hash=$HASH" >> $GITHUB_OUTPUT
          else
            echo "hash=no-lock" >> $GITHUB_OUTPUT
          fi

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ matrix.target }}-${{ steps.cargo_lock.outputs.hash }}
          restore-keys: |
            ${{ runner.os }}-cargo-${{ matrix.target }}-

      - name: Build release binaries
        shell: bash
        env:
          CARGO_BUILD_TARGET: ${{ matrix.target }}
        run: |
          # ä¸º Linux x86_64 è®¾ç½® xcb æ„å»ºç¯å¢ƒ
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            echo "ğŸ” Setting up xcb build environment..."
            # xcb-proto ä¸æ˜¯ä¸€ä¸ªå¯æ‰§è¡Œç¨‹åºï¼Œè€Œæ˜¯ä¸€ä¸ªåŒ…å«åè®®æè¿°æ–‡ä»¶çš„åŒ…
            # xcb crate çš„æ„å»ºè„šæœ¬ä½¿ç”¨ Python çš„ xcbgen æ¨¡å—æ¥è¯»å–è¿™äº›æ–‡ä»¶
            # éªŒè¯ xcb-proto åŒ…å·²å®‰è£…ï¼ˆåè®®æ–‡ä»¶ï¼‰
            if dpkg -l | grep -q "^ii.*xcb-proto"; then
              echo "âœ… xcb-proto package is installed"
              # æŸ¥æ‰¾åè®®æ–‡ä»¶ç›®å½•ï¼ˆé€šå¸¸åœ¨ /usr/share/xcb/ï¼‰
              XCB_PROTO_DIR="/usr/share/xcb"
              if [ -d "$XCB_PROTO_DIR" ]; then
                echo "âœ… xcb protocol files found at: $XCB_PROTO_DIR"
                # è®¾ç½®ç¯å¢ƒå˜é‡æŒ‡å‘åè®®æ–‡ä»¶ç›®å½•ï¼ˆå¦‚æœ xcb crate éœ€è¦ï¼‰
                export XCB_PROTO_DIR="$XCB_PROTO_DIR"
              else
                # å°è¯•æŸ¥æ‰¾å®é™…ä½ç½®
                XCB_PROTO_DIR=$(dpkg -L xcb-proto 2>/dev/null | grep "/usr/share/xcb" | head -1 | xargs dirname 2>/dev/null || echo "")
                if [ -n "$XCB_PROTO_DIR" ] && [ -d "$XCB_PROTO_DIR" ]; then
                  echo "âœ… xcb protocol files found at: $XCB_PROTO_DIR"
                  export XCB_PROTO_DIR="$XCB_PROTO_DIR"
                else
                  echo "âš ï¸  Warning: xcb protocol directory not found, but package is installed"
                fi
              fi
            else
              echo "âŒ Error: xcb-proto package is not installed"
              exit 1
            fi
            # è®¾ç½® PKG_CONFIG_PATH ç¡®ä¿èƒ½æ‰¾åˆ° xcb åº“
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            echo "âœ… PKG_CONFIG_PATH set to: $PKG_CONFIG_PATH"
            # ç¡®ä¿ PYTHONPATH åŒ…å« xcbgen æ¨¡å—è·¯å¾„
            echo "ğŸ” Checking for xcbgen Python module..."
            # é¦–å…ˆå°è¯•ç›´æ¥å¯¼å…¥
            if python3 -c "import xcbgen" 2>/dev/null; then
              echo "âœ… xcbgen module is importable"
              # æ˜¾ç¤ºæ¨¡å—ä½ç½®ä»¥ä¾¿è°ƒè¯•
              python3 -c "import xcbgen; import os; print(f'xcbgen location: {os.path.dirname(xcbgen.__file__)}')" 2>/dev/null || true
              # ç¡®ä¿ PYTHONPATH åŒ…å«æ¨¡å—è·¯å¾„
              XCBGEN_DIR=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null)
              if [ -n "$XCBGEN_DIR" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_DIR):${PYTHONPATH:-}"
                echo "âœ… PYTHONPATH set to include xcbgen: $PYTHONPATH"
              fi
            else
              echo "âš ï¸  xcbgen not directly importable, trying to locate..."
              # å°è¯•æŸ¥æ‰¾å¹¶æ·»åŠ  xcbgen è·¯å¾„
              XCBGEN_PATH=$(find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_PATH" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_PATH):${PYTHONPATH:-}"
                echo "   Found xcbgen at: $XCBGEN_PATH"
                echo "   PYTHONPATH set to: $PYTHONPATH"
                # å†æ¬¡éªŒè¯
                if python3 -c "import xcbgen" 2>/dev/null; then
                  echo "âœ… xcbgen module is now importable"
                else
                  echo "âŒ xcbgen still not importable after setting PYTHONPATH"
                  echo "   Trying alternative method..."
                  # å°è¯•é€šè¿‡ pip å®‰è£…ï¼ˆå¦‚æœå¯ç”¨ï¼‰
                  python3 -m pip install --user xcbgen 2>/dev/null || true
                  if python3 -c "import xcbgen" 2>/dev/null; then
                    echo "âœ… xcbgen installed via pip"
                  else
                    echo "âŒ xcbgen installation failed"
                    exit 1
                  fi
                fi
              else
                echo "   xcbgen module directory not found"
                echo "   Checking installed packages..."
                dpkg -l | grep -i xcb || echo "   No xcb packages found"
                echo "   Attempting to install python3-xcbgen..."
                sudo apt-get install -y python3-xcbgen || {
                  echo "âŒ Failed to install python3-xcbgen"
                  exit 1
                }
                # å†æ¬¡å°è¯•
                if python3 -c "import xcbgen" 2>/dev/null; then
                  echo "âœ… xcbgen module is now importable after installation"
                else
                  echo "âŒ xcbgen still not importable"
                  exit 1
                fi
              fi
            fi
          fi
          # è®¾ç½®äº¤å‰ç¼–è¯‘ç¯å¢ƒå˜é‡ï¼ˆä»… Linux ARM64ï¼‰
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            echo "ğŸ”§ Cross-compiling for Linux ARM64"
            echo "â„¹ï¸  Note: clipboard feature is disabled for Linux ARM64 (XCB libraries not available in Ubuntu sources)"
            # æµ‹è¯•ï¼šæ³¨é‡Šæ‰ remove_xcb_deps.py è„šæœ¬è°ƒç”¨
            # ç†è®ºä¸Šï¼ŒCargo.toml ä¸­çš„æ¡ä»¶ç¼–è¯‘åº”è¯¥å·²ç»ç¦ç”¨äº† clipboard ä¾èµ–
            # å¦‚æœæ„å»ºå¤±è´¥ï¼Œè¯´æ˜ä»ç„¶éœ€è¦è¿™ä¸ªè„šæœ¬ï¼Œéœ€è¦å–æ¶ˆæ³¨é‡Šä¸‹é¢çš„ä»£ç 
            echo "ğŸ§ª Testing: Skipping Cargo.lock modification (relying on conditional compilation in Cargo.toml)"
            echo "â„¹ï¸  If build fails, the remove_xcb_deps.py script may still be needed"
            # å¯¹äº Linux ARM64ï¼Œæˆ‘ä»¬éœ€è¦ç¡®ä¿ Cargo ä¸ä¼šå°è¯•ç¼–è¯‘ xcb
            # ç”±äºæ¡ä»¶ç¼–è¯‘é…ç½®ï¼Œclipboard ä¾èµ–åº”è¯¥è¢«æ’é™¤ï¼Œä½† Cargo.lock å¯èƒ½ä»ç„¶åŒ…å«å®ƒ
            # è§£å†³æ–¹æ¡ˆï¼šä¸´æ—¶ä» Cargo.lock ä¸­ç§»é™¤è¿™äº›ä¾èµ–ï¼Œæ„å»ºåå†æ¢å¤
            # if [ -f "Cargo.lock" ]; then
            #   # æ£€æŸ¥ Python3 æ˜¯å¦å¯ç”¨
            #   if ! command -v python3 >/dev/null 2>&1; then
            #     echo "âŒ python3 is required but not found"
            #     exit 1
            #   fi
            #   cp Cargo.lock Cargo.lock.backup
            #   echo "ğŸ“ Backed up Cargo.lock"
            #   # ä½¿ç”¨ Python è„šæœ¬åˆ é™¤ clipboardã€x11-clipboardã€xcb å’Œ clipboard-win çš„åŒ…æ¡ç›®
            #   # ä»¥åŠä»å…¶ä»–åŒ…çš„ dependencies ä¸­ç§»é™¤å¯¹è¿™äº›åŒ…çš„å¼•ç”¨
            #   # Python è„šæœ¬æ›´å¯é ï¼Œèƒ½æ›´å¥½åœ°å¤„ç† TOML æ ¼å¼
            #   # æ·»åŠ è¶…æ—¶æœºåˆ¶ï¼ˆ120ç§’ï¼‰ï¼Œé˜²æ­¢è„šæœ¬å¡ä½
            #   echo "ğŸ”„ Processing Cargo.lock to remove xcb dependencies..."
            #   timeout 120 python3 .github/scripts/remove_xcb_deps.py || {
            #     EXIT_CODE=$?
            #     if [ $EXIT_CODE -eq 124 ]; then
            #       echo "âŒ Script timed out after 120 seconds"
            #       echo "âš ï¸  This may indicate a performance issue with the script"
            #     else
            #       echo "âŒ Script failed with exit code $EXIT_CODE"
            #     fi
            #     exit $EXIT_CODE
            #   }
            #
            #   if [ $? -ne 0 ]; then
            #     echo "âš ï¸  Failed to process Cargo.lock, restoring backup"
            #     if [ -f "Cargo.lock.backup" ]; then
            #       mv Cargo.lock.backup Cargo.lock
            #       echo "âœ… Restored Cargo.lock from backup"
            #     fi
            #     echo "âŒ Cannot proceed without removing xcb dependencies"
            #     exit 1
            #   fi
            #
            #   # éªŒè¯ Cargo.lock ä»ç„¶æœ‰æ•ˆï¼ˆè‡³å°‘åº”è¯¥èƒ½è§£æåŸºæœ¬ç»“æ„ï¼‰
            #   if ! grep -q '^\[\[package\]\]' Cargo.lock; then
            #     echo "âŒ Cargo.lock appears corrupted after processing"
            #     if [ -f "Cargo.lock.backup" ]; then
            #       mv Cargo.lock.backup Cargo.lock
            #       echo "âœ… Restored Cargo.lock from backup"
            #     fi
            #     exit 1
            #   fi
            # fi
          fi
          # æ„å»ºå‰éªŒè¯ï¼ˆä»… Linux x86_64ï¼‰
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            echo "ğŸ” Pre-build verification for xcb dependencies..."
            # é‡æ–°è®¾ç½®ç¯å¢ƒå˜é‡ï¼ˆå› ä¸ºæ¯ä¸ª step æ˜¯ç‹¬ç«‹çš„ shellï¼‰
            export XCB_PROTO_DIR="${XCB_PROTO_DIR:-/usr/share/xcb}"
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            # ç¡®ä¿ PYTHONPATH åŒ…å« xcbgen æ¨¡å—è·¯å¾„
            if [ -z "$PYTHONPATH" ] || ! python3 -c "import xcbgen" 2>/dev/null; then
              XCBGEN_DIR=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null || find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_DIR" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_DIR):${PYTHONPATH:-}"
              fi
            fi
            # éªŒè¯ xcb-proto åŒ…å·²å®‰è£…
            if dpkg -l | grep -q "^ii.*xcb-proto"; then
              echo "âœ… xcb-proto package is installed"
              # éªŒè¯åè®®æ–‡ä»¶ç›®å½•å­˜åœ¨
              if [ -n "$XCB_PROTO_DIR" ] && [ -d "$XCB_PROTO_DIR" ]; then
                echo "âœ… xcb protocol directory: $XCB_PROTO_DIR"
                # åˆ—å‡ºä¸€äº›åè®®æ–‡ä»¶
                echo "   Protocol files found:"
                ls -1 "$XCB_PROTO_DIR"/*.xml 2>/dev/null | head -5 | xargs -n1 basename || echo "   (none found)"
              else
                echo "âš ï¸  Warning: XCB_PROTO_DIR not set or directory not found"
              fi
            else
              echo "âŒ xcb-proto package is not installed"
              exit 1
            fi
            # éªŒè¯ Python
            if command -v python3 >/dev/null 2>&1; then
              echo "âœ… python3: $(which python3)"
            else
              echo "âŒ python3 not found"
              exit 1
            fi
            # éªŒè¯ xcbgen Python æ¨¡å—ï¼ˆå¿…éœ€ï¼‰
            if python3 -c "import xcbgen" 2>/dev/null; then
              echo "âœ… xcbgen Python module is importable"
              python3 -c "import xcbgen; import os; print(f'   xcbgen location: {os.path.dirname(xcbgen.__file__)}')" 2>/dev/null || true
            else
              echo "âŒ Error: xcbgen module not importable"
              echo "   This is required for xcb crate to build"
              echo "   PYTHONPATH: ${PYTHONPATH:-not set}"
              echo "   Python path: $(python3 -c 'import sys; print(":".join(sys.path))' 2>/dev/null || echo 'unknown')"
              exit 1
            fi
            # éªŒè¯ pkg-config
            if pkg-config --exists xcb; then
              echo "âœ… xcb libraries found via pkg-config"
              pkg-config --modversion xcb
            else
              echo "âš ï¸  Warning: xcb not found via pkg-config"
            fi
            # æ˜¾ç¤ºæœ€ç»ˆç¯å¢ƒå˜é‡
            echo "ğŸ“‹ Environment variables for build:"
            echo "   XCB_PROTO_DIR: ${XCB_PROTO_DIR}"
            echo "   PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
            echo "   PYTHONPATH: ${PYTHONPATH:-not set}"
          fi
          # æ„å»ºé¡¹ç›®
          # å¯¹äº Linux x86_64ï¼Œå¯ç”¨è¯¦ç»†è¾“å‡ºä»¥ä¾¿è°ƒè¯• xcb æ„å»ºé—®é¢˜
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            echo "ğŸ”¨ Building with verbose output for xcb debugging..."
            # ç¡®ä¿ç¯å¢ƒå˜é‡åœ¨æ„å»ºæ—¶å¯ç”¨
            # xcb crate çš„æ„å»ºè„šæœ¬éœ€è¦è¿™äº›ç¯å¢ƒå˜é‡
            export XCB_PROTO_DIR="${XCB_PROTO_DIR:-/usr/share/xcb}"
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            # ç¡®ä¿ PYTHONPATH åŒ…å« xcbgen æ¨¡å—è·¯å¾„
            if [ -z "$PYTHONPATH" ] || ! python3 -c "import xcbgen" 2>/dev/null; then
              XCBGEN_PATH=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null || find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_PATH" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_PATH):${PYTHONPATH:-}"
              fi
            fi
            # æ¸…ç†ä¹‹å‰çš„æ„å»ºç¼“å­˜ï¼Œé¿å…ç¼“å­˜é—®é¢˜
            echo "ğŸ§¹ Cleaning xcb build artifacts..."
            # æ¸…ç† xcb åŒ…çš„æ„å»ºç¼“å­˜
            cargo clean -p xcb 2>/dev/null || true
            # ä¹Ÿæ¸…ç†æ„å»ºè¾“å‡ºç›®å½•ä¸­çš„ xcb ç›¸å…³æ–‡ä»¶
            rm -rf target/${{ matrix.target }}/release/build/xcb-* 2>/dev/null || true
            rm -rf target/${{ matrix.target }}/release/deps/libxcb-* 2>/dev/null || true
            # æ˜¾ç¤ºæœ€ç»ˆçš„ç¯å¢ƒå˜é‡è®¾ç½®
            echo "ğŸ“‹ Final environment variables:"
            echo "   XCB_PROTO_DIR: ${XCB_PROTO_DIR}"
            echo "   PKG_CONFIG_PATH: ${PKG_CONFIG_PATH}"
            echo "   PYTHONPATH: ${PYTHONPATH:-not set}"
            echo "   Python version: $(python3 --version 2>&1 || echo "unknown")"
            echo "   Python xcbgen: $(python3 -c 'import xcbgen; print("OK")' 2>&1 || echo "FAILED")"
            # éªŒè¯ Python ç‰ˆæœ¬å…¼å®¹æ€§ï¼ˆxcbgen éœ€è¦ Python 3.6+ï¼‰
            PYTHON_VERSION=$(python3 -c 'import sys; print(f"{sys.version_info.major}.{sys.version_info.minor}")' 2>/dev/null || echo "unknown")
            echo "   Python version check: $PYTHON_VERSION"
            if [ "$PYTHON_VERSION" != "unknown" ]; then
              MAJOR=$(echo "$PYTHON_VERSION" | cut -d. -f1)
              MINOR=$(echo "$PYTHON_VERSION" | cut -d. -f2)
              if [ "$MAJOR" -lt 3 ] || ([ "$MAJOR" -eq 3 ] && [ "$MINOR" -lt 6 ]); then
                echo "âš ï¸  Warning: Python version $PYTHON_VERSION may be too old for xcbgen"
              else
                echo "âœ… Python version $PYTHON_VERSION is compatible"
              fi
            fi
            # æµ‹è¯• xcbgen æ˜¯å¦èƒ½æ­£å¸¸å·¥ä½œ
            echo "ğŸ§ª Testing xcbgen functionality..."
            if python3 -c "import xcbgen; import os; import sys; proto_dir = '${XCB_PROTO_DIR}'; print('âœ… Protocol directory exists:', proto_dir) if os.path.isdir(proto_dir) else (print('âŒ Protocol directory not found:', proto_dir), sys.exit(1)); import xcbgen.state, xcbgen.xtypes; print('âœ… xcbgen modules imported successfully')" 2>/dev/null; then
              echo "âœ… xcbgen test passed"
            else
              echo "âš ï¸  xcbgen test failed, but continuing with build..."
            fi
            # æ„å»º
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install -vv 2>&1 | tee build.log; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
              echo "âŒ Build failed. Checking build log for xcb-related errors..."
              grep -i "xcb\|xproto\|big_requests\|xcbgen\|xc_misc\|render\|shape\|xfixes" build.log || echo "No xcb-related errors found in log"
              # æ˜¾ç¤ºæ„å»ºè„šæœ¬è¾“å‡ºï¼ˆå¦‚æœæœ‰ï¼‰
              echo "ğŸ“‹ Checking for build script errors..."
              grep -i "error\|warning\|failed" build.log | head -20 || true
            fi
          else
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
            fi
          fi

          # æ¢å¤ Cargo.lockï¼ˆå¦‚æœå¤‡ä»½å­˜åœ¨ï¼Œæ— è®ºæ„å»ºæˆåŠŸä¸å¦éƒ½è¦æ¢å¤ï¼‰
          # æµ‹è¯•ï¼šæ³¨é‡Šæ‰æ¢å¤é€»è¾‘ï¼Œå› ä¸ºä¸å†åˆ›å»ºå¤‡ä»½
          # if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]] && [ -f "Cargo.lock.backup" ]; then
          #   mv Cargo.lock.backup Cargo.lock
          #   echo "âœ… Restored Cargo.lock from backup"
          # fi

          # å¦‚æœæ„å»ºå¤±è´¥ï¼Œé€€å‡ºå¹¶è¿”å›é”™è¯¯ç 
          if [ "$BUILD_SUCCESS" != "true" ]; then
            echo "âŒ Build failed"
            exit 1
          fi

      - name: Create package directory
        shell: bash
        run: |
          mkdir -p package
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cp target/${{ matrix.target }}/release/workflow.exe package/
            cp target/${{ matrix.target }}/release/install.exe package/
            echo "âœ… Copied workflow.exe and install.exe to package/"
          else
            cp target/${{ matrix.target }}/release/workflow package/
            cp target/${{ matrix.target }}/release/install package/
            echo "âœ… Copied workflow and install binaries to package/"
          fi

      - name: Create archive (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $archiveName = "workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          $archivePath = Join-Path $PWD $archiveName
          # è¿›å…¥ package ç›®å½•
          Push-Location package
          try {
            # æ‰“åŒ… workflow.exe å’Œ install.exe ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
            Compress-Archive -Path "workflow.exe", "install.exe" -DestinationPath $archivePath -Force
            # æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
            $fileInfo = Get-Item $archivePath
            Write-Host "ğŸ“¦ Archive created: $archiveName"
            Write-Host "   Size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
            # éªŒè¯æ‰“åŒ…å†…å®¹
            Write-Host "ğŸ“¦ Archive contents:"
            $verifyPath = Join-Path $env:TEMP "workflow-verify"
            Expand-Archive -Path $archivePath -DestinationPath $verifyPath -Force
            Get-ChildItem $verifyPath | ForEach-Object { Write-Host "   $($_.Name)" }
            Remove-Item $verifyPath -Recurse -Force
          } finally {
            Pop-Location
          }

      - name: Create archive (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          cd package
          ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          # æ‰“åŒ… workflow å’Œ install ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
          tar czf "../$ARCHIVE_NAME" workflow install
          cd ..
          ls -lh "$ARCHIVE_NAME"
          # éªŒè¯æ‰“åŒ…å†…å®¹
          echo "ğŸ“¦ Archive contents:"
          tar tzf "$ARCHIVE_NAME"

      - name: Calculate SHA256
        id: sha256
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          else
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          fi
          if [[ "${{ matrix.os }}" == "macos-latest" ]]; then
            SHA256=$(shasum -a 256 "$ARCHIVE_NAME" | cut -d' ' -f1)
          elif [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            # Windows: ä½¿ç”¨ PowerShell è®¡ç®— SHA256
            SHA256=$(powershell -Command "(Get-FileHash -Path '$ARCHIVE_NAME' -Algorithm SHA256).Hash")
          else
            SHA256=$(sha256sum "$ARCHIVE_NAME" | cut -d' ' -f1)
          fi
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "platform=${{ matrix.platform }}" >> $GITHUB_OUTPUT
          echo "archive=$ARCHIVE_NAME" >> $GITHUB_OUTPUT
          echo "SHA256 for ${{ matrix.platform }}: $SHA256"

      - name: Save SHA256 to file
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          else
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          fi
          echo "${{ steps.sha256.outputs.sha256 }}" > sha256-${{ matrix.platform }}.txt
          echo "${{ matrix.platform }}" >> sha256-${{ matrix.platform }}.txt
          echo "$ARCHIVE_NAME" >> sha256-${{ matrix.platform }}.txt

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}
          path: |
            workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.${{ matrix.os == 'windows-latest' && 'zip' || 'tar.gz' }}
          retention-days: 30

      - name: Upload SHA256
        uses: actions/upload-artifact@v4
        with:
          name: sha256-${{ matrix.platform }}
          path: |
            sha256-${{ matrix.platform }}.txt
          retention-days: 30

  # åˆ›å»º GitHub Release å¹¶ä¸Šä¼ æ‰€æœ‰äºŒè¿›åˆ¶æ–‡ä»¶
  release:
    name: Run create-release
    needs: [create-tag, build]
    runs-on: ubuntu-latest
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
      pull-requests: read  # è¯»å– PRï¼ˆå¦‚æœéœ€è¦ï¼‰

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version from tag
        id: version
        shell: bash
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            VERSION="${{ github.event.inputs.version }}"
            # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
            VERSION=${VERSION#v}
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # ä»æ ‡ç­¾è·å–ç‰ˆæœ¬å·
            VERSION=${GITHUB_REF#refs/tags/}
            # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
            VERSION=${VERSION#v}
          elif [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            # ä» create-tag job çš„ outputs è·å–ç‰ˆæœ¬å·
            if [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
              VERSION="${{ needs.create-tag.outputs.tag }}"
              # ç§»é™¤ v å‰ç¼€ï¼ˆå¦‚æœæœ‰ï¼‰
              VERSION=${VERSION#v}
            else
              # å¦‚æœ outputs ä¸å¯ç”¨ï¼Œä» Cargo.toml è¯»å–
              VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
              if [ -z "$VERSION" ]; then
                echo "âŒ Error: Cannot read version from Cargo.toml"
                exit 1
              fi
            fi
          else
            echo "âŒ Error: Cannot determine version from context"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: v$VERSION"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release assets
        shell: bash
        run: |
          mkdir -p release-assets
          # å¤åˆ¶å‹ç¼©åŒ…æ–‡ä»¶
          find artifacts -name "workflow-*.tar.gz" -exec cp {} release-assets/ \;
          find artifacts -name "workflow-*.zip" -exec cp {} release-assets/ \;

          # ä¸ºæ¯ä¸ªå‹ç¼©åŒ…åˆ›å»ºå¯¹åº”çš„ .sha256 æ–‡ä»¶
          cd release-assets
          for archive in workflow-*.tar.gz workflow-*.zip; do
            if [ -f "$archive" ]; then
              # ä»æ–‡ä»¶åæå–å¹³å°ä¿¡æ¯ï¼ˆä¾‹å¦‚ï¼šworkflow-1.3.4-macOS-AppleSilicon.tar.gz -> macOS-AppleSiliconï¼‰
              PLATFORM=$(echo "$archive" | sed -E 's/workflow-[0-9]+\.[0-9]+\.[0-9]+-(.+)\.(tar\.gz|zip)/\1/')

              # æŸ¥æ‰¾å¯¹åº”çš„ SHA256 æ–‡ä»¶ï¼ˆartifacts ç›®å½•ç»“æ„ï¼šartifacts/sha256-{platform}/sha256-{platform}.txtï¼‰
              SHA256_FILE=$(find ../artifacts -path "*/sha256-$PLATFORM/sha256-$PLATFORM.txt" | head -1)

              if [ -f "$SHA256_FILE" ]; then
                # æå–ç¬¬ä¸€è¡Œï¼ˆå“ˆå¸Œå€¼ï¼‰
                SHA256_HASH=$(head -n 1 "$SHA256_FILE")
                # åˆ›å»º .sha256 æ–‡ä»¶ï¼ˆåªåŒ…å«å“ˆå¸Œå€¼ï¼Œç¬¦åˆ parse_hash_from_content çš„æœŸæœ›æ ¼å¼ï¼‰
                echo "$SHA256_HASH" > "${archive}.sha256"
                echo "âœ… Created ${archive}.sha256: $SHA256_HASH"
              else
                echo "âš ï¸  Warning: SHA256 file not found for $archive (platform: $PLATFORM)"
                echo "   Searched in: $(find ../artifacts -name "*$PLATFORM*" -type f 2>/dev/null | head -5)"
              fi
            fi
          done
          cd ..

          if [ -z "$(ls -A release-assets)" ]; then
            echo "Error: No release assets found!"
            exit 1
          fi
          echo "ğŸ“¦ Release assets prepared:"
          ls -lh release-assets/

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: Release ${{ steps.version.outputs.tag }}
          make_latest: true
          body: |
            ## Release ${{ steps.version.outputs.tag }}

            ### Downloads

            #### macOS
            - **macOS Intel**: [workflow-${{ steps.version.outputs.version }}-macOS-Intel.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-Intel.tar.gz)
            - **macOS Apple Silicon**: [workflow-${{ steps.version.outputs.version }}-macOS-AppleSilicon.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-AppleSilicon.tar.gz)

            #### Linux
            - **Linux x86_64 (glibc)**: [workflow-${{ steps.version.outputs.version }}-Linux-x86_64.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-x86_64.tar.gz) - For most Linux distributions (Ubuntu, Debian, Fedora, CentOS, etc.)
            - **Linux ARM64**: [workflow-${{ steps.version.outputs.version }}-Linux-ARM64.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-ARM64.tar.gz) - For ARM64 servers (AWS Graviton, Raspberry Pi 4+, etc.)
            - **Linux x86_64 (static/musl)**: [workflow-${{ steps.version.outputs.version }}-Linux-x86_64-static.tar.gz](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-x86_64-static.tar.gz) - Static binary for Alpine Linux, Docker containers, or older distributions

            #### Windows
            - **Windows x86_64**: [workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip) - For Windows 10/11 (64-bit, Intel/AMD)
            - **Windows ARM64**: [workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip](https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip) - For Windows on ARM devices (Surface Pro X, Surface Laptop Studio, etc.)

            ### Installation

            #### macOS

            ```bash
            # Download and extract
            # For Intel Mac
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-Intel.tar.gz
            # For Apple Silicon Mac
            # curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-macOS-AppleSilicon.tar.gz
            tar xzf workflow-${{ steps.version.outputs.version }}-*.tar.gz

            # Install binaries and completions
            ./install
            ```

            #### Linux

            **For most Linux distributions (Ubuntu, Debian, Fedora, CentOS, etc.):**
            ```bash
            # Download and extract x86_64 version
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-x86_64.tar.gz
            tar xzf workflow-${{ steps.version.outputs.version }}-Linux-x86_64.tar.gz
            ./install
            ```

            **For ARM64 servers (AWS Graviton, Raspberry Pi 4+, etc.):**
            ```bash
            # Download and extract ARM64 version
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-ARM64.tar.gz
            tar xzf workflow-${{ steps.version.outputs.version }}-Linux-ARM64.tar.gz
            ./install
            ```

            **For Alpine Linux, Docker containers, or older distributions:**
            ```bash
            # Download and extract static version (musl)
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Linux-x86_64-static.tar.gz
            tar xzf workflow-${{ steps.version.outputs.version }}-Linux-x86_64-static.tar.gz
            ./install
            ```

            #### Windows

            **For Windows x86_64 (Intel/AMD):**

            **Using PowerShell:**
            ```powershell
            # Download and extract
            Invoke-WebRequest -Uri "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip" -OutFile "workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip"
            Expand-Archive -Path "workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip" -DestinationPath "."

            # Install binaries and completions
            .\install.exe
            ```

            **For Windows ARM64 (Surface Pro X, Surface Laptop Studio, etc.):**

            **Using PowerShell:**
            ```powershell
            # Download and extract
            Invoke-WebRequest -Uri "https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip" -OutFile "workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip"
            Expand-Archive -Path "workflow-${{ steps.version.outputs.version }}-Windows-ARM64.zip" -DestinationPath "."

            # Install binaries and completions
            .\install.exe
            ```

            **Using Command Prompt (x86_64):**
            ```cmd
            # Download using curl (if available) or use a browser
            curl -LO https://github.com/${{ github.repository }}/releases/download/${{ steps.version.outputs.tag }}/workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip

            # Extract using PowerShell (or use 7-Zip/WinRAR)
            powershell -Command "Expand-Archive -Path 'workflow-${{ steps.version.outputs.version }}-Windows-x86_64.zip' -DestinationPath '.'"

            # Install binaries and completions
            install.exe
            ```

            **Note:** After installation, you may need to add `%LOCALAPPDATA%\Programs\workflow\bin` to your PATH environment variable.

            ### Homebrew (macOS only)

            Install via Homebrew:
            ```bash
            brew tap zevwings/workflow
            brew install workflow
            ```
          files: release-assets/*
          draft: false
          prerelease: false

  # è‡ªåŠ¨æ›´æ–° Homebrew Formula
  update-homebrew:
    name: Run update-homebrew
    needs: [create-tag, build, release]
    runs-on: ubuntu-latest
    if: |
      startsWith(github.ref, 'refs/tags/v') ||
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write  # å…è®¸æ¨é€åˆ° homebrew-workflow ä»“åº“

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get version and detect install type
        id: version
        shell: bash
        run: |
          # æ£€æµ‹æ˜¯ tag è¿˜æ˜¯ branch
          # ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦æ˜¯ä» create-tag job åˆ›å»ºçš„ tagï¼ˆåœ¨ master push æ—¶ï¼‰
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/master" ]]; then
            # åœ¨ master push æ—¶ï¼Œå¦‚æœ create-tag job åˆ›å»ºäº† tagï¼Œåº”è¯¥ä½¿ç”¨ tag
            if [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
              INSTALL_TYPE="tag"
              VERSION_REF="${{ needs.create-tag.outputs.tag }}"
              VERSION="${VERSION_REF#v}"  # ç§»é™¤ v å‰ç¼€
              echo "âœ… Detected as TAG from create-tag job: $VERSION_REF"
            else
              # å¦‚æœæ²¡æœ‰åˆ›å»º tagï¼Œåˆ™ä½¿ç”¨ branch
              INSTALL_TYPE="branch"
              VERSION_REF="${GITHUB_REF#refs/heads/}"
              VERSION="0.0.0-dev"
              echo "âœ… Detected as BRANCH: $VERSION_REF"
              echo "â„¹ï¸  Using default version for branch: $VERSION"
            fi
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # æ˜¯ tag push è§¦å‘çš„ workflow
            INSTALL_TYPE="tag"
            VERSION_REF="${GITHUB_REF#refs/tags/}"
            VERSION="${VERSION_REF#v}"  # ç§»é™¤ v å‰ç¼€
            echo "âœ… Detected as TAG: $VERSION_REF"
          elif [[ "${{ github.ref }}" == refs/heads/* ]]; then
            # æ˜¯ branch push è§¦å‘çš„ workflowï¼ˆé masterï¼Œæˆ– master ä½†æ²¡æœ‰åˆ›å»º tagï¼‰
            INSTALL_TYPE="branch"
            VERSION_REF="${GITHUB_REF#refs/heads/}"
            # å¯¹äº branchï¼Œç‰ˆæœ¬å·å¯ä»¥ä» workflow_dispatch input æˆ–ä½¿ç”¨é»˜è®¤ç‰ˆæœ¬
            if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              VERSION="${{ github.event.inputs.version }}"
            else
              # å¯¹äº branchï¼Œä½¿ç”¨é»˜è®¤ç‰ˆæœ¬å·ï¼ˆå› ä¸º branch åå¯èƒ½åŒ…å«ç‰¹æ®Šå­—ç¬¦ï¼Œä¸é€‚åˆä½œä¸º versionï¼‰
              # å¯ä»¥å°† branch åè½¬æ¢ä¸ºæœ‰æ•ˆçš„ç‰ˆæœ¬å·æ ¼å¼ï¼Œæˆ–ä½¿ç”¨å›ºå®šçš„å¼€å‘ç‰ˆæœ¬å·
              # ä¾‹å¦‚ï¼šzw/update-completions -> 0.0.0-dev (æˆ–è€…ä½¿ç”¨æ—¥æœŸç­‰)
              VERSION="0.0.0-dev"
            fi
            echo "âœ… Detected as BRANCH: $VERSION_REF"
            echo "â„¹ï¸  Using default version for branch: $VERSION"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # æ‰‹åŠ¨è§¦å‘ï¼Œé»˜è®¤ä½¿ç”¨ tag
            INSTALL_TYPE="tag"
            VERSION_REF="${{ github.event.inputs.version }}"
            VERSION="${VERSION_REF#v}"
            echo "âœ… Manual trigger, using as TAG: $VERSION_REF"
          else
            echo "âŒ Error: Cannot determine install type from ${{ github.ref }}"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "install_type=$INSTALL_TYPE" >> $GITHUB_OUTPUT
          echo "version_ref=$VERSION_REF" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT
          echo ""
          echo "Install Type: $INSTALL_TYPE"
          echo "Version Ref: $VERSION_REF"
          echo "Version: $VERSION"

      # æ³¨æ„ï¼šä½¿ç”¨ git tag æ–¹å¼æ—¶ï¼Œä¸éœ€è¦ SHA256 æ ¡éªŒ
      # å› ä¸º Homebrew ä¼šç›´æ¥ä» git ä»“åº“ checkout æŒ‡å®šçš„ tag

      - name: Check HOMEBREW_TAP_TOKEN
        id: check_token
        shell: bash
        run: |
          if [ -z "${{ secrets.HOMEBREW_TAP_TOKEN }}" ]; then
            echo "âŒ Error: HOMEBREW_TAP_TOKEN secret is not configured"
            echo ""
            echo "Please configure HOMEBREW_TAP_TOKEN secret:"
            echo "1. Go to: Settings â†’ Secrets and variables â†’ Actions"
            echo "2. Click 'New repository secret'"
            echo "3. Name: HOMEBREW_TAP_TOKEN"
            echo "4. Value: Your Personal Access Token (PAT) with 'repo' scope"
            echo ""
            echo "To create a PAT:"
            echo "1. Go to: https://github.com/settings/tokens"
            echo "2. Click 'Generate new token (classic)'"
            echo "3. Select 'repo' scope (full control of private repositories)"
            echo "4. Copy the token and add it as HOMEBREW_TAP_TOKEN secret"
            exit 1
          else
            echo "âœ… HOMEBREW_TAP_TOKEN is configured"
          fi

      - name: Checkout homebrew-workflow
        uses: actions/checkout@v4
        with:
          repository: zevwings/homebrew-workflow
          path: homebrew-workflow
          token: ${{ secrets.HOMEBREW_TAP_TOKEN }}

      - name: Update Formula from template
        shell: bash
        run: |
          # æ¨¡æ¿æ–‡ä»¶å’Œç›®æ ‡æ–‡ä»¶è·¯å¾„
          TEMPLATE_FILE="homebrew/Formula.template"
          FORMULA_FILE="homebrew-workflow/Formula/workflow.rb"

          # æ£€æŸ¥æ¨¡æ¿æ–‡ä»¶æ˜¯å¦å­˜åœ¨
          if [ ! -f "$TEMPLATE_FILE" ]; then
            echo "âŒ Error: Template file not found at $TEMPLATE_FILE"
            echo "Make sure homebrew/Formula.template exists in the source repository"
            exit 1
          fi

          # ç¡®ä¿ homebrew-workflow/Formula ç›®å½•å­˜åœ¨
          mkdir -p homebrew-workflow/Formula

          # å¤‡ä»½ç°æœ‰çš„ Formula æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          if [ -f "$FORMULA_FILE" ]; then
            cp "$FORMULA_FILE" "$FORMULA_FILE.bak"
            echo "ğŸ“¦ Backed up existing Formula file"
          fi

          # ä»æ¨¡æ¿ç”Ÿæˆ URL è¡Œ
          INSTALL_TYPE="${{ steps.version.outputs.install_type }}"
          VERSION_REF="${{ steps.version.outputs.version_ref }}"

          if [[ "$INSTALL_TYPE" == "tag" ]]; then
            URL_LINE="url \"https://github.com/zevwings/workflow.rs.git\", tag: \"$VERSION_REF\""
          elif [[ "$INSTALL_TYPE" == "branch" ]]; then
            URL_LINE="url \"https://github.com/zevwings/workflow.rs.git\", branch: \"$VERSION_REF\""
          else
            echo "âŒ Error: Invalid install type: $INSTALL_TYPE"
            exit 1
          fi

          echo "ğŸ”§ Generated URL line: $URL_LINE"

          # ä»æ¨¡æ¿ç”Ÿæˆ Formula æ–‡ä»¶
          echo "ğŸ“ Generating Formula file from template..."
          sed -e "s|{{VERSION}}|${{ steps.version.outputs.version }}|g" \
              -e "s|{{INSTALL_TYPE}}|$INSTALL_TYPE|g" \
              -e "s|{{VERSION_REF}}|$VERSION_REF|g" \
              -e "s|{{URL_LINE}}|$URL_LINE|g" \
              "$TEMPLATE_FILE" > "$FORMULA_FILE"

          echo "âœ… Formula file generated from template"

          cd homebrew-workflow

          # æ›´æ–°ä¸ºç›¸å¯¹äº homebrew-workflow ç›®å½•çš„è·¯å¾„
          FORMULA_FILE="Formula/workflow.rb"

          # éªŒè¯æ–‡ä»¶ç»“æ„ï¼ˆç¡®ä¿æ²¡æœ‰è¯­æ³•é”™è¯¯ï¼‰
          echo "ğŸ” Validating Formula file structure..."
          if ! ruby -c "$FORMULA_FILE" 2>/dev/null; then
            echo "âŒ Error: Formula file has syntax errors"
            ruby -c "$FORMULA_FILE" || true
            exit 1
          fi
          echo "âœ… Formula file syntax is valid"

          # æ˜¾ç¤ºç”Ÿæˆçš„ Formula æ–‡ä»¶
          echo ""
          echo "ğŸ“„ Generated Formula file:"
          echo "--- Formula/workflow.rb ---"
          cat "$FORMULA_FILE"
          echo ""

          # æ˜¾ç¤ºæ›´æ”¹ï¼ˆå¦‚æœæœ‰å¤‡ä»½ï¼‰
          if [ -f "$FORMULA_FILE.bak" ]; then
            echo "--- Diff (Before vs After) ---"
            diff "$FORMULA_FILE.bak" "$FORMULA_FILE" || true
          fi

      - name: Commit and push changes
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.HOMEBREW_TAP_TOKEN }}
        run: |
          cd homebrew-workflow

          # é…ç½® Git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
          git add Formula/workflow.rb

          if git diff --staged --quiet; then
            echo "No changes to commit. Formula file is already up to date."
            exit 0
          fi

          # éªŒè¯ Formula æ–‡ä»¶æ ¼å¼
          if ! brew audit --strict Formula/workflow.rb 2>/dev/null; then
            echo "Warning: brew audit failed, but continuing..."
          fi

          # æäº¤æ›´æ”¹
          git commit -m "Update workflow to ${{ steps.version.outputs.tag }}"

          # æ£€æµ‹å½“å‰åˆ†æ”¯åç§°
          CURRENT_BRANCH=$(git branch --show-current)
          echo "Current branch: $CURRENT_BRANCH"

          # actions/checkout@v4 å·²ç»è®¾ç½®äº†æ­£ç¡®çš„è¿œç¨‹ URLï¼Œç›´æ¥æ¨é€å³å¯
          # æ¨é€æ›´æ”¹åˆ°å½“å‰åˆ†æ”¯
          echo "Pushing to branch: $CURRENT_BRANCH"
          if git push origin "$CURRENT_BRANCH"; then
            echo "âœ… Successfully pushed to $CURRENT_BRANCH branch"
          else
            echo "âŒ Error: Failed to push changes to $CURRENT_BRANCH"
            echo "Remote URL: $(git remote get-url origin | sed 's|://.*@|://***@|')"
            echo "Branch: $CURRENT_BRANCH"
            echo "Git status:"
            git status
            echo "Git log:"
            git log --oneline -5
            echo ""
            echo "Possible issues:"
            echo "1. HOMEBREW_TAP_TOKEN may not have write access to zevwings/homebrew-workflow"
            echo "2. Token may have expired or been revoked"
            echo "3. Repository may not exist or be accessible"
            exit 1
          fi

          echo "âœ… Homebrew Formula updated successfully!"
