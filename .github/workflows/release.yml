name: Release

on:
  push:
    branches:
      - master  # å½“åˆå¹¶åˆ° master åˆ†æ”¯æ—¶è§¦å‘
      # æ’é™¤ bump-version-* åˆ†æ”¯ï¼Œé¿å…è§¦å‘ release workflow
      - '!bump-version-*'
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘ï¼ˆä»…é master åˆ†æ”¯ï¼‰

# ç»Ÿä¸€ workflow run çš„æ˜¾ç¤ºåç§°
# ç­–ç•¥ï¼š
# - å¯¹äº push äº‹ä»¶ï¼ˆPR mergeï¼‰ï¼Œä¸è®¾ç½® run-nameï¼Œè®© GitHub è‡ªåŠ¨ä½¿ç”¨ PR æ ‡é¢˜
# - å¯¹äº workflow_dispatchï¼Œä½¿ç”¨è‡ªå®šä¹‰åç§°
run-name: ${{ github.event_name == 'workflow_dispatch' && format('Release - {0} (manual)', github.ref_name) || '' }}

# å¹¶å‘æ§åˆ¶ï¼šä»…å¯¹ master åˆ†æ”¯é™åˆ¶å¹¶å‘ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ª release
# - Master åˆ†æ”¯ï¼šæ‰€æœ‰ release å…±äº«åŒä¸€ä¸ª groupï¼Œç¡®ä¿æŒ‰é¡ºåºæ‰§è¡Œ
# - é Master åˆ†æ”¯ï¼šæ¯ä¸ªåˆ†æ”¯ä½¿ç”¨ä¸åŒçš„ groupï¼Œå…è®¸å¤šä¸ªå¹¶å‘
concurrency:
  group: release-workflow-${{ github.ref == 'refs/heads/master' && 'master' || github.ref_name }}
  cancel-in-progress: false  # ä¸å–æ¶ˆæ­£åœ¨è¿è¡Œçš„ï¼Œè®©æ–°çš„ç­‰å¾…

permissions:
  contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
  pull-requests: write  # å…è®¸åˆ›å»º PRï¼ˆç”¨äºç‰ˆæœ¬æ›´æ–°ï¼‰
  statuses: write  # å…è®¸åˆ›å»ºçŠ¶æ€æ£€æŸ¥ï¼ˆç”¨äºæ»¡è¶³åˆ†æ”¯ä¿æŠ¤è§„åˆ™ï¼‰

env:
  CARGO_TERM_COLOR: always

jobs:
  # æ„å»º dev å·¥å…·ï¼ˆä¾›åç»­ job ä½¿ç”¨ï¼‰
  build-dev-tool:
    name: ğŸ”¨ Build Dev Tool
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: ğŸ’¾ Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          enableCrossOsArchive: false

      - name: ğŸ“¦ Install system dependencies (Linux)
        if: runner.os == 'Linux'
        run: bash scripts/dev/dependencies/install-basic.sh

      - name: ğŸ’¾ Cache dev binary build artifacts
        uses: actions/cache@v4
        with:
          path: |
            target/release/dev
            target/release/deps/dev*
            target/release/.fingerprint/dev*
            target/release/incremental/dev-*
          key: ${{ runner.os }}-dev-bin-${{ hashFiles('src/lib/cli/dev.rs', 'src/bin/dev.rs', 'src/commands/dev/**/*.rs') }}-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-dev-bin-${{ hashFiles('src/lib/cli/dev.rs', 'src/bin/dev.rs', 'src/commands/dev/**/*.rs') }}-
            ${{ runner.os }}-dev-bin-
          enableCrossOsArchive: false

      - name: ğŸ”¨ Build dev binary
        run: cargo build --bin dev --release

      - name: ğŸ“¤ Upload dev binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: dev-binary
          path: |
            target/release/dev
            target/release/deps/dev*
          retention-days: 1
          if-no-files-found: error

  # ä»£ç è´¨é‡æ£€æŸ¥ï¼ˆLintï¼‰
  check-lint:
    name: ğŸ” Code Quality Check
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: ğŸ’¾ Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          # ä¼˜åŒ– Windows ä¸Šçš„ç¼“å­˜æ€§èƒ½ï¼šç¦ç”¨è·¨ OS å½’æ¡£å¯ä»¥é¿å… Windows è·¯å¾„é—®é¢˜
          enableCrossOsArchive: false

      - name: âœ¨ Check code formatting
        run: cargo fmt --check

      - name: ğŸ” Run Clippy linter
        run: cargo clippy -- -D warnings

      - name: âœ… Verify compilation
        run: cargo check
  #
  # è¿è¡Œæµ‹è¯•ï¼ˆè·¨å¹³å°å¹¶è¡Œæ‰§è¡Œï¼‰
  tests:
    name: ğŸ§ª Run Tests (${{ matrix.platform }})
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            platform: Linux-x86_64
            test_timeout: 25
          - os: macos-latest
            platform: macOS
            test_timeout: 35
          - os: windows-latest
            platform: Windows-x86_64
            test_timeout: 30
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: ğŸ’¾ Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          # ä¼˜åŒ– Windows ä¸Šçš„ç¼“å­˜æ€§èƒ½ï¼šç¦ç”¨è·¨ OS å½’æ¡£å¯ä»¥é¿å… Windows è·¯å¾„é—®é¢˜
          enableCrossOsArchive: false

      - name: ğŸ“¦ Install system dependencies (Linux)
        if: runner.os == 'Linux'
        run: bash scripts/dev/dependencies/install-basic.sh

      - name: ğŸ§ª Run tests
        timeout-minutes: ${{ matrix.test_timeout }}
        run: cargo test --verbose

  # æ€§èƒ½åŸºå‡†æµ‹è¯•
  check-performance:
    name: âš¡ Performance Benchmarks
    runs-on: ubuntu-latest
    needs: [check-status]
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: ğŸ’¾ Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          enableCrossOsArchive: false

      - name: ğŸ“¦ Install system dependencies (Linux)
        run: bash scripts/dev/dependencies/install-basic.sh

      - name: âš¡ Run performance benchmarks
        run: |
          cargo bench --bench cli_performance \
            --bench core_operations \
            --bench network_operations

      - name: ğŸ“¤ Upload performance reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: performance-benchmarks-${{ github.run_id }}
          path: target/criterion/
          retention-days: 30
          if-no-files-found: ignore

      - name: ğŸ“‹ Performance summary
        if: always()
        run: |
          if [ -d "target/criterion" ]; then
            echo "âš¡ Performance benchmarks completed"
            echo "Reports available in target/criterion/"
          else
            echo "âš ï¸  Performance benchmarks did not generate reports"
          fi

  #
  # ç¡®ä¿æ‰€æœ‰æ£€æŸ¥éƒ½é€šè¿‡ï¼ˆæ±‡æ€» jobï¼‰
  # è¿™ä¸ª job ä¾èµ–äº check-lint å’Œ testsï¼Œæ£€æŸ¥æ‰€æœ‰å¿…éœ€æ£€æŸ¥çš„çŠ¶æ€
  # å¦‚æœä»»ä½•æ£€æŸ¥å¤±è´¥ï¼Œæ­¤ job ä¼šå¤±è´¥ï¼Œä»è€Œé˜»æ­¢åç»­æ“ä½œ
  # æ³¨æ„ï¼šéœ€è¦åœ¨ GitHub ä»“åº“è®¾ç½®ä¸­é…ç½®åˆ†æ”¯ä¿æŠ¤è§„åˆ™ï¼Œå°†æ­¤å·¥ä½œæµè®¾ä¸ºå¿…éœ€çš„çŠ¶æ€æ£€æŸ¥
  check-status:
    name: âœ… Verify All Checks
    runs-on: ubuntu-latest
    needs: [check-lint, tests]
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: Check lint and test status
        run: |
          if [ "${{ needs.check-lint.result }}" != "success" ] || [ "${{ needs.tests.result }}" != "success" ]; then
            echo "âŒ Some checks failed:"
            echo "  Lint: ${{ needs.check-lint.result }}"
            echo "  Test: ${{ needs.tests.result }}"
            echo ""
            echo "Cannot proceed until all checks pass."
            exit 1
          fi
          echo "âœ… All checks passed!"

  # ç”Ÿæˆç‰ˆæœ¬å·å¹¶æ›´æ–° Cargo.toml å’Œ Cargo.lock
  update-version:
    name: ğŸ“¦ Generate Version
    runs-on: ubuntu-latest
    needs: [check-status, build-dev-tool]
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master') ||
      (github.ref == 'refs/heads/master' && github.event_name == 'push')
    permissions:
      contents: read  # åªéœ€è¦è¯»å–æƒé™
    outputs:
      version: ${{ steps.generate_version.outputs.version }}
      tag: ${{ steps.generate_version.outputs.tag }}
      needs_increment: ${{ steps.generate_version.outputs.needs_increment }}
      is_master_branch: ${{ steps.detect_mode.outputs.is_master_branch }}
      has_changes: ${{ steps.check_changes.outputs.has_changes }}

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # éœ€è¦å®Œæ•´å†å²è®°å½•æ¥æ£€æŸ¥ tag
          # ä½¿ç”¨é»˜è®¤çš„ GITHUB_TOKENï¼Œæœ‰ contents: write æƒé™ï¼Œå¯ä»¥æ¨é€ tag

      - name: ğŸ” Get latest version from git tags
        id: get_latest_version
        shell: bash
        run: |
          # ä» git tags è·å–æœ€æ–°çš„æ ‡å‡†ç‰ˆæœ¬å·ï¼ˆæ’é™¤ alpha/beta é¢„å‘å¸ƒç‰ˆæœ¬ï¼‰
          # è·å–æ‰€æœ‰æ ‡å‡†ç‰ˆæœ¬ tagï¼ˆæ ¼å¼ï¼švx.x.xï¼‰ï¼ŒæŒ‰ç‰ˆæœ¬å·æ’åº
          LATEST_TAG=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1)

          if [ -z "$LATEST_TAG" ]; then
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†ç‰ˆæœ¬ tagï¼Œä½¿ç”¨é»˜è®¤ç‰ˆæœ¬
            LATEST_VERSION="0.0.0"
            echo "âš ï¸  No standard version tag found, using default: $LATEST_VERSION"
          else
            # ç§»é™¤ v å‰ç¼€
            LATEST_VERSION=${LATEST_TAG#v}
            echo "âœ… Latest standard version from git tags: $LATEST_TAG ($LATEST_VERSION)"
          fi

          echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: ğŸ¯ Detect branch type and trigger mode
        id: detect_mode
        shell: bash
        run: |
          set -e
          # æ£€æµ‹æ˜¯å¦æ˜¯ master åˆ†æ”¯
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            IS_MASTER_BRANCH="true"
          else
            IS_MASTER_BRANCH="false"
          fi

          # æ£€æµ‹è§¦å‘ç±»å‹
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            IS_MANUAL_TRIGGER="true"
          else
            IS_MANUAL_TRIGGER="false"
          fi

          echo "is_master_branch=$IS_MASTER_BRANCH" >> $GITHUB_OUTPUT
          echo "is_manual_trigger=$IS_MANUAL_TRIGGER" >> $GITHUB_OUTPUT

          echo "âœ… Branch detection completed:"
          echo "   Branch: ${{ github.ref }}"
          echo "   Is Master: $IS_MASTER_BRANCH"
          echo "   Event: ${{ github.event_name }}"
          echo "   Is Manual: $IS_MANUAL_TRIGGER"

      - name: ğŸ“¥ Download dev binary artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-binary
          path: target/release/

      - name: ğŸ“¦ Generate version number
        id: generate_version
        run: |
          # ä½¿ç”¨å·²ä¸‹è½½çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œé¿å…é‡æ–°ç¼–è¯‘
          if [ -f "./target/release/dev" ]; then
            chmod +x ./target/release/dev
            ./target/release/dev version generate \
              --master ${{ steps.detect_mode.outputs.is_master_branch == 'true' }} \
              --ci
          else
            echo "âš ï¸  dev binary not found, falling back to cargo run"
            cargo run --bin dev --release -- version generate \
              --master ${{ steps.detect_mode.outputs.is_master_branch == 'true' }} \
              --ci
          fi

      - name: ğŸ“ Update Cargo.toml and Cargo.lock version
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true'
        shell: bash
        run: |
          NEW_VERSION="${{ steps.generate_version.outputs.version }}"

          # æ›´æ–° Cargo.toml ä¸­çš„ç‰ˆæœ¬å·
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          else
            sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          fi

          # éªŒè¯ Cargo.toml æ›´æ–°
          UPDATED_VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "âŒ Error: Failed to update version in Cargo.toml"
            exit 1
          fi

          # æ›´æ–° Cargo.lock ä¸­çš„ç‰ˆæœ¬å·
          if grep -q 'name = "workflow"' Cargo.lock; then
            if [[ "$OSTYPE" == "darwin"* ]]; then
              sed -i '' '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            else
              sed -i '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            fi
          fi

          echo "âœ… Version updated to $NEW_VERSION in Cargo.toml and Cargo.lock"

      - name: ğŸ” Check if version files have changes
        id: check_changes
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true'
        shell: bash
        run: |
          # æ£€æŸ¥ Cargo.toml å’Œ Cargo.lock æ˜¯å¦æœ‰å®é™…çš„æ›´æ”¹
          if git diff --quiet Cargo.toml Cargo.lock; then
            echo "âš ï¸  No changes detected in Cargo.toml and Cargo.lock"
            echo "   This usually means:"
            echo "   - Cargo.toml already has the target version"
            echo "   - Cargo.lock is already up to date"
            echo "   - No version increment is needed"
            echo ""
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Changes detected in version files"
            git diff Cargo.toml Cargo.lock
            echo ""
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“¤ Upload updated version files
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true' && steps.check_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: updated-version-files
          path: |
            Cargo.toml
            Cargo.lock
          retention-days: 1

  # æ„å»ºæ‰€æœ‰å¹³å°çš„äºŒè¿›åˆ¶æ–‡ä»¶
  build:
    name: ğŸ”¨ Build Binaries - ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    needs: [check-status, update-version, build-dev-tool]
    # æ‰‹åŠ¨è§¦å‘/ Master Push: éœ€è¦ä¾èµ–æˆåŠŸ
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master' && needs.check-status.result == 'success' && needs.update-version.result == 'success') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.check-status.result == 'success' && needs.update-version.result == 'success')
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: macOS-Intel
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: macOS-AppleSilicon
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            platform: Linux-x86_64
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            platform: Linux-ARM64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            platform: Linux-x86_64-static
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            platform: Windows-x86_64
          - os: windows-latest
            target: aarch64-pc-windows-msvc
            platform: Windows-ARM64

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¥ Download updated version files
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        uses: actions/download-artifact@v4
        with:
          name: updated-version-files
          path: .

      - name: ğŸ” Get version from update-version job
        id: version
        shell: bash
        run: |
          # ç»Ÿä¸€ä» update-version job çš„ outputs è·å–ç‰ˆæœ¬å·
          if [ -n "${{ needs.update-version.outputs.version }}" ]; then
            VERSION="${{ needs.update-version.outputs.version }}"
            TAG="${{ needs.update-version.outputs.tag }}"
            echo "âœ… Using version from update-version job: $VERSION ($TAG)"
          else
            echo "âŒ Error: Cannot determine version from update-version job"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: $TAG"

      - name: ğŸ”§ Setup Rust for ${{ matrix.target }}
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: ğŸ“¦ Install musl target
        if: contains(matrix.target, 'musl')
        run: |
          rustup target add ${{ matrix.target }}
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: ğŸ“¦ Install cross-compilation toolchain (Linux ARM64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu python3
          # æ³¨æ„ï¼šclipboard åŠŸèƒ½åœ¨ Linux ARM64 ä¸Šå·²ç¦ç”¨ï¼ˆCargo.toml ä¸­é…ç½®ï¼‰
          # å› æ­¤ä¸éœ€è¦å®‰è£… XCB å¼€å‘åº“ï¼Œç®€åŒ–æ„å»ºæµç¨‹
          # ä½†éœ€è¦å®‰è£… Python3 ç”¨äºå¤„ç† Cargo.lock è„šæœ¬

      - name: ğŸ“¦ Install system dependencies (Linux x86_64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'x86_64-unknown-linux-gnu'
        run: bash scripts/dev/dependencies/install-build.sh

      - name: ğŸ“¦ Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          # æ£€æŸ¥ pkg-config æ˜¯å¦å·²å®‰è£…ï¼Œé¿å…é‡å¤å®‰è£…è­¦å‘Š
          if ! command -v pkg-config >/dev/null 2>&1; then
            brew install pkg-config
          else
            echo "âœ… pkg-config is already installed"
          fi

      - name: ğŸ” Get Cargo.lock hash
        id: cargo_lock
        shell: bash
        run: |
          if [ -f "Cargo.lock" ]; then
            # macOS ä½¿ç”¨ shasumï¼ŒLinux ä½¿ç”¨ sha256sum
            if command -v shasum >/dev/null 2>&1; then
              HASH=$(shasum -a 256 Cargo.lock | cut -d' ' -f1 | head -c 16)
            else
              HASH=$(sha256sum Cargo.lock | cut -d' ' -f1 | head -c 16)
            fi
            echo "hash=$HASH" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ’¾ Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ steps.cargo_lock.outputs.hash }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          enableCrossOsArchive: false

      - name: ğŸ”¨ Build binaries
        shell: bash
        run: |
          # è®¾ç½®äº¤å‰ç¼–è¯‘ç¯å¢ƒå˜é‡ï¼ˆä»… Linux ARM64ï¼‰
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            echo "ğŸ”§ Cross-compiling for Linux ARM64"
            echo "   CC: $CC_aarch64_unknown_linux_gnu"
            echo "   LINKER: $CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER"
            # éªŒè¯äº¤å‰ç¼–è¯‘å·¥å…·é“¾
            if command -v aarch64-linux-gnu-gcc >/dev/null 2>&1; then
              echo "âœ… aarch64-linux-gnu-gcc found: $(which aarch64-linux-gnu-gcc)"
              aarch64-linux-gnu-gcc --version || true
            else
              echo "âŒ Error: aarch64-linux-gnu-gcc not found"
              exit 1
            fi
          fi

          # å¯¹äº Linux x86_64ï¼Œè®¾ç½®ç¯å¢ƒå˜é‡ä»¥æ”¯æŒ xcb æ„å»º
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            export XCB_PROTO_DIR="${XCB_PROTO_DIR:-/usr/share/xcb}"
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            # ç¡®ä¿ PYTHONPATH åŒ…å« xcbgen æ¨¡å—è·¯å¾„
            if ! python3 -c "import xcbgen" 2>/dev/null; then
              XCBGEN_DIR=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null || find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_DIR" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_DIR):${PYTHONPATH:-}"
              fi
            fi
            # åŸºæœ¬éªŒè¯
            python3 -c "import xcbgen" || (echo "âŒ Error: xcbgen module not available" && exit 1)
            pkg-config --exists xcb || (echo "âŒ Error: xcb pkg-config not found" && exit 1)
          fi
          # æ„å»ºé¡¹ç›®
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            # Linux x86_64 ä½¿ç”¨è¯¦ç»†è¾“å‡ºä»¥ä¾¿è°ƒè¯•
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install -vv 2>&1 | tee build.log; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
              echo "âŒ Build failed. Checking build log for xcb-related errors..."
              grep -i "xcb\|xproto\|xcbgen" build.log | head -20 || true
            fi
          elif [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            # Linux ARM64 äº¤å‰ç¼–è¯‘
            echo "ğŸ”¨ Building for Linux ARM64..."
            # ç¡®ä¿ç¯å¢ƒå˜é‡å·²è®¾ç½®
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
              echo "âŒ Build failed for Linux ARM64"
            fi
          else
            # å…¶ä»–ç›®æ ‡ï¼ˆmacOS, Windows, muslï¼‰
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
            fi
          fi

          # å¦‚æœæ„å»ºå¤±è´¥ï¼Œé€€å‡ºå¹¶è¿”å›é”™è¯¯ç 
          if [ "$BUILD_SUCCESS" != "true" ]; then
            echo "âŒ Build failed"
            exit 1
          fi

      - name: ğŸ“¦ Create package directory for binaries
        shell: bash
        run: |
          mkdir -p package
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cp target/${{ matrix.target }}/release/workflow.exe package/
            cp target/${{ matrix.target }}/release/install.exe package/
            echo "âœ… Copied workflow.exe and install.exe to package/"
          else
            cp target/${{ matrix.target }}/release/workflow package/
            cp target/${{ matrix.target }}/release/install package/
            echo "âœ… Copied workflow and install binaries to package/"
          fi

      - name: ğŸ“¦ Create archive (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $archiveName = "workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          $archivePath = Join-Path $PWD $archiveName
          # è¿›å…¥ package ç›®å½•
          Push-Location package
          try {
            # æ‰“åŒ… workflow.exe å’Œ install.exe ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
            Compress-Archive -Path "workflow.exe", "install.exe" -DestinationPath $archivePath -Force
            # æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
            $fileInfo = Get-Item $archivePath
            Write-Host "ğŸ“¦ Archive created: $archiveName"
            Write-Host "   Size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
            # éªŒè¯æ‰“åŒ…å†…å®¹
            Write-Host "ğŸ“¦ Archive contents:"
            $verifyPath = Join-Path $env:TEMP "workflow-verify"
            Expand-Archive -Path $archivePath -DestinationPath $verifyPath -Force
            Get-ChildItem $verifyPath | ForEach-Object { Write-Host "   $($_.Name)" }
            Remove-Item $verifyPath -Recurse -Force
          } finally {
            Pop-Location
          }

      - name: ğŸ“¦ Create archive (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          cd package
          ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          # æ‰“åŒ… workflow å’Œ install ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
          tar czf "../$ARCHIVE_NAME" workflow install
          cd ..
          ls -lh "$ARCHIVE_NAME"
          # éªŒè¯æ‰“åŒ…å†…å®¹
          echo "ğŸ“¦ Archive contents:"
          tar tzf "$ARCHIVE_NAME"

      - name: ğŸ“¥ Download dev binary artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-binary
          path: target/release/

      - name: ğŸ” Calculate SHA256 checksum for archive
        id: sha256
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
            # Windows: ä½¿ç”¨å·²ä¸‹è½½çš„äºŒè¿›åˆ¶æ–‡ä»¶æˆ– fallback åˆ° cargo run
            if [ -f "target/release/dev.exe" ]; then
              DEV_CMD="target/release/dev.exe"
            elif [ -f "target\\release\\dev.exe" ]; then
              DEV_CMD="target\\release\\dev.exe"
            else
              echo "âš ï¸  dev binary not found, falling back to cargo run"
              DEV_CMD="cargo run --bin dev --release --"
            fi
          else
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
            # Linux/macOS: ä½¿ç”¨å·²ä¸‹è½½çš„äºŒè¿›åˆ¶æ–‡ä»¶æˆ– fallback åˆ° cargo run
            if [ -f "./target/release/dev" ]; then
              chmod +x ./target/release/dev
              DEV_CMD="./target/release/dev"
            else
              echo "âš ï¸  dev binary not found, falling back to cargo run"
              DEV_CMD="cargo run --bin dev --release --"
            fi
          fi
          SHA256=$($DEV_CMD checksum calculate "$ARCHIVE_NAME")
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "$SHA256" > "sha256-${{ matrix.platform }}.txt"

      - name: ğŸ“¤ Upload build archive to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}
          path: |
            workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.${{ matrix.os == 'windows-latest' && 'zip' || 'tar.gz' }}
          retention-days: 30

      - name: ğŸ“¤ Upload SHA256 checksum file
        uses: actions/upload-artifact@v4
        with:
          name: sha256-${{ matrix.platform }}
          path: |
            sha256-${{ matrix.platform }}.txt
          retention-days: 30

  # ç”¨æˆ·ç¡®è®¤æ˜¯å¦ç»§ç»­å‘å¸ƒæµç¨‹
  release-confirm:
    name: â¸ï¸ Release Confirmation
    runs-on: ubuntu-latest
    needs: [update-version, build, check-performance]
    if: |
      needs.update-version.result == 'success' &&
      needs.build.result == 'success' &&
      needs.check-performance.result == 'success'
    environment: release-confirm
    permissions:
      contents: read
    steps:
      - name: â¸ï¸ Wait for approval
        run: |
          echo "âœ… Release confirmation approved"
          echo "   Version: ${{ needs.update-version.outputs.version }}"
          echo "   Tag: ${{ needs.update-version.outputs.tag }}"
          echo "   Build completed successfully"

  # åˆ›å»ºç‰ˆæœ¬æ›´æ–° PRã€åˆå¹¶ PR å¹¶åˆ›å»º tagï¼ˆåˆå¹¶åçš„ jobï¼‰
  create-tag:
    name: ğŸ·ï¸ Create Tag & Merge PR
    runs-on: ubuntu-latest
    needs: [update-version, build, release-confirm]
    if: |
      needs.update-version.result == 'success' &&
      needs.build.result == 'success' &&
      needs.release-confirm.result == 'success'
    permissions:
      contents: write
      pull-requests: write
    outputs:
      tag: ${{ steps.job_outputs.outputs.tag }}
      version: ${{ steps.job_outputs.outputs.version }}
      tag_created: ${{ steps.job_outputs.outputs.tag_created }}
      pr_number: ${{ steps.create_pr.outputs.pr_number }}
      pr_url: ${{ steps.create_pr.outputs.pr_url }}
      pr_merged: ${{ steps.handle_pr_merged.outputs.pr_merged || steps.merge_pr.outputs.pr_merged }}
      merge_commit_sha: ${{ steps.get_merge_sha_merged.outputs.merge_commit_sha || steps.get_merge_sha.outputs.merge_commit_sha }}
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # ä½¿ç”¨ PAT ä»¥æ”¯æŒæ¨é€æŒ‡å‘ä¿®æ”¹äº† workflow æ–‡ä»¶çš„ commit çš„ tag
          # å½“ tag æŒ‡å‘çš„ commit ä¿®æ”¹äº† workflow æ–‡ä»¶æ—¶ï¼ŒGITHUB_TOKEN æ— æ³•æ¨é€ï¼Œå¿…é¡»ä½¿ç”¨ PAT
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: ğŸ“¥ Download dev binary artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-binary
          path: target/release/

      - name: ğŸ”§ Install jq
        shell: bash
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          else
            echo "âœ… jq is already installed"
          fi
          jq --version

      - name: ğŸ“¥ Download updated version files
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        uses: actions/download-artifact@v4
        with:
          name: updated-version-files
          path: .

      # Step 1: Create version update PR (only if needs_increment is true and master branch)
      - name: âš™ï¸ Configure Git for PR creation
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: ğŸŒ¿ Create version update PR
        id: create_pr
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          # ä½¿ç”¨å·²ä¸‹è½½çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œé¿å…é‡æ–°ç¼–è¯‘
          if [ -f "./target/release/dev" ]; then
            chmod +x ./target/release/dev
            ./target/release/dev pr create \
              --version "${{ needs.update-version.outputs.version }}" \
              --base master \
              --ci
          else
            echo "âš ï¸  dev binary not found, falling back to cargo run"
            cargo run --bin dev --release -- pr create \
              --version "${{ needs.update-version.outputs.version }}" \
              --base master \
              --ci
          fi

      # Step 2: Merge version update PR (only if needs_increment is true and master branch and has changes)
      - name: â³ Wait for PR status update
        id: wait_pr_status
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        shell: bash
        run: |
          echo "â³ Waiting 30s for PR status to be updated and CI to complete..."
          sleep 30

      - name: ğŸ” Check PR mergeable status
        id: check_pr_status
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"

          if [ -z "$PR_NUMBER" ]; then
            echo "âŒ Error: PR_NUMBER is not set"
            exit 1
          fi

          # ä½¿ç”¨ GITHUB_TOKEN æ£€æŸ¥ PR çŠ¶æ€ï¼ˆé»˜è®¤ tokenï¼Œæœ‰ read æƒé™ï¼‰
          PR_STATUS=$(curl -s \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

          MERGED=$(echo "$PR_STATUS" | grep -o '"merged":[^,}]*' | cut -d':' -f2 | tr -d ' "')
          MERGEABLE=$(echo "$PR_STATUS" | grep -o '"mergeable":[^,}]*' | cut -d':' -f2 | tr -d ' "')

          echo "merged=$MERGED" >> $GITHUB_OUTPUT
          echo "mergeable=$MERGEABLE" >> $GITHUB_OUTPUT

      - name: âœ… Handle already merged PR
        id: handle_pr_merged
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          steps.check_pr_status.outputs.merged == 'true'
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          NEW_VERSION="${{ needs.update-version.outputs.version }}"

          echo "âœ… PR already merged"
          echo "pr_merged=true" >> $GITHUB_OUTPUT

          # åˆ é™¤è¿œç¨‹åˆ†æ”¯
          echo "Step 2.2: Deleting remote branch"
          BRANCH_NAME="bump-version-${NEW_VERSION}"
          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            git push origin --delete "$BRANCH_NAME" 2>/dev/null || echo "âš ï¸  Failed to delete remote branch (may already be deleted)"
          else
            echo "â„¹ï¸  Remote branch already deleted"
          fi

      - name: ğŸ” Get merge commit SHA (for already merged PR)
        id: get_merge_sha_merged
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          steps.handle_pr_merged.outputs.pr_merged == 'true'
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          echo "Getting merge commit SHA from PR API..."
          MERGE_SHA_MAX_WAIT=10
          MERGE_SHA_ELAPSED=0
          MERGE_SHA_INTERVAL=1
          MERGE_COMMIT_SHA=""

          while [ $MERGE_SHA_ELAPSED -lt $MERGE_SHA_MAX_WAIT ] && [ -z "$MERGE_COMMIT_SHA" ]; do
            sleep $MERGE_SHA_INTERVAL
            MERGE_SHA_ELAPSED=$((MERGE_SHA_ELAPSED + MERGE_SHA_INTERVAL))

            PR_INFO=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGE_COMMIT_SHA=$(echo "$PR_INFO" | jq -r '.merge_commit_sha // empty' 2>/dev/null)
            if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
              echo "âœ… Got merge commit SHA: $MERGE_COMMIT_SHA (after ${MERGE_SHA_ELAPSED}s)"
              echo "merge_commit_sha=$MERGE_COMMIT_SHA" >> $GITHUB_OUTPUT
              break
            fi
          done

          if [ -z "$MERGE_COMMIT_SHA" ] || [ "$MERGE_COMMIT_SHA" = "null" ]; then
            echo "âš ï¸  Warning: Could not get merge_commit_sha from PR API after ${MERGE_SHA_MAX_WAIT}s, will use git pull method"
            echo "merge_commit_sha=" >> $GITHUB_OUTPUT
          fi

      - name: â³ Wait for PR to be mergeable and merge
        id: wait_and_merge_pr
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          steps.check_pr_status.outputs.merged != 'true' &&
          (steps.check_pr_status.outputs.mergeable == 'null' || steps.check_pr_status.outputs.mergeable == 'false')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # ä½¿ç”¨å·²ä¸‹è½½çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œé¿å…é‡æ–°ç¼–è¯‘
          if [ -f "./target/release/dev" ]; then
            chmod +x ./target/release/dev
            ./target/release/dev pr merge \
              --pr-number "${{ steps.create_pr.outputs.pr_number }}" \
              --commit-title "chore: bump version to ${{ needs.update-version.outputs.version }}" \
              --commit-message "Automated version bump to ${{ needs.update-version.outputs.version }}\n\nMerged via GitHub Actions workflow" \
              --ci || true
          else
            echo "âš ï¸  dev binary not found, falling back to cargo run"
            cargo run --bin dev --release -- pr merge \
              --pr-number "${{ steps.create_pr.outputs.pr_number }}" \
              --commit-title "chore: bump version to ${{ needs.update-version.outputs.version }}" \
              --commit-message "Automated version bump to ${{ needs.update-version.outputs.version }}\n\nMerged via GitHub Actions workflow" \
              --ci || true
          fi

      - name: ğŸ”€ Merge version update PR
        id: merge_pr
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          steps.check_pr_status.outputs.merged != 'true' &&
          (steps.wait_and_merge_pr.outputs.pr_merged == 'true' || steps.check_pr_status.outputs.mergeable == 'true')
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          NEW_VERSION="${{ needs.update-version.outputs.version }}"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Step 2: Merging version update PR"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "â„¹ï¸  Using GITHUB_TOKEN to merge PR (workflow has pull-requests: write permission)"
          echo "ğŸ”€ Attempting to merge PR #$PR_NUMBER..."

          # å°è¯•åˆå¹¶ï¼ˆä½¿ç”¨ GITHUB_TOKENï¼Œworkflow æœ‰ pull-requests: write æƒé™ï¼‰
          MERGE_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/merge" \
            -d '{
              "commit_title": "chore: bump version to '"$NEW_VERSION"'",
              "commit_message": "Automated version bump to '"$NEW_VERSION"'\n\nMerged via GitHub Actions workflow",
              "merge_method": "squash"
            }')

          MERGE_CODE=$(echo "$MERGE_RESPONSE" | tail -n1)
          MERGE_BODY=$(echo "$MERGE_RESPONSE" | head -n-1)

          if [ "$MERGE_CODE" = "200" ]; then
            echo "âœ… PR merged successfully"
            echo "pr_merged=true" >> $GITHUB_OUTPUT
          elif [ "$MERGE_CODE" = "405" ]; then
            echo "âš ï¸  PR not ready to merge yet (HTTP 405), but continuing..."
            echo "pr_merged=false" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to merge PR (HTTP $MERGE_CODE)"
            echo "Response: $MERGE_BODY" | jq '.' 2>/dev/null || echo "$MERGE_BODY"
            exit 1
          fi

      - name: ğŸ” Get merge commit SHA (for merged PR)
        id: get_merge_sha
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          (steps.handle_pr_merged.outputs.pr_merged == 'true' || steps.merge_pr.outputs.pr_merged == 'true' || steps.wait_and_merge_pr.outputs.pr_merged == 'true')
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          echo "Getting merge commit SHA from PR API..."
          MERGE_SHA_MAX_WAIT=10
          MERGE_SHA_ELAPSED=0
          MERGE_SHA_INTERVAL=1
          MERGE_COMMIT_SHA=""

          while [ $MERGE_SHA_ELAPSED -lt $MERGE_SHA_MAX_WAIT ] && [ -z "$MERGE_COMMIT_SHA" ]; do
            sleep $MERGE_SHA_INTERVAL
            MERGE_SHA_ELAPSED=$((MERGE_SHA_ELAPSED + MERGE_SHA_INTERVAL))

            PR_INFO=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGE_COMMIT_SHA=$(echo "$PR_INFO" | jq -r '.merge_commit_sha // empty' 2>/dev/null)
            if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
              echo "âœ… Got merge commit SHA: $MERGE_COMMIT_SHA (after ${MERGE_SHA_ELAPSED}s)"
              echo "merge_commit_sha=$MERGE_COMMIT_SHA" >> $GITHUB_OUTPUT
              break
            fi
          done

          if [ -z "$MERGE_COMMIT_SHA" ] || [ "$MERGE_COMMIT_SHA" = "null" ]; then
            echo "âš ï¸  Warning: Could not get merge_commit_sha from PR API after ${MERGE_SHA_MAX_WAIT}s, will use git pull method"
            echo "merge_commit_sha=" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ—‘ï¸ Delete remote branch
        id: delete_branch
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          (steps.handle_pr_merged.outputs.pr_merged == 'true' || steps.merge_pr.outputs.pr_merged == 'true')
        shell: bash
        run: |
          NEW_VERSION="${{ needs.update-version.outputs.version }}"
          BRANCH_NAME="bump-version-${NEW_VERSION}"

          echo "Step 2.2: Deleting remote branch"
          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            git push origin --delete "$BRANCH_NAME" 2>/dev/null || echo "âš ï¸  Failed to delete remote branch (may already be deleted)"
          else
            echo "â„¹ï¸  Remote branch already deleted"
          fi

      # Step 3: Create and push tag
      - name: âš™ï¸ Configure Git for tag creation
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: ğŸ·ï¸ Create and push tag
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          TAG="${{ needs.update-version.outputs.tag }}"
          IS_MASTER="${{ needs.update-version.outputs.is_master_branch }}"
          NEEDS_INCREMENT="${{ needs.update-version.outputs.needs_increment }}"

          # Master åˆ†æ”¯ï¼šå¦‚æœ PR å·²åˆå¹¶ï¼Œä½¿ç”¨ merge_commit_sha
          if [ "$IS_MASTER" == "true" ] && [ "$NEEDS_INCREMENT" == "true" ]; then
            MERGE_COMMIT_SHA="${{ steps.get_merge_sha_merged.outputs.merge_commit_sha || steps.get_merge_sha.outputs.merge_commit_sha }}"
            if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
              # éªŒè¯è¯¥ commit æ˜¯å¦å­˜åœ¨
              if ! git cat-file -e "$MERGE_COMMIT_SHA" 2>/dev/null; then
                # å°è¯•è·å– commit
                git fetch origin "$MERGE_COMMIT_SHA" 2>/dev/null || \
                git fetch origin "+refs/heads/*:refs/remotes/origin/*" 2>/dev/null || true
              fi
              # ä½¿ç”¨å·²ä¸‹è½½çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œé¿å…é‡æ–°ç¼–è¯‘
              if [ -f "./target/release/dev" ]; then
                chmod +x ./target/release/dev
                ./target/release/dev tag create \
                  --tag "$TAG" \
                  --commit "$MERGE_COMMIT_SHA" \
                  --ci
              else
                echo "âš ï¸  dev binary not found, falling back to cargo run"
                cargo run --bin dev --release -- tag create \
                  --tag "$TAG" \
                  --commit "$MERGE_COMMIT_SHA" \
                  --ci
              fi
            else
              # å¦‚æœæ²¡æœ‰ merge_commit_shaï¼Œä½¿ç”¨å½“å‰ HEAD
              if [ -f "./target/release/dev" ]; then
                chmod +x ./target/release/dev
                ./target/release/dev tag create \
                  --tag "$TAG" \
                  --ci
              else
                echo "âš ï¸  dev binary not found, falling back to cargo run"
                cargo run --bin dev --release -- tag create \
                  --tag "$TAG" \
                  --ci
              fi
            fi
          else
            # é Master åˆ†æ”¯ï¼šä½¿ç”¨å½“å‰ HEAD
            if [ -f "./target/release/dev" ]; then
              chmod +x ./target/release/dev
              ./target/release/dev tag create \
                --tag "$TAG" \
                --ci
            else
              echo "âš ï¸  dev binary not found, falling back to cargo run"
              cargo run --bin dev --release -- tag create \
                --tag "$TAG" \
                --ci
            fi
          fi

      # Step 4: Set job outputs
      - name: ğŸ“Š Set job outputs for downstream jobs
        id: job_outputs
        shell: bash
        run: |
          VERSION="${{ needs.update-version.outputs.version }}"
          TAG="${{ needs.update-version.outputs.tag }}"
          IS_MASTER="${{ needs.update-version.outputs.is_master_branch }}"
          NEEDS_INCREMENT="${{ needs.update-version.outputs.needs_increment }}"

          # æ£€æŸ¥æ˜¯å¦åˆ›å»ºäº†æ–° tag
          if [ "$IS_MASTER" == "true" ]; then
            # Master åˆ†æ”¯ï¼šæ£€æŸ¥æ˜¯å¦åˆ›å»ºäº†æ–° tag
            if [ "$NEEDS_INCREMENT" == "true" ]; then
              # éœ€è¦é€’å¢ç‰ˆæœ¬å·ï¼Œä¼šåˆ›å»ºæ–° tag
              TAG_CREATED="true"
            else
              # æ£€æŸ¥ tag æ˜¯å¦å·²å­˜åœ¨
              if git rev-parse "$TAG" >/dev/null 2>&1; then
                TAG_CREATED="false"
              else
                TAG_CREATED="true"
              fi
            fi
          else
            # é Master åˆ†æ”¯ï¼šæ£€æŸ¥ tag æ˜¯å¦å·²å­˜åœ¨
            if git rev-parse "$TAG" >/dev/null 2>&1; then
              TAG_CREATED="false"
              echo "â„¹ï¸  Tag already exists: $TAG"
            else
              TAG_CREATED="true"
              echo "â„¹ï¸  Created new pre-release tag: $TAG"
            fi
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "tag_created=$TAG_CREATED" >> $GITHUB_OUTPUT
          echo "âœ… Job outputs set: version=$VERSION, tag=$TAG, tag_created=$TAG_CREATED"

  # åˆ›å»º GitHub Release
  release:
    name: ğŸš€ Create Release
    runs-on: ubuntu-latest
    needs: [update-version, create-tag, build, release-confirm]
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master' && needs.update-version.result == 'success' && needs.create-tag.result == 'success' && needs.build.result == 'success' && needs.release-confirm.result == 'success') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.update-version.result == 'success' && needs.create-tag.result == 'success' && needs.build.result == 'success' && needs.release-confirm.result == 'success' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ” Get version and tag from previous jobs
        id: version
        shell: bash
        run: |
          VERSION="${{ needs.update-version.outputs.version }}"
          # å¦‚æœ create-tag job æˆåŠŸè¿è¡Œï¼Œä½¿ç”¨å…¶ outputsï¼›å¦åˆ™ä½¿ç”¨ update-version çš„ outputs
          if [ "${{ needs.create-tag.result }}" == "success" ] && [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
            TAG="${{ needs.create-tag.outputs.tag }}"
            echo "âœ… Using tag from create-tag job: $TAG"
          else
            TAG="${{ needs.update-version.outputs.tag }}"
            echo "âœ… Using tag from update-version job: $TAG"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: $TAG"

      - name: ğŸ“¥ Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: ğŸ“ Prepare release info
        id: release_info
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IS_MASTER="${{ needs.update-version.outputs.is_master_branch }}"

          if [ "$IS_MASTER" == "true" ]; then
            RELEASE_NAME="Release $VERSION"
            RELEASE_BODY="## Release $VERSION

            See the [changelog](https://github.com/${{ github.repository }}/blob/master/CHANGELOG.md) for details."
          else
            RELEASE_NAME="Pre-release $VERSION"
            RELEASE_BODY="## Pre-release $VERSION

            âš ï¸ **This is a pre-release version** (alpha build)

            See the [changelog](https://github.com/${{ github.repository }}/blob/master/CHANGELOG.md) for details."
          fi

          # ä½¿ç”¨å¤šè¡Œè¾“å‡ºï¼ˆä½¿ç”¨ EOF åˆ†éš”ç¬¦ï¼‰
          {
            echo "name<<EOF"
            echo "$RELEASE_NAME"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          {
            echo "body<<EOF"
            echo "$RELEASE_BODY"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "âœ… Release name: $RELEASE_NAME"
          echo "âœ… Is pre-release: $([ "$IS_MASTER" != "true" ] && echo "true" || echo "false")"

      - name: ğŸš€ Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: ${{ steps.release_info.outputs.name }}
          body: ${{ steps.release_info.outputs.body }}
          files: |
            artifacts/**/*
          draft: false
          prerelease: ${{ needs.update-version.outputs.is_master_branch != 'true' }}

  # æ›´æ–° Homebrew Formula
  # æ³¨æ„ï¼šåªåœ¨ master åˆ†æ”¯çš„ push äº‹ä»¶æ—¶æ›´æ–°ï¼Œé master åˆ†æ”¯ä¸æ›´æ–°
  update-homebrew:
    name: ğŸº Update Homebrew Formula
    runs-on: ubuntu-latest
    needs: [update-version, create-tag, build, release]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.update-version.result == 'success' && needs.create-tag.result == 'success' && needs.build.result == 'success' && needs.release.result == 'success' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¥ Download dev binary artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-binary
          path: target/release/

      - name: ğŸ” Get version and tag from previous jobs
        id: version
        shell: bash
        run: |
          VERSION="${{ needs.update-version.outputs.version }}"
          # å¦‚æœ create-tag job æˆåŠŸè¿è¡Œï¼Œä½¿ç”¨å…¶ outputsï¼›å¦åˆ™ä½¿ç”¨ update-version çš„ outputs
          if [ "${{ needs.create-tag.result }}" == "success" ] && [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
            TAG="${{ needs.create-tag.outputs.tag }}"
            echo "âœ… Using tag from create-tag job: $TAG"
          else
            TAG="${{ needs.update-version.outputs.tag }}"
            echo "âœ… Using tag from update-version job: $TAG"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: $TAG"

      - name: ğŸ“¥ Checkout homebrew-workflow
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/homebrew-workflow
          token: ${{ secrets.WORKFLOW_PAT }}
          path: homebrew-workflow

      - name: ğŸ“ Generate Formula file and update
        working-directory: homebrew-workflow
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          # ä½¿ç”¨å·²ä¸‹è½½çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œé¿å…é‡æ–°ç¼–è¯‘
          if [ -f "./target/release/dev" ]; then
            chmod +x ./target/release/dev
            ./target/release/dev homebrew update \
              --version "${{ steps.version.outputs.version }}" \
              --tag "${{ steps.version.outputs.tag }}" \
              --formula-path Formula/workflow.rb \
              --template-path Formula/workflow.rb.template \
              --repo "${{ github.repository }}" \
              --commit \
              --push
          else
            echo "âš ï¸  dev binary not found, falling back to cargo run"
            cargo run --bin dev --release -- homebrew update \
              --version "${{ steps.version.outputs.version }}" \
              --tag "${{ steps.version.outputs.tag }}" \
              --formula-path Formula/workflow.rb \
              --template-path Formula/workflow.rb.template \
              --repo "${{ github.repository }}" \
              --commit \
              --push
          fi

  # æ¸…ç†å·²åˆå¹¶åˆ†æ”¯çš„ alpha tag
  # å½“ PR åˆå¹¶åˆ° master åï¼Œæ¸…ç†æŒ‡å‘å·²åˆå¹¶æäº¤çš„ alpha tag
  cleanup-alpha-tags:
    name: ğŸ§¹ Cleanup Alpha Tags
    runs-on: ubuntu-latest
    needs: [create-tag]
    # åªåœ¨ master åˆ†æ”¯çš„ push äº‹ä»¶æ—¶è¿è¡Œï¼Œä¸” create-tag job æˆåŠŸ
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/master' &&
      needs.create-tag.result == 'success' &&
      needs.create-tag.outputs.pr_merged == 'true'
    permissions:
      contents: write
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # ä½¿ç”¨ PAT ä»¥æ”¯æŒåˆ é™¤ tag
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: ğŸ“¥ Download dev binary artifact
        uses: actions/download-artifact@v4
        with:
          name: dev-binary
          path: target/release/

      - name: ğŸ§¹ Cleanup Alpha Tags
        id: cleanup
        run: |
          MERGE_COMMIT_SHA="${{ needs.create-tag.outputs.merge_commit_sha }}"

          if [ -z "$MERGE_COMMIT_SHA" ]; then
            echo "âš ï¸  No merge commit SHA found, skipping cleanup"
            exit 0
          fi

          CURRENT_VERSION="${{ needs.create-tag.outputs.version }}"
          # ä½¿ç”¨å·²ä¸‹è½½çš„äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œé¿å…é‡æ–°ç¼–è¯‘
          if [ -f "./target/release/dev" ]; then
            chmod +x ./target/release/dev
            ./target/release/dev tag cleanup \
              --merge-commit "$MERGE_COMMIT_SHA" \
              --version "$CURRENT_VERSION" \
              --ci
          else
            echo "âš ï¸  dev binary not found, falling back to cargo run"
            cargo run --bin dev --release -- tag cleanup \
              --merge-commit "$MERGE_COMMIT_SHA" \
              --version "$CURRENT_VERSION" \
              --ci
          fi

