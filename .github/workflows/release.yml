name: Release

on:
  push:
    branches:
      - master  # å½“åˆå¹¶åˆ° master åˆ†æ”¯æ—¶è§¦å‘
      # æ’é™¤ bump-version-* åˆ†æ”¯ï¼Œé¿å…è§¦å‘ release workflow
      - '!bump-version-*'
  workflow_dispatch:  # å…è®¸æ‰‹åŠ¨è§¦å‘ï¼ˆä»…é master åˆ†æ”¯ï¼‰

# ç»Ÿä¸€ workflow run çš„æ˜¾ç¤ºåç§°
# ç­–ç•¥ï¼š
# - å¯¹äº push äº‹ä»¶ï¼ˆPR mergeï¼‰ï¼Œä¸è®¾ç½® run-nameï¼Œè®© GitHub è‡ªåŠ¨ä½¿ç”¨ PR æ ‡é¢˜
# - å¯¹äº workflow_dispatchï¼Œä½¿ç”¨è‡ªå®šä¹‰åç§°
run-name: ${{ github.event_name == 'workflow_dispatch' && format('Release - {0} (manual)', github.ref_name) || '' }}

# å¹¶å‘æ§åˆ¶ï¼šä»…å¯¹ master åˆ†æ”¯é™åˆ¶å¹¶å‘ï¼Œç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ª release
# - Master åˆ†æ”¯ï¼šæ‰€æœ‰ release å…±äº«åŒä¸€ä¸ª groupï¼Œç¡®ä¿æŒ‰é¡ºåºæ‰§è¡Œ
# - é Master åˆ†æ”¯ï¼šæ¯ä¸ªåˆ†æ”¯ä½¿ç”¨ä¸åŒçš„ groupï¼Œå…è®¸å¤šä¸ªå¹¶å‘
concurrency:
  group: release-workflow-${{ github.ref == 'refs/heads/master' && 'master' || github.ref_name }}
  cancel-in-progress: false  # ä¸å–æ¶ˆæ­£åœ¨è¿è¡Œçš„ï¼Œè®©æ–°çš„ç­‰å¾…

permissions:
  contents: write  # å…è®¸åˆ›å»º Release å’Œä¸Šä¼ æ–‡ä»¶
  pull-requests: write  # å…è®¸åˆ›å»º PRï¼ˆç”¨äºç‰ˆæœ¬æ›´æ–°ï¼‰
  statuses: write  # å…è®¸åˆ›å»ºçŠ¶æ€æ£€æŸ¥ï¼ˆç”¨äºæ»¡è¶³åˆ†æ”¯ä¿æŠ¤è§„åˆ™ï¼‰

env:
  CARGO_TERM_COLOR: always

jobs:
  # ä»£ç è´¨é‡æ£€æŸ¥ï¼ˆLintï¼‰
  check-lint:
    name: ğŸ” Code Quality Check
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: ğŸ’¾ Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          # ä¼˜åŒ– Windows ä¸Šçš„ç¼“å­˜æ€§èƒ½ï¼šç¦ç”¨è·¨ OS å½’æ¡£å¯ä»¥é¿å… Windows è·¯å¾„é—®é¢˜
          enableCrossOsArchive: false

      - name: âœ¨ Check code formatting
        run: cargo fmt --check

      - name: ğŸ” Run Clippy linter
        run: cargo clippy -- -D warnings

      - name: âœ… Verify compilation
        run: cargo check
  #
  # è¿è¡Œæµ‹è¯•
  tests:
    name: ğŸ§ª Run Tests
    runs-on: ubuntu-latest
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: ğŸ’¾ Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          # ä¼˜åŒ– Windows ä¸Šçš„ç¼“å­˜æ€§èƒ½ï¼šç¦ç”¨è·¨ OS å½’æ¡£å¯ä»¥é¿å… Windows è·¯å¾„é—®é¢˜
          enableCrossOsArchive: false

      - name: ğŸ“¦ Install system dependencies (Linux)
        run: |
          sudo apt-get update
          # å®‰è£… XCB å¼€å‘åº“ï¼ˆclipboard ä¾èµ–ï¼‰
          # xcb crate éœ€è¦ xcb-proto æ¥ç”Ÿæˆä»£ç æ¨¡å—
          sudo apt-get install -y \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev

      - name: ğŸ§ª Run tests
        run: cargo test --verbose

  # æ€§èƒ½åŸºå‡†æµ‹è¯•
  check-performance:
    name: âš¡ Performance Benchmarks
    runs-on: ubuntu-latest
    needs: [check-status]
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: ğŸ’¾ Cache Cargo dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          enableCrossOsArchive: false

      - name: ğŸ“¦ Install system dependencies (Linux)
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            python3 \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev

      - name: âš¡ Run performance benchmarks
        run: |
          cargo bench --bench cli_performance \
            --bench core_operations \
            --bench network_operations

      - name: ğŸ“¤ Upload performance reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: performance-benchmarks-${{ github.run_id }}
          path: target/criterion/
          retention-days: 30
          if-no-files-found: ignore

      - name: ğŸ“‹ Performance summary
        if: always()
        run: |
          if [ -d "target/criterion" ]; then
            echo "âš¡ Performance benchmarks completed"
            echo "Reports available in target/criterion/"
          else
            echo "âš ï¸  Performance benchmarks did not generate reports"
          fi

  #
  # ç¡®ä¿æ‰€æœ‰æ£€æŸ¥éƒ½é€šè¿‡ï¼ˆæ±‡æ€» jobï¼‰
  # è¿™ä¸ª job ä¾èµ–äº check-lint å’Œ testsï¼Œæ£€æŸ¥æ‰€æœ‰å¿…éœ€æ£€æŸ¥çš„çŠ¶æ€
  # å¦‚æœä»»ä½•æ£€æŸ¥å¤±è´¥ï¼Œæ­¤ job ä¼šå¤±è´¥ï¼Œä»è€Œé˜»æ­¢åç»­æ“ä½œ
  # æ³¨æ„ï¼šéœ€è¦åœ¨ GitHub ä»“åº“è®¾ç½®ä¸­é…ç½®åˆ†æ”¯ä¿æŠ¤è§„åˆ™ï¼Œå°†æ­¤å·¥ä½œæµè®¾ä¸ºå¿…éœ€çš„çŠ¶æ€æ£€æŸ¥
  check-status:
    name: âœ… Verify All Checks
    runs-on: ubuntu-latest
    needs: [check-lint, tests]
    if: |
      (github.ref == 'refs/heads/master' && github.event_name == 'push') ||
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master')
    steps:
      - name: Check lint and test status
        run: |
          if [ "${{ needs.check-lint.result }}" != "success" ] || [ "${{ needs.tests.result }}" != "success" ]; then
            echo "âŒ Some checks failed:"
            echo "  Lint: ${{ needs.check-lint.result }}"
            echo "  Test: ${{ needs.tests.result }}"
            echo ""
            echo "Cannot proceed until all checks pass."
            exit 1
          fi
          echo "âœ… All checks passed!"

  # ç”Ÿæˆç‰ˆæœ¬å·å¹¶æ›´æ–° Cargo.toml å’Œ Cargo.lock
  update-version:
    name: ğŸ“¦ Generate Version
    runs-on: ubuntu-latest
    needs: [check-status]
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master') ||
      (github.ref == 'refs/heads/master' && github.event_name == 'push')
    permissions:
      contents: read  # åªéœ€è¦è¯»å–æƒé™
    outputs:
      version: ${{ steps.generate_version.outputs.version }}
      tag: ${{ steps.generate_version.outputs.tag }}
      needs_increment: ${{ steps.generate_version.outputs.needs_increment }}
      is_master_branch: ${{ steps.detect_mode.outputs.is_master_branch }}
      has_changes: ${{ steps.check_changes.outputs.has_changes }}

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # éœ€è¦å®Œæ•´å†å²è®°å½•æ¥æ£€æŸ¥ tag
          # ä½¿ç”¨é»˜è®¤çš„ GITHUB_TOKENï¼Œæœ‰ contents: write æƒé™ï¼Œå¯ä»¥æ¨é€ tag

      - name: ğŸ” Get latest version from git tags
        id: get_latest_version
        shell: bash
        run: |
          # ä» git tags è·å–æœ€æ–°çš„æ ‡å‡†ç‰ˆæœ¬å·ï¼ˆæ’é™¤ alpha/beta é¢„å‘å¸ƒç‰ˆæœ¬ï¼‰
          # è·å–æ‰€æœ‰æ ‡å‡†ç‰ˆæœ¬ tagï¼ˆæ ¼å¼ï¼švx.x.xï¼‰ï¼ŒæŒ‰ç‰ˆæœ¬å·æ’åº
          LATEST_TAG=$(git tag -l 'v[0-9]*.[0-9]*.[0-9]*' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1)

          if [ -z "$LATEST_TAG" ]; then
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†ç‰ˆæœ¬ tagï¼Œä½¿ç”¨é»˜è®¤ç‰ˆæœ¬
            LATEST_VERSION="0.0.0"
            echo "âš ï¸  No standard version tag found, using default: $LATEST_VERSION"
          else
            # ç§»é™¤ v å‰ç¼€
            LATEST_VERSION=${LATEST_TAG#v}
            echo "âœ… Latest standard version from git tags: $LATEST_TAG ($LATEST_VERSION)"
          fi

          echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: ğŸ¯ Detect branch type and trigger mode
        id: detect_mode
        shell: bash
        run: |
          set -e
          # æ£€æµ‹æ˜¯å¦æ˜¯ master åˆ†æ”¯
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            IS_MASTER_BRANCH="true"
          else
            IS_MASTER_BRANCH="false"
          fi

          # æ£€æµ‹è§¦å‘ç±»å‹
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            IS_MANUAL_TRIGGER="true"
          else
            IS_MANUAL_TRIGGER="false"
          fi

          echo "is_master_branch=$IS_MASTER_BRANCH" >> $GITHUB_OUTPUT
          echo "is_manual_trigger=$IS_MANUAL_TRIGGER" >> $GITHUB_OUTPUT

          echo "âœ… Branch detection completed:"
          echo "   Branch: ${{ github.ref }}"
          echo "   Is Master: $IS_MASTER_BRANCH"
          echo "   Event: ${{ github.event_name }}"
          echo "   Is Manual: $IS_MANUAL_TRIGGER"

      - name: ğŸ“¦ Generate version number
        id: generate_version
        shell: bash
        run: |
          set -e
          LATEST_VERSION="${{ steps.get_latest_version.outputs.latest_version }}"
          IS_MASTER="${{ steps.detect_mode.outputs.is_master_branch }}"

          # éªŒè¯ LATEST_VERSION ä¸ä¸ºç©º
          if [ -z "$LATEST_VERSION" ]; then
            echo "âŒ Error: LATEST_VERSION is empty"
            exit 1
          fi

          echo "ğŸ“‹ Version generation inputs:"
          echo "   LATEST_VERSION: $LATEST_VERSION"
          echo "   IS_MASTER: $IS_MASTER"

          if [[ "$IS_MASTER" == "true" ]]; then
            # Master åˆ†æ”¯ï¼šç”Ÿæˆæ ‡å‡†ç‰ˆæœ¬å·
            # è§£ææœ€æ–°ç‰ˆæœ¬å·
            IFS='.' read -ra VERSION_PARTS <<< "$LATEST_VERSION"
            MAJOR="${VERSION_PARTS[0]:-0}"
            MINOR="${VERSION_PARTS[1]:-0}"
            PATCH="${VERSION_PARTS[2]:-0}"

            # é¦–å…ˆæ£€æŸ¥å½“å‰ commit æ˜¯å¦å·²ç»æœ‰ä»»ä½•æ ‡å‡†ç‰ˆæœ¬ tag æŒ‡å‘å®ƒ
            CURRENT_COMMIT_SHA=$(git rev-parse HEAD)
            EXISTING_TAG_ON_COMMIT=$(git tag --points-at HEAD | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -1 || true)

            if [ -n "$EXISTING_TAG_ON_COMMIT" ]; then
              # å½“å‰ commit å·²ç»æœ‰ tagï¼Œä½¿ç”¨è¯¥ tag çš„ç‰ˆæœ¬å·
              VERSION=${EXISTING_TAG_ON_COMMIT#v}
              TAG="$EXISTING_TAG_ON_COMMIT"
              NEEDS_INCREMENT="false"
              echo "âœ… Found existing tag $TAG on current commit, reusing it"
            else
              # å½“å‰ commit æ²¡æœ‰ tagï¼Œéœ€è¦æ ¹æ® Conventional Commits è§„èŒƒç¡®å®šç‰ˆæœ¬æ›´æ–°ç±»å‹
              # è·å–ä»æœ€æ–° tag åˆ°å½“å‰ commit çš„æ‰€æœ‰ commit messages
              LATEST_TAG="${{ steps.get_latest_version.outputs.latest_tag }}"

              if [ -n "$LATEST_TAG" ] && git rev-parse "$LATEST_TAG" >/dev/null 2>&1; then
                # ä»æœ€æ–° tag åˆ°å½“å‰ commit çš„æ‰€æœ‰æäº¤
                COMMITS=$(git log ${LATEST_TAG}..HEAD --format="%s" --no-merges || echo "")
              else
                # å¦‚æœæ²¡æœ‰æ‰¾åˆ° tagï¼Œä½¿ç”¨æœ€è¿‘çš„æäº¤
                COMMITS=$(git log -10 --format="%s" --no-merges || echo "")
              fi

              # æ ¹æ® Conventional Commits è§„èŒƒç¡®å®šç‰ˆæœ¬æ›´æ–°ç±»å‹
              # ä¼˜å…ˆçº§ï¼šBREAKING CHANGE > patch >= 9 > feat: > å…¶ä»–
              VERSION_INCREMENT_TYPE="patch"  # é»˜è®¤æ˜¯ patch

              if echo "$COMMITS" | grep -qE "(BREAKING CHANGE|BREAKING:)" || echo "$COMMITS" | grep -qE "^[^:]*!:"; then
                # æ£€æµ‹åˆ° BREAKING CHANGE æˆ– ! æ ‡è®°ï¼Œé€’å¢ major ç‰ˆæœ¬ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
                VERSION_INCREMENT_TYPE="major"
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                echo "ğŸ”´ Detected BREAKING CHANGE, incrementing MAJOR version"
              elif [ "$PATCH" -ge 9 ]; then
                # è§„åˆ™ï¼šå¦‚æœ patch ç‰ˆæœ¬è¾¾åˆ° 9ï¼Œè‡ªåŠ¨é€’å¢ minor ç‰ˆæœ¬ï¼ˆå¦‚ v1.5.9 â†’ v1.6.0ï¼‰
                VERSION_INCREMENT_TYPE="minor"
                MINOR=$((MINOR + 1))
                PATCH=0
                echo "ğŸŸ¡ Patch version reached 9, incrementing MINOR version (v${MAJOR}.${MINOR}.${PATCH})"
              elif echo "$COMMITS" | grep -qE "^(feat|feature):"; then
                # æ£€æµ‹åˆ° feat: æˆ– feature:ï¼Œé€’å¢ minor ç‰ˆæœ¬
                VERSION_INCREMENT_TYPE="minor"
                MINOR=$((MINOR + 1))
                PATCH=0
                echo "ğŸŸ¢ Detected feat: commit, incrementing MINOR version"
              else
                # å…¶ä»–æƒ…å†µï¼ˆfixã€choreã€docs ç­‰ï¼‰ï¼Œé€’å¢ patch ç‰ˆæœ¬
                VERSION_INCREMENT_TYPE="patch"
                PATCH=$((PATCH + 1))
                echo "ğŸ”µ No feat: or BREAKING CHANGE detected, incrementing PATCH version"
              fi

              VERSION="$MAJOR.$MINOR.$PATCH"
              TAG="v$VERSION"
              NEEDS_INCREMENT="true"

              echo "âœ… Version increment type: $VERSION_INCREMENT_TYPE"
              echo "âœ… Generated version $VERSION ($TAG) based on Conventional Commits"
            fi

            echo "âœ… Master branch: Generated version $VERSION ($TAG)"
          else
            # é Master åˆ†æ”¯ï¼šç”Ÿæˆé¢„å‘å¸ƒç‰ˆæœ¬å· (vx.x.x.alpha-xxx)
            # åº”ç”¨ä¸ master åˆ†æ”¯ç›¸åŒçš„ç‰ˆæœ¬é€’å¢è§„åˆ™
            IFS='.' read -ra VERSION_PARTS <<< "$LATEST_VERSION"
            MAJOR="${VERSION_PARTS[0]:-0}"
            MINOR="${VERSION_PARTS[1]:-0}"
            PATCH="${VERSION_PARTS[2]:-0}"

            # è·å–ä»æœ€æ–° tag åˆ°å½“å‰ commit çš„æ‰€æœ‰ commit messages
            LATEST_TAG="${{ steps.get_latest_version.outputs.latest_tag }}"

            if [ -n "$LATEST_TAG" ] && git rev-parse "$LATEST_TAG" >/dev/null 2>&1; then
              # ä»æœ€æ–° tag åˆ°å½“å‰ commit çš„æ‰€æœ‰æäº¤
              COMMITS=$(git log ${LATEST_TAG}..HEAD --format="%s" --no-merges || echo "")
            else
              # å¦‚æœæ²¡æœ‰æ‰¾åˆ° tagï¼Œä½¿ç”¨æœ€è¿‘çš„æäº¤
              COMMITS=$(git log -10 --format="%s" --no-merges || echo "")
            fi

            # æ ¹æ® Conventional Commits è§„èŒƒç¡®å®šç‰ˆæœ¬æ›´æ–°ç±»å‹
            # ä¼˜å…ˆçº§ï¼šBREAKING CHANGE > patch >= 9 > feat: > å…¶ä»–
            VERSION_INCREMENT_TYPE="patch"  # é»˜è®¤æ˜¯ patch

            if echo "$COMMITS" | grep -qE "(BREAKING CHANGE|BREAKING:)" || echo "$COMMITS" | grep -qE "^[^:]*!:"; then
              # æ£€æµ‹åˆ° BREAKING CHANGE æˆ– ! æ ‡è®°ï¼Œé€’å¢ major ç‰ˆæœ¬ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
              VERSION_INCREMENT_TYPE="major"
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              echo "ğŸ”´ Detected BREAKING CHANGE, incrementing MAJOR version"
            elif [ "$PATCH" -ge 9 ]; then
              # è§„åˆ™ï¼šå¦‚æœ patch ç‰ˆæœ¬è¾¾åˆ° 9ï¼Œè‡ªåŠ¨é€’å¢ minor ç‰ˆæœ¬ï¼ˆå¦‚ v1.5.9 â†’ v1.6.0ï¼‰
              VERSION_INCREMENT_TYPE="minor"
              MINOR=$((MINOR + 1))
              PATCH=0
              echo "ğŸŸ¡ Patch version reached 9, incrementing MINOR version (v${MAJOR}.${MINOR}.${PATCH})"
            elif echo "$COMMITS" | grep -qE "^(feat|feature):"; then
              # æ£€æµ‹åˆ° feat: æˆ– feature:ï¼Œé€’å¢ minor ç‰ˆæœ¬
              VERSION_INCREMENT_TYPE="minor"
              MINOR=$((MINOR + 1))
              PATCH=0
              echo "ğŸŸ¢ Detected feat: commit, incrementing MINOR version"
            else
              # å…¶ä»–æƒ…å†µï¼ˆfixã€choreã€docs ç­‰ï¼‰ï¼Œé€’å¢ patch ç‰ˆæœ¬
              VERSION_INCREMENT_TYPE="patch"
              PATCH=$((PATCH + 1))
              echo "ğŸ”µ No feat: or BREAKING CHANGE detected, incrementing PATCH version"
            fi

            BASE_VERSION="$MAJOR.$MINOR.$PATCH"

            # ä½¿ç”¨æ—¶é—´æˆ³æ ¼å¼ç¡®ä¿å”¯ä¸€æ€§ï¼šYYYYMMDDHHmmssSSS
            # æ ¼å¼ï¼švx.x.x.alpha-YYYYMMDDHHmmssSSS
            # ç¤ºä¾‹ï¼šv1.6.1.alpha-20251216101712000
            # æ³¨æ„ï¼šæ­¤ job è¿è¡Œåœ¨ ubuntu-latest ä¸Šï¼Œdate æ”¯æŒ %3Nï¼ˆæ¯«ç§’ï¼‰
            TIMESTAMP=$(date +%Y%m%d%H%M%S%3N)

            VERSION="${BASE_VERSION}.alpha-${TIMESTAMP}"
            TAG="v$VERSION"
            NEEDS_INCREMENT="false"

            echo "âœ… Non-master branch: Generated pre-release version $VERSION ($TAG)"
            echo "   Timestamp format: YYYYMMDDHHmmssSSS"
            echo "   Example: v1.6.1.alpha-20251216101712000"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "needs_increment=$NEEDS_INCREMENT" >> $GITHUB_OUTPUT

      - name: ğŸ”§ Setup Rust toolchain
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true'
        uses: dtolnay/rust-toolchain@stable

      - name: ğŸ“ Update Cargo.toml and Cargo.lock version
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true'
        shell: bash
        run: |
          NEW_VERSION="${{ steps.generate_version.outputs.version }}"

          # æ›´æ–° Cargo.toml ä¸­çš„ç‰ˆæœ¬å·
          if [[ "$OSTYPE" == "darwin"* ]]; then
            sed -i '' "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          else
            sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" Cargo.toml
          fi

          # éªŒè¯ Cargo.toml æ›´æ–°
          UPDATED_VERSION=$(grep -E '^version\s*=' Cargo.toml | head -1 | sed -E 's/^version\s*=\s*"([^"]+)".*/\1/')
          if [ "$UPDATED_VERSION" != "$NEW_VERSION" ]; then
            echo "âŒ Error: Failed to update version in Cargo.toml"
            exit 1
          fi

          # æ›´æ–° Cargo.lock ä¸­çš„ç‰ˆæœ¬å·
          if grep -q 'name = "workflow"' Cargo.lock; then
            if [[ "$OSTYPE" == "darwin"* ]]; then
              sed -i '' '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            else
              sed -i '/^name = "workflow"$/,/^version = /{
                /^version = /s/version = "[^"]*"/version = "'"$NEW_VERSION"'"/
              }' Cargo.lock
            fi
          fi

          echo "âœ… Version updated to $NEW_VERSION in Cargo.toml and Cargo.lock"

      - name: ğŸ” Check if version files have changes
        id: check_changes
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true'
        shell: bash
        run: |
          # æ£€æŸ¥ Cargo.toml å’Œ Cargo.lock æ˜¯å¦æœ‰å®é™…çš„æ›´æ”¹
          if git diff --quiet Cargo.toml Cargo.lock; then
            echo "âš ï¸  No changes detected in Cargo.toml and Cargo.lock"
            echo "   This usually means:"
            echo "   - Cargo.toml already has the target version"
            echo "   - Cargo.lock is already up to date"
            echo "   - No version increment is needed"
            echo ""
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "âœ… Changes detected in version files"
            git diff Cargo.toml Cargo.lock
            echo ""
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“¤ Upload updated version files
        if: steps.generate_version.outputs.needs_increment == 'true' && steps.detect_mode.outputs.is_master_branch == 'true' && steps.check_changes.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: updated-version-files
          path: |
            Cargo.toml
            Cargo.lock
          retention-days: 1

  # æ„å»ºæ‰€æœ‰å¹³å°çš„äºŒè¿›åˆ¶æ–‡ä»¶
  build:
    name: ğŸ”¨ Build Binaries - ${{ matrix.platform }}
    runs-on: ${{ matrix.os }}
    needs: [check-status, update-version]
    # æ‰‹åŠ¨è§¦å‘/ Master Push: éœ€è¦ä¾èµ–æˆåŠŸ
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master' && needs.check-status.result == 'success' && needs.update-version.result == 'success') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.check-status.result == 'success' && needs.update-version.result == 'success')
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-latest
            target: x86_64-apple-darwin
            platform: macOS-Intel
          - os: macos-latest
            target: aarch64-apple-darwin
            platform: macOS-AppleSilicon
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            platform: Linux-x86_64
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            platform: Linux-ARM64
          - os: ubuntu-latest
            target: x86_64-unknown-linux-musl
            platform: Linux-x86_64-static
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            platform: Windows-x86_64
          - os: windows-latest
            target: aarch64-pc-windows-msvc
            platform: Windows-ARM64

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ“¥ Download updated version files
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        uses: actions/download-artifact@v4
        with:
          name: updated-version-files
          path: .

      - name: ğŸ” Get version from update-version job
        id: version
        shell: bash
        run: |
          # ç»Ÿä¸€ä» update-version job çš„ outputs è·å–ç‰ˆæœ¬å·
          if [ -n "${{ needs.update-version.outputs.version }}" ]; then
            VERSION="${{ needs.update-version.outputs.version }}"
            TAG="${{ needs.update-version.outputs.tag }}"
            echo "âœ… Using version from update-version job: $VERSION ($TAG)"
          else
            echo "âŒ Error: Cannot determine version from update-version job"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: $TAG"

      - name: ğŸ”§ Setup Rust for ${{ matrix.target }}
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: ğŸ“¦ Install musl target
        if: contains(matrix.target, 'musl')
        run: |
          rustup target add ${{ matrix.target }}
          sudo apt-get update
          sudo apt-get install -y musl-tools

      - name: ğŸ“¦ Install cross-compilation toolchain (Linux ARM64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'aarch64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu python3
          # æ³¨æ„ï¼šclipboard åŠŸèƒ½åœ¨ Linux ARM64 ä¸Šå·²ç¦ç”¨ï¼ˆCargo.toml ä¸­é…ç½®ï¼‰
          # å› æ­¤ä¸éœ€è¦å®‰è£… XCB å¼€å‘åº“ï¼Œç®€åŒ–æ„å»ºæµç¨‹
          # ä½†éœ€è¦å®‰è£… Python3 ç”¨äºå¤„ç† Cargo.lock è„šæœ¬

      - name: ğŸ“¦ Install system dependencies (Linux x86_64)
        if: matrix.os == 'ubuntu-latest' && matrix.target == 'x86_64-unknown-linux-gnu'
        run: |
          sudo apt-get update
          # å®‰è£… XCB å¼€å‘åº“ï¼ˆclipboard ä¾èµ–ï¼‰
          # xcb crate éœ€è¦ xcb-proto æ¥ç”Ÿæˆä»£ç æ¨¡å—ï¼ˆxproto, big_requests, etc.ï¼‰
          # xcb-proto éœ€è¦ Python æ¥è¿è¡Œä»£ç ç”Ÿæˆè„šæœ¬
          sudo apt-get install -y \
            python3 \
            python3-pip \
            python3-xcbgen \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev \
            pkg-config
          # åŸºæœ¬éªŒè¯ï¼šæ£€æŸ¥å…³é”®ä¾èµ–æ˜¯å¦å¯ç”¨
          python3 -c "import xcbgen" || (echo "âŒ Error: xcbgen module not available" && exit 1)
          pkg-config --exists xcb || (echo "âŒ Error: xcb pkg-config not found" && exit 1)
          echo "âœ… xcb dependencies verified"

      - name: ğŸ“¦ Install system dependencies (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          # æ£€æŸ¥ pkg-config æ˜¯å¦å·²å®‰è£…ï¼Œé¿å…é‡å¤å®‰è£…è­¦å‘Š
          if ! command -v pkg-config >/dev/null 2>&1; then
            brew install pkg-config
          else
            echo "âœ… pkg-config is already installed"
          fi

      - name: ğŸ” Get Cargo.lock hash
        id: cargo_lock
        shell: bash
        run: |
          if [ -f "Cargo.lock" ]; then
            # macOS ä½¿ç”¨ shasumï¼ŒLinux ä½¿ç”¨ sha256sum
            if command -v shasum >/dev/null 2>&1; then
              HASH=$(shasum -a 256 Cargo.lock | cut -d' ' -f1 | head -c 16)
            else
              HASH=$(sha256sum Cargo.lock | cut -d' ' -f1 | head -c 16)
            fi
            echo "hash=$HASH" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ’¾ Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-${{ steps.cargo_lock.outputs.hash }}
          restore-keys: |
            ${{ runner.os }}-cargo-
          enableCrossOsArchive: false

      - name: ğŸ”¨ Build binaries
        shell: bash
        run: |
          # è®¾ç½®äº¤å‰ç¼–è¯‘ç¯å¢ƒå˜é‡ï¼ˆä»… Linux ARM64ï¼‰
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            echo "ğŸ”§ Cross-compiling for Linux ARM64"
            echo "   CC: $CC_aarch64_unknown_linux_gnu"
            echo "   LINKER: $CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER"
            # éªŒè¯äº¤å‰ç¼–è¯‘å·¥å…·é“¾
            if command -v aarch64-linux-gnu-gcc >/dev/null 2>&1; then
              echo "âœ… aarch64-linux-gnu-gcc found: $(which aarch64-linux-gnu-gcc)"
              aarch64-linux-gnu-gcc --version || true
            else
              echo "âŒ Error: aarch64-linux-gnu-gcc not found"
              exit 1
            fi
          fi

          # å¯¹äº Linux x86_64ï¼Œè®¾ç½®ç¯å¢ƒå˜é‡ä»¥æ”¯æŒ xcb æ„å»º
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            export XCB_PROTO_DIR="${XCB_PROTO_DIR:-/usr/share/xcb}"
            export PKG_CONFIG_PATH="/usr/lib/x86_64-linux-gnu/pkgconfig:/usr/lib/pkgconfig:${PKG_CONFIG_PATH:-}"
            # ç¡®ä¿ PYTHONPATH åŒ…å« xcbgen æ¨¡å—è·¯å¾„
            if ! python3 -c "import xcbgen" 2>/dev/null; then
              XCBGEN_DIR=$(python3 -c "import xcbgen; import os; print(os.path.dirname(xcbgen.__file__))" 2>/dev/null || find /usr -name "xcbgen" -type d 2>/dev/null | head -1)
              if [ -n "$XCBGEN_DIR" ]; then
                export PYTHONPATH="$(dirname $XCBGEN_DIR):${PYTHONPATH:-}"
              fi
            fi
            # åŸºæœ¬éªŒè¯
            python3 -c "import xcbgen" || (echo "âŒ Error: xcbgen module not available" && exit 1)
            pkg-config --exists xcb || (echo "âŒ Error: xcb pkg-config not found" && exit 1)
          fi
          # æ„å»ºé¡¹ç›®
          if [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            # Linux x86_64 ä½¿ç”¨è¯¦ç»†è¾“å‡ºä»¥ä¾¿è°ƒè¯•
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install -vv 2>&1 | tee build.log; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
              echo "âŒ Build failed. Checking build log for xcb-related errors..."
              grep -i "xcb\|xproto\|xcbgen" build.log | head -20 || true
            fi
          elif [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            # Linux ARM64 äº¤å‰ç¼–è¯‘
            echo "ğŸ”¨ Building for Linux ARM64..."
            # ç¡®ä¿ç¯å¢ƒå˜é‡å·²è®¾ç½®
            export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
              echo "âŒ Build failed for Linux ARM64"
            fi
          else
            # å…¶ä»–ç›®æ ‡ï¼ˆmacOS, Windows, muslï¼‰
            if cargo build --release --target ${{ matrix.target }} --bin workflow --bin install; then
              BUILD_SUCCESS=true
            else
              BUILD_SUCCESS=false
            fi
          fi

          # å¦‚æœæ„å»ºå¤±è´¥ï¼Œé€€å‡ºå¹¶è¿”å›é”™è¯¯ç 
          if [ "$BUILD_SUCCESS" != "true" ]; then
            echo "âŒ Build failed"
            exit 1
          fi

      - name: ğŸ“¦ Create package directory for binaries
        shell: bash
        run: |
          mkdir -p package
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            cp target/${{ matrix.target }}/release/workflow.exe package/
            cp target/${{ matrix.target }}/release/install.exe package/
            echo "âœ… Copied workflow.exe and install.exe to package/"
          else
            cp target/${{ matrix.target }}/release/workflow package/
            cp target/${{ matrix.target }}/release/install package/
            echo "âœ… Copied workflow and install binaries to package/"
          fi

      - name: ğŸ“¦ Create archive (Windows)
        if: matrix.os == 'windows-latest'
        shell: pwsh
        run: |
          $archiveName = "workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          $archivePath = Join-Path $PWD $archiveName
          # è¿›å…¥ package ç›®å½•
          Push-Location package
          try {
            # æ‰“åŒ… workflow.exe å’Œ install.exe ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
            Compress-Archive -Path "workflow.exe", "install.exe" -DestinationPath $archivePath -Force
            # æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
            $fileInfo = Get-Item $archivePath
            Write-Host "ğŸ“¦ Archive created: $archiveName"
            Write-Host "   Size: $([math]::Round($fileInfo.Length / 1MB, 2)) MB"
            # éªŒè¯æ‰“åŒ…å†…å®¹
            Write-Host "ğŸ“¦ Archive contents:"
            $verifyPath = Join-Path $env:TEMP "workflow-verify"
            Expand-Archive -Path $archivePath -DestinationPath $verifyPath -Force
            Get-ChildItem $verifyPath | ForEach-Object { Write-Host "   $($_.Name)" }
            Remove-Item $verifyPath -Recurse -Force
          } finally {
            Pop-Location
          }

      - name: ğŸ“¦ Create archive (Unix)
        if: matrix.os != 'windows-latest'
        shell: bash
        run: |
          cd package
          ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          # æ‰“åŒ… workflow å’Œ install ä¸¤ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶
          tar czf "../$ARCHIVE_NAME" workflow install
          cd ..
          ls -lh "$ARCHIVE_NAME"
          # éªŒè¯æ‰“åŒ…å†…å®¹
          echo "ğŸ“¦ Archive contents:"
          tar tzf "$ARCHIVE_NAME"

      - name: ğŸ” Calculate SHA256 checksum for archive
        id: sha256
        shell: bash
        run: |
          if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.zip"
          else
            ARCHIVE_NAME="workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.tar.gz"
          fi
          if command -v shasum >/dev/null 2>&1; then
            SHA256=$(shasum -a 256 "$ARCHIVE_NAME" | cut -d' ' -f1)
          else
            SHA256=$(sha256sum "$ARCHIVE_NAME" | cut -d' ' -f1)
          fi
          echo "sha256=$SHA256" >> $GITHUB_OUTPUT
          echo "$SHA256" > "sha256-${{ matrix.platform }}.txt"

      - name: ğŸ“¤ Upload build archive to artifacts
        uses: actions/upload-artifact@v4
        with:
          name: workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}
          path: |
            workflow-${{ steps.version.outputs.version }}-${{ matrix.platform }}.${{ matrix.os == 'windows-latest' && 'zip' || 'tar.gz' }}
          retention-days: 30

      - name: ğŸ“¤ Upload SHA256 checksum file
        uses: actions/upload-artifact@v4
        with:
          name: sha256-${{ matrix.platform }}
          path: |
            sha256-${{ matrix.platform }}.txt
          retention-days: 30

  # ç”¨æˆ·ç¡®è®¤æ˜¯å¦ç»§ç»­å‘å¸ƒæµç¨‹
  release-confirm:
    name: â¸ï¸ Release Confirmation
    runs-on: ubuntu-latest
    needs: [update-version, build, check-performance]
    if: |
      needs.update-version.result == 'success' &&
      needs.build.result == 'success' &&
      needs.check-performance.result == 'success'
    environment: release-confirm
    permissions:
      contents: read
    steps:
      - name: â¸ï¸ Wait for approval
        run: |
          echo "âœ… Release confirmation approved"
          echo "   Version: ${{ needs.update-version.outputs.version }}"
          echo "   Tag: ${{ needs.update-version.outputs.tag }}"
          echo "   Build completed successfully"

  # åˆ›å»ºç‰ˆæœ¬æ›´æ–° PRã€åˆå¹¶ PR å¹¶åˆ›å»º tagï¼ˆåˆå¹¶åçš„ jobï¼‰
  create-tag:
    name: ğŸ·ï¸ Create Tag & Merge PR
    runs-on: ubuntu-latest
    needs: [update-version, build, release-confirm]
    if: |
      needs.update-version.result == 'success' &&
      needs.build.result == 'success' &&
      needs.release-confirm.result == 'success'
    permissions:
      contents: write
      pull-requests: write
    outputs:
      tag: ${{ steps.job_outputs.outputs.tag }}
      version: ${{ steps.job_outputs.outputs.version }}
      tag_created: ${{ steps.job_outputs.outputs.tag_created }}
      pr_number: ${{ steps.create_pr.outputs.pr_number }}
      pr_url: ${{ steps.create_pr.outputs.pr_url }}
      pr_merged: ${{ steps.handle_pr_merged.outputs.pr_merged || steps.merge_pr.outputs.pr_merged }}
      merge_commit_sha: ${{ steps.get_merge_sha_merged.outputs.merge_commit_sha || steps.get_merge_sha.outputs.merge_commit_sha }}
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # ä½¿ç”¨ PAT ä»¥æ”¯æŒæ¨é€æŒ‡å‘ä¿®æ”¹äº† workflow æ–‡ä»¶çš„ commit çš„ tag
          # å½“ tag æŒ‡å‘çš„ commit ä¿®æ”¹äº† workflow æ–‡ä»¶æ—¶ï¼ŒGITHUB_TOKEN æ— æ³•æ¨é€ï¼Œå¿…é¡»ä½¿ç”¨ PAT
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: ğŸ”§ Install jq
        shell: bash
        run: |
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update
            sudo apt-get install -y jq
          else
            echo "âœ… jq is already installed"
          fi
          jq --version

      - name: ğŸ“¥ Download updated version files
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        uses: actions/download-artifact@v4
        with:
          name: updated-version-files
          path: .

      # Step 1: Create version update PR (only if needs_increment is true and master branch)
      - name: âš™ï¸ Configure Git for PR creation
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: ğŸŒ¿ Create version update PR
        id: create_pr
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        shell: bash
        env:
          WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
        run: |

          NEW_VERSION="${{ needs.update-version.outputs.version }}"
          BRANCH_NAME="bump-version-${NEW_VERSION}"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Step 1: Creating version update PR"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          # ç¬¬ä¸€æ­¥ï¼šåˆ›å»ºæ–°åˆ†æ”¯
          echo "Step 1.1: Creating branch $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"

          # ç¬¬äºŒæ­¥ï¼šæ·»åŠ æ–‡ä»¶
          echo "Step 1.2: Staging Cargo.toml and Cargo.lock"
          git add Cargo.toml Cargo.lock

          # ç¬¬ä¸‰æ­¥ï¼šæäº¤æ›´æ”¹
          echo "Step 1.3: Committing changes"
          git commit -m "chore: bump version to ${NEW_VERSION}"

          # ç¬¬å››æ­¥ï¼šæ¨é€åˆ°æ–°åˆ†æ”¯
          echo "Step 1.4: Pushing branch to origin"
          git push origin "$BRANCH_NAME"

          # ç¬¬äº”æ­¥ï¼šåˆ›å»º Pull Requestï¼ˆä½¿ç”¨ WORKFLOW_PAT ä»¥è§¦å‘ CIï¼‰
          echo "Step 1.5: Creating Pull Request"
          echo "Branch: $BRANCH_NAME"
          echo "Version: $NEW_VERSION"

          PR_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $WORKFLOW_PAT" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls" \
            -d '{
              "title": "chore: bump version to '"$NEW_VERSION"'",
              "head": "'"$BRANCH_NAME"'",
              "base": "master",
              "body": "Automated version bump to '"$NEW_VERSION"'\n\nThis PR was created automatically by the release workflow.\n\n**Changes:**\n- Updated version in Cargo.toml to '"$NEW_VERSION"'\n- Updated version in Cargo.lock to '"$NEW_VERSION"'\n\n**Workflow Run:** https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }')

          HTTP_CODE=$(echo "$PR_RESPONSE" | tail -n1)
          PR_BODY=$(echo "$PR_RESPONSE" | head -n-1)

          echo "HTTP Status Code: $HTTP_CODE"

          if [ "$HTTP_CODE" != "201" ]; then
            echo "âš ï¸  Failed to create PR (HTTP $HTTP_CODE)"
            echo "Response body:"
            echo "$PR_BODY" | jq '.' 2>/dev/null || echo "$PR_BODY"

            # å¦‚æœæ˜¯ 422 é”™è¯¯ï¼ˆå·²å­˜åœ¨ PRï¼‰ï¼Œå°è¯•æŸ¥æ‰¾ç°æœ‰çš„ PR
            if [ "$HTTP_CODE" = "422" ]; then
              echo "Checking for existing PR..."
              EXISTING_PR=$(curl -s \
                -H "Accept: application/vnd.github+json" \
                -H "Authorization: Bearer $WORKFLOW_PAT" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.repository_owner }}:$BRANCH_NAME&base=master&state=open")

              PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.[0].number // empty' 2>/dev/null)
              if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
                PR_URL=$(echo "$EXISTING_PR" | jq -r '.[0].html_url // empty' 2>/dev/null)
                echo "âœ… Found existing PR #$PR_NUMBER: $PR_URL"
                echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
                echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
              else
                exit 1
              fi
            else
              exit 1
            fi
          else
            # æå– PR ä¿¡æ¯
            PR_NUMBER=$(echo "$PR_BODY" | jq -r '.number // empty' 2>/dev/null || echo "$PR_BODY" | grep -o '"number":[0-9]*' | head -1 | cut -d':' -f2)
            PR_URL=$(echo "$PR_BODY" | jq -r '.html_url // empty' 2>/dev/null || echo "$PR_BODY" | grep -o '"html_url":"[^"]*"' | head -1 | cut -d'"' -f4)
            echo "âœ… PR #$PR_NUMBER created: $PR_URL"
            echo "PR_NUMBER=$PR_NUMBER" >> $GITHUB_OUTPUT
            echo "PR_URL=$PR_URL" >> $GITHUB_OUTPUT
          fi

          # ç¡®ä¿ PR_NUMBER å·²è®¾ç½®
          if [ -z "$PR_NUMBER" ]; then
            echo "âŒ Error: PR_NUMBER is not set"
            exit 1
          fi

          echo "âœ… Using WORKFLOW_PAT to create PR, CI will trigger automatically"

      # Step 2: Merge version update PR (only if needs_increment is true and master branch and has changes)
      - name: â³ Wait for PR status update
        id: wait_pr_status
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        shell: bash
        run: |
          echo "â³ Waiting 30s for PR status to be updated and CI to complete..."
          sleep 30

      - name: ğŸ” Check PR mergeable status
        id: check_pr_status
        if: needs.update-version.outputs.needs_increment == 'true' && needs.update-version.outputs.is_master_branch == 'true' && needs.update-version.outputs.has_changes == 'true'
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"

          if [ -z "$PR_NUMBER" ]; then
            echo "âŒ Error: PR_NUMBER is not set"
            exit 1
          fi

          # ä½¿ç”¨ GITHUB_TOKEN æ£€æŸ¥ PR çŠ¶æ€ï¼ˆé»˜è®¤ tokenï¼Œæœ‰ read æƒé™ï¼‰
          PR_STATUS=$(curl -s \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

          MERGED=$(echo "$PR_STATUS" | grep -o '"merged":[^,}]*' | cut -d':' -f2 | tr -d ' "')
          MERGEABLE=$(echo "$PR_STATUS" | grep -o '"mergeable":[^,}]*' | cut -d':' -f2 | tr -d ' "')

          echo "merged=$MERGED" >> $GITHUB_OUTPUT
          echo "mergeable=$MERGEABLE" >> $GITHUB_OUTPUT

      - name: âœ… Handle already merged PR
        id: handle_pr_merged
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          steps.check_pr_status.outputs.merged == 'true'
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          NEW_VERSION="${{ needs.update-version.outputs.version }}"

          echo "âœ… PR already merged"
          echo "pr_merged=true" >> $GITHUB_OUTPUT

          # åˆ é™¤è¿œç¨‹åˆ†æ”¯
          echo "Step 2.2: Deleting remote branch"
          BRANCH_NAME="bump-version-${NEW_VERSION}"
          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            git push origin --delete "$BRANCH_NAME" 2>/dev/null || echo "âš ï¸  Failed to delete remote branch (may already be deleted)"
          else
            echo "â„¹ï¸  Remote branch already deleted"
          fi

      - name: ğŸ” Get merge commit SHA (for already merged PR)
        id: get_merge_sha_merged
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          steps.handle_pr_merged.outputs.pr_merged == 'true'
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          echo "Getting merge commit SHA from PR API..."
          MERGE_SHA_MAX_WAIT=10
          MERGE_SHA_ELAPSED=0
          MERGE_SHA_INTERVAL=1
          MERGE_COMMIT_SHA=""

          while [ $MERGE_SHA_ELAPSED -lt $MERGE_SHA_MAX_WAIT ] && [ -z "$MERGE_COMMIT_SHA" ]; do
            sleep $MERGE_SHA_INTERVAL
            MERGE_SHA_ELAPSED=$((MERGE_SHA_ELAPSED + MERGE_SHA_INTERVAL))

            PR_INFO=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGE_COMMIT_SHA=$(echo "$PR_INFO" | jq -r '.merge_commit_sha // empty' 2>/dev/null)
            if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
              echo "âœ… Got merge commit SHA: $MERGE_COMMIT_SHA (after ${MERGE_SHA_ELAPSED}s)"
              echo "merge_commit_sha=$MERGE_COMMIT_SHA" >> $GITHUB_OUTPUT
              break
            fi
          done

          if [ -z "$MERGE_COMMIT_SHA" ] || [ "$MERGE_COMMIT_SHA" = "null" ]; then
            echo "âš ï¸  Warning: Could not get merge_commit_sha from PR API after ${MERGE_SHA_MAX_WAIT}s, will use git pull method"
            echo "merge_commit_sha=" >> $GITHUB_OUTPUT
          fi

      - name: â³ Wait for PR to be mergeable
        id: wait_mergeable
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          steps.check_pr_status.outputs.merged != 'true' &&
          (steps.check_pr_status.outputs.mergeable == 'null' || steps.check_pr_status.outputs.mergeable == 'false')
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          MAX_WAIT=300
          INITIAL_CHECK_INTERVAL=3  # å‰ 60 ç§’æ¯ 3 ç§’æ£€æŸ¥ä¸€æ¬¡
          NORMAL_CHECK_INTERVAL=5   # ä¹‹åæ¯ 5 ç§’æ£€æŸ¥ä¸€æ¬¡
          ELAPSED=30  # ä» 30 ç§’å¼€å§‹è®¡æ•°ï¼ˆå·²ç­‰å¾… CI å®Œæˆï¼‰

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # åŠ¨æ€è°ƒæ•´æ£€æŸ¥é—´éš”ï¼ˆå‰ 60 ç§’æ›´é¢‘ç¹æ£€æŸ¥ï¼‰
            if [ $ELAPSED -lt 60 ]; then
              CHECK_INTERVAL=$INITIAL_CHECK_INTERVAL
            else
              CHECK_INTERVAL=$NORMAL_CHECK_INTERVAL
            fi

            # ä½¿ç”¨ GITHUB_TOKEN æ£€æŸ¥ PR çŠ¶æ€ï¼ˆé»˜è®¤ tokenï¼Œæœ‰ read æƒé™ï¼‰
            PR_STATUS=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGED=$(echo "$PR_STATUS" | grep -o '"merged":[^,}]*' | cut -d':' -f2 | tr -d ' "')
            MERGEABLE=$(echo "$PR_STATUS" | grep -o '"mergeable":[^,}]*' | cut -d':' -f2 | tr -d ' "')

            if [ "$MERGED" = "true" ]; then
              echo "âœ… PR already merged"
              echo "pr_merged=true" >> $GITHUB_OUTPUT
              break
            fi

            # å¦‚æœ mergeable ä¸º nullï¼Œè¯´æ˜ GitHub è¿˜åœ¨è®¡ç®—çŠ¶æ€ï¼Œç»§ç»­ç­‰å¾…
            if [ "$MERGEABLE" = "null" ]; then
              echo "â³ PR mergeable status is still being calculated (elapsed: ${ELAPSED}s), waiting..."
              sleep $CHECK_INTERVAL
              ELAPSED=$((ELAPSED + CHECK_INTERVAL))
              continue
            fi

            # å¦‚æœ mergeable ä¸º falseï¼Œè¯´æ˜ PR æœ‰å†²çªæˆ–æœªé€šè¿‡æ£€æŸ¥ï¼Œè®°å½•å¹¶ç»§ç»­ç­‰å¾…
            if [ "$MERGEABLE" = "false" ]; then
              echo "â³ PR is not mergeable yet (may have conflicts or pending checks, elapsed: ${ELAPSED}s), waiting..."
              sleep $CHECK_INTERVAL
              ELAPSED=$((ELAPSED + CHECK_INTERVAL))
              continue
            fi

            if [ "$MERGEABLE" = "true" ]; then
              echo "âœ… PR is mergeable, proceeding to merge..."
              echo "pr_mergeable=true" >> $GITHUB_OUTPUT
              break
            fi

            sleep $CHECK_INTERVAL
            ELAPSED=$((ELAPSED + CHECK_INTERVAL))
          done

          if [ $ELAPSED -ge $MAX_WAIT ]; then
            echo "â° Timeout: PR did not become mergeable within ${MAX_WAIT}s"
            echo "Please manually merge: $PR_URL"
            exit 1
          fi

      - name: ğŸ”€ Merge version update PR
        id: merge_pr
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          steps.check_pr_status.outputs.merged != 'true' &&
          (steps.wait_mergeable.outputs.pr_mergeable == 'true' || steps.check_pr_status.outputs.mergeable == 'true')
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          NEW_VERSION="${{ needs.update-version.outputs.version }}"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Step 2: Merging version update PR"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "â„¹ï¸  Using GITHUB_TOKEN to merge PR (workflow has pull-requests: write permission)"
          echo "ğŸ”€ Attempting to merge PR #$PR_NUMBER..."

          # å°è¯•åˆå¹¶ï¼ˆä½¿ç”¨ GITHUB_TOKENï¼Œworkflow æœ‰ pull-requests: write æƒé™ï¼‰
          MERGE_RESPONSE=$(curl -s -w "\n%{http_code}" -X PUT \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/merge" \
            -d '{
              "commit_title": "chore: bump version to '"$NEW_VERSION"'",
              "commit_message": "Automated version bump to '"$NEW_VERSION"'\n\nMerged via GitHub Actions workflow",
              "merge_method": "squash"
            }')

          MERGE_CODE=$(echo "$MERGE_RESPONSE" | tail -n1)
          MERGE_BODY=$(echo "$MERGE_RESPONSE" | head -n-1)

          if [ "$MERGE_CODE" = "200" ]; then
            echo "âœ… PR merged successfully"
            echo "pr_merged=true" >> $GITHUB_OUTPUT
          elif [ "$MERGE_CODE" = "405" ]; then
            echo "âš ï¸  PR not ready to merge yet (HTTP 405), but continuing..."
            echo "pr_merged=false" >> $GITHUB_OUTPUT
          else
            echo "âŒ Failed to merge PR (HTTP $MERGE_CODE)"
            echo "Response: $MERGE_BODY" | jq '.' 2>/dev/null || echo "$MERGE_BODY"
            exit 1
          fi

      - name: ğŸ” Get merge commit SHA (for merged PR)
        id: get_merge_sha
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          (steps.handle_pr_merged.outputs.pr_merged == 'true' || steps.merge_pr.outputs.pr_merged == 'true' || steps.wait_mergeable.outputs.pr_merged == 'true')
        shell: bash
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number }}"
          echo "Getting merge commit SHA from PR API..."
          MERGE_SHA_MAX_WAIT=10
          MERGE_SHA_ELAPSED=0
          MERGE_SHA_INTERVAL=1
          MERGE_COMMIT_SHA=""

          while [ $MERGE_SHA_ELAPSED -lt $MERGE_SHA_MAX_WAIT ] && [ -z "$MERGE_COMMIT_SHA" ]; do
            sleep $MERGE_SHA_INTERVAL
            MERGE_SHA_ELAPSED=$((MERGE_SHA_ELAPSED + MERGE_SHA_INTERVAL))

            PR_INFO=$(curl -s \
              -H "Accept: application/vnd.github+json" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER")

            MERGE_COMMIT_SHA=$(echo "$PR_INFO" | jq -r '.merge_commit_sha // empty' 2>/dev/null)
            if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
              echo "âœ… Got merge commit SHA: $MERGE_COMMIT_SHA (after ${MERGE_SHA_ELAPSED}s)"
              echo "merge_commit_sha=$MERGE_COMMIT_SHA" >> $GITHUB_OUTPUT
              break
            fi
          done

          if [ -z "$MERGE_COMMIT_SHA" ] || [ "$MERGE_COMMIT_SHA" = "null" ]; then
            echo "âš ï¸  Warning: Could not get merge_commit_sha from PR API after ${MERGE_SHA_MAX_WAIT}s, will use git pull method"
            echo "merge_commit_sha=" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ—‘ï¸ Delete remote branch
        id: delete_branch
        if: |
          needs.update-version.outputs.needs_increment == 'true' &&
          needs.update-version.outputs.is_master_branch == 'true' &&
          needs.update-version.outputs.has_changes == 'true' &&
          (steps.handle_pr_merged.outputs.pr_merged == 'true' || steps.merge_pr.outputs.pr_merged == 'true')
        shell: bash
        run: |
          NEW_VERSION="${{ needs.update-version.outputs.version }}"
          BRANCH_NAME="bump-version-${NEW_VERSION}"

          echo "Step 2.2: Deleting remote branch"
          if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
            git push origin --delete "$BRANCH_NAME" 2>/dev/null || echo "âš ï¸  Failed to delete remote branch (may already be deleted)"
          else
            echo "â„¹ï¸  Remote branch already deleted"
          fi

      # Step 3: Create and push tag
      - name: âš™ï¸ Configure Git for tag creation
        shell: bash
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: ğŸ·ï¸ Create and push tag
        shell: bash
        run: |
          TAG="${{ needs.update-version.outputs.tag }}"
          NEW_VERSION="${{ needs.update-version.outputs.version }}"
          IS_MASTER="${{ needs.update-version.outputs.is_master_branch }}"
          NEEDS_INCREMENT="${{ needs.update-version.outputs.needs_increment }}"

          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Step 3: Creating and pushing tag"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Creating tag: $TAG"

          # Master åˆ†æ”¯ï¼šå¦‚æœ PR å·²åˆå¹¶ï¼Œä½¿ç”¨ merge_commit_sha æˆ–æ‹‰å–æœ€æ–°çš„ master åˆ†æ”¯
          if [ "$IS_MASTER" == "true" ] && [ "$NEEDS_INCREMENT" == "true" ]; then
            MERGE_COMMIT_SHA="${{ steps.get_merge_sha_merged.outputs.merge_commit_sha || steps.get_merge_sha.outputs.merge_commit_sha }}"

            if [ -n "$MERGE_COMMIT_SHA" ] && [ "$MERGE_COMMIT_SHA" != "null" ]; then
              # ä½¿ç”¨ä» PR API è·å–çš„ merge_commit_sha
              echo "Step 3.1: Using merge_commit_sha from PR API: $MERGE_COMMIT_SHA"
              TAG_COMMIT_SHA="$MERGE_COMMIT_SHA"

              # éªŒè¯è¯¥ commit æ˜¯å¦å­˜åœ¨
              if git cat-file -e "$TAG_COMMIT_SHA" 2>/dev/null; then
                echo "âœ… Merge commit exists locally"
              else
                echo "Step 3.2: Fetching merge commit from origin..."
                # å°è¯•é€šè¿‡ refs è·å– commit
                git fetch origin "$TAG_COMMIT_SHA" 2>/dev/null || \
                git fetch origin "+refs/heads/*:refs/remotes/origin/*" 2>/dev/null || true
                if ! git cat-file -e "$TAG_COMMIT_SHA" 2>/dev/null; then
                  echo "âš ï¸  Warning: Merge commit not found, falling back to git pull method"
                  TAG_COMMIT_SHA=""
                fi
              fi
            else
              TAG_COMMIT_SHA=""
            fi

            # å¦‚æœæ²¡æœ‰ merge_commit_shaï¼Œä½¿ç”¨ git pull æ–¹æ³•ï¼ˆå›é€€æ–¹æ¡ˆï¼‰
            if [ -z "$TAG_COMMIT_SHA" ]; then
              echo "Step 3.1: Fetching latest changes from origin (after PR merge)..."
              # å°è¯•è·å–é»˜è®¤åˆ†æ”¯åç§°ï¼ˆmaster æˆ– mainï¼‰
              DEFAULT_BRANCH=$(git remote show origin | grep "HEAD branch" | cut -d' ' -f5 || echo "master")
              echo "Detected default branch: $DEFAULT_BRANCH"

              git fetch origin "$DEFAULT_BRANCH:$DEFAULT_BRANCH" 2>/dev/null || true

              echo "Step 3.2: Checking out $DEFAULT_BRANCH branch..."
              git checkout "$DEFAULT_BRANCH" 2>/dev/null || true

              echo "Step 3.3: Pulling latest changes..."
              git pull origin "$DEFAULT_BRANCH" 2>/dev/null || true

              # éªŒè¯å½“å‰æäº¤åŒ…å«ç‰ˆæœ¬æ›´æ–°
              echo "Step 3.4: Verifying current commit..."
              LATEST_COMMIT_MSG=$(git log -1 --format='%s' HEAD)
              TAG_COMMIT_SHA=$(git rev-parse HEAD)
              echo "Latest commit SHA: $TAG_COMMIT_SHA"
              echo "Latest commit message: $LATEST_COMMIT_MSG"

              if [[ "$LATEST_COMMIT_MSG" =~ "bump version" ]] || [[ "$LATEST_COMMIT_MSG" =~ "chore: bump version" ]]; then
                echo "âœ… Found version bump commit on master"
              else
                echo "âš ï¸  Warning: Latest commit may not be the version bump commit"
                echo "   This might happen if PR was merged with a different commit message"
                echo "   Continuing to create tag on current commit..."
              fi
            fi
          else
            # é Master åˆ†æ”¯ï¼šä½¿ç”¨å½“å‰åˆ†æ”¯çš„ commit
            echo "Step 3.1: Using current branch for tag creation (non-master branch)"
            CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
            TAG_COMMIT_SHA=$(git rev-parse HEAD)
            echo "Current branch: $CURRENT_BRANCH"
            echo "Current commit SHA: $TAG_COMMIT_SHA"
          fi

          # æ£€æŸ¥ tag æ˜¯å¦å·²å­˜åœ¨
          if git rev-parse "$TAG" >/dev/null 2>&1; then
            EXISTING_TAG_SHA=$(git rev-parse "$TAG")
            if [ "$EXISTING_TAG_SHA" = "$TAG_COMMIT_SHA" ]; then
              echo "âœ… Tag $TAG already exists and points to the correct commit: $TAG_COMMIT_SHA"
            else
              echo "âš ï¸  Warning: Tag $TAG already exists but points to different commit"
              echo "   Existing tag SHA: $EXISTING_TAG_SHA"
              echo "   Target commit SHA: $TAG_COMMIT_SHA"
              echo "   Deleting existing tag and recreating..."
              git tag -d "$TAG" 2>/dev/null || true
              git push origin ":refs/tags/$TAG" 2>/dev/null || true
            fi
          fi

          # åˆ›å»º tagï¼ˆåŸºäºæŒ‡å®šçš„ commit SHAï¼‰
          echo "Step 3.5: Creating tag $TAG on commit $TAG_COMMIT_SHA..."
          git tag "$TAG" "$TAG_COMMIT_SHA"

          # æ¨é€ tagï¼ˆä½¿ç”¨ PATï¼Œå› ä¸º tag å¯èƒ½æŒ‡å‘ä¿®æ”¹äº† workflow æ–‡ä»¶çš„ commitï¼‰
          # æ³¨æ„ï¼šå½“ tag æŒ‡å‘çš„ commit ä¿®æ”¹äº† workflow æ–‡ä»¶æ—¶ï¼ŒGITHUB_TOKEN æ— æ³•æ¨é€ï¼Œå¿…é¡»ä½¿ç”¨ PAT
          echo "Step 3.6: Pushing tag: $TAG"
          echo "â„¹ï¸  Using WORKFLOW_PAT to push tag (required when tag points to commit that modifies workflow files)"
          if git push origin "$TAG" 2>&1; then
            echo "âœ… Successfully created and pushed tag: $TAG"
          else
            PUSH_ERROR=$?
            echo "âŒ Error: Failed to push tag: $TAG (exit code: $PUSH_ERROR)"
            echo "Checking if tag already exists remotely..."
            if git ls-remote --tags origin "$TAG" | grep -q "$TAG"; then
              REMOTE_TAG_SHA=$(git ls-remote --tags origin "$TAG" | cut -f1)
              if [ "$REMOTE_TAG_SHA" = "$TAG_COMMIT_SHA" ]; then
                echo "âœ… Tag already exists remotely and points to the correct commit"
                echo "   Remote tag SHA: $REMOTE_TAG_SHA"
                echo "   Target commit SHA: $TAG_COMMIT_SHA"
              else
                echo "âš ï¸  Warning: Tag exists remotely but points to different commit"
                echo "   Remote tag SHA: $REMOTE_TAG_SHA"
                echo "   Target commit SHA: $TAG_COMMIT_SHA"
                echo "   This may indicate a conflict. Please check manually."
                exit 1
              fi
            else
              echo "âŒ Tag does not exist remotely. Push failed."
              exit 1
            fi
          fi

      # Step 4: Set job outputs
      - name: ğŸ“Š Set job outputs for downstream jobs
        id: job_outputs
        shell: bash
        run: |
          VERSION="${{ needs.update-version.outputs.version }}"
          TAG="${{ needs.update-version.outputs.tag }}"
          IS_MASTER="${{ needs.update-version.outputs.is_master_branch }}"
          NEEDS_INCREMENT="${{ needs.update-version.outputs.needs_increment }}"

          # æ£€æŸ¥æ˜¯å¦åˆ›å»ºäº†æ–° tag
          if [ "$IS_MASTER" == "true" ]; then
            # Master åˆ†æ”¯ï¼šæ£€æŸ¥æ˜¯å¦åˆ›å»ºäº†æ–° tag
            if [ "$NEEDS_INCREMENT" == "true" ]; then
              # éœ€è¦é€’å¢ç‰ˆæœ¬å·ï¼Œä¼šåˆ›å»ºæ–° tag
              TAG_CREATED="true"
            else
              # æ£€æŸ¥ tag æ˜¯å¦å·²å­˜åœ¨
              if git rev-parse "$TAG" >/dev/null 2>&1; then
                TAG_CREATED="false"
              else
                TAG_CREATED="true"
              fi
            fi
          else
            # é Master åˆ†æ”¯ï¼šæ£€æŸ¥ tag æ˜¯å¦å·²å­˜åœ¨
            if git rev-parse "$TAG" >/dev/null 2>&1; then
              TAG_CREATED="false"
              echo "â„¹ï¸  Tag already exists: $TAG"
            else
              TAG_CREATED="true"
              echo "â„¹ï¸  Created new pre-release tag: $TAG"
            fi
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "tag_created=$TAG_CREATED" >> $GITHUB_OUTPUT
          echo "âœ… Job outputs set: version=$VERSION, tag=$TAG, tag_created=$TAG_CREATED"

  # åˆ›å»º GitHub Release
  release:
    name: ğŸš€ Create Release
    runs-on: ubuntu-latest
    needs: [update-version, create-tag, build, release-confirm]
    if: |
      (github.event_name == 'workflow_dispatch' && github.ref != 'refs/heads/master' && needs.update-version.result == 'success' && needs.create-tag.result == 'success' && needs.build.result == 'success' && needs.release-confirm.result == 'success') ||
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.update-version.result == 'success' && needs.create-tag.result == 'success' && needs.build.result == 'success' && needs.release-confirm.result == 'success' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ” Get version and tag from previous jobs
        id: version
        shell: bash
        run: |
          VERSION="${{ needs.update-version.outputs.version }}"
          # å¦‚æœ create-tag job æˆåŠŸè¿è¡Œï¼Œä½¿ç”¨å…¶ outputsï¼›å¦åˆ™ä½¿ç”¨ update-version çš„ outputs
          if [ "${{ needs.create-tag.result }}" == "success" ] && [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
            TAG="${{ needs.create-tag.outputs.tag }}"
            echo "âœ… Using tag from create-tag job: $TAG"
          else
            TAG="${{ needs.update-version.outputs.tag }}"
            echo "âœ… Using tag from update-version job: $TAG"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: $TAG"

      - name: ğŸ“¥ Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: ğŸ“ Prepare release info
        id: release_info
        shell: bash
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          IS_MASTER="${{ needs.update-version.outputs.is_master_branch }}"

          if [ "$IS_MASTER" == "true" ]; then
            RELEASE_NAME="Release $VERSION"
            RELEASE_BODY="## Release $VERSION

            See the [changelog](https://github.com/${{ github.repository }}/blob/master/CHANGELOG.md) for details."
          else
            RELEASE_NAME="Pre-release $VERSION"
            RELEASE_BODY="## Pre-release $VERSION

            âš ï¸ **This is a pre-release version** (alpha build)

            See the [changelog](https://github.com/${{ github.repository }}/blob/master/CHANGELOG.md) for details."
          fi

          # ä½¿ç”¨å¤šè¡Œè¾“å‡ºï¼ˆä½¿ç”¨ EOF åˆ†éš”ç¬¦ï¼‰
          {
            echo "name<<EOF"
            echo "$RELEASE_NAME"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          {
            echo "body<<EOF"
            echo "$RELEASE_BODY"
            echo "EOF"
          } >> $GITHUB_OUTPUT

          echo "âœ… Release name: $RELEASE_NAME"
          echo "âœ… Is pre-release: $([ "$IS_MASTER" != "true" ] && echo "true" || echo "false")"

      - name: ğŸš€ Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.version.outputs.tag }}
          name: ${{ steps.release_info.outputs.name }}
          body: ${{ steps.release_info.outputs.body }}
          files: |
            artifacts/**/*
          draft: false
          prerelease: ${{ needs.update-version.outputs.is_master_branch != 'true' }}

  # æ›´æ–° Homebrew Formula
  # æ³¨æ„ï¼šåªåœ¨ master åˆ†æ”¯çš„ push äº‹ä»¶æ—¶æ›´æ–°ï¼Œé master åˆ†æ”¯ä¸æ›´æ–°
  update-homebrew:
    name: ğŸº Update Homebrew Formula
    runs-on: ubuntu-latest
    needs: [update-version, create-tag, build, release]
    if: |
      (github.event_name == 'push' && github.ref == 'refs/heads/master' && needs.update-version.result == 'success' && needs.create-tag.result == 'success' && needs.build.result == 'success' && needs.release.result == 'success' && needs.create-tag.outputs.tag_created == 'true')
    permissions:
      contents: write
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ” Get version and tag from previous jobs
        id: version
        shell: bash
        run: |
          VERSION="${{ needs.update-version.outputs.version }}"
          # å¦‚æœ create-tag job æˆåŠŸè¿è¡Œï¼Œä½¿ç”¨å…¶ outputsï¼›å¦åˆ™ä½¿ç”¨ update-version çš„ outputs
          if [ "${{ needs.create-tag.result }}" == "success" ] && [ -n "${{ needs.create-tag.outputs.tag }}" ]; then
            TAG="${{ needs.create-tag.outputs.tag }}"
            echo "âœ… Using tag from create-tag job: $TAG"
          else
            TAG="${{ needs.update-version.outputs.tag }}"
            echo "âœ… Using tag from update-version job: $TAG"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "âœ… Version: $VERSION"
          echo "âœ… Tag: $TAG"

      - name: ğŸ“¥ Checkout homebrew-workflow
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/homebrew-workflow
          token: ${{ secrets.WORKFLOW_PAT }}
          path: homebrew-workflow

      - name: ğŸ“ Generate Formula file
        shell: bash
        run: |
          cd homebrew-workflow

          VERSION="${{ steps.version.outputs.version }}"
          TAG="${{ steps.version.outputs.tag }}"
          FORMULA_FILE="Formula/workflow.rb"

          # å¤‡ä»½åŸå§‹æ–‡ä»¶
          if [ -f "$FORMULA_FILE" ]; then
            cp "$FORMULA_FILE" "$FORMULA_FILE.bak"
          fi

          # ä»æ¨¡æ¿ç”Ÿæˆ Formula æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨æ¨¡æ¿ï¼‰
          # å¦åˆ™ç›´æ¥æ›´æ–°ç°æœ‰æ–‡ä»¶
          if [ -f "Formula/workflow.rb.template" ]; then
            echo "ğŸ“ Generating Formula file from template..."
            sed -e "s|{{VERSION}}|$VERSION|g" \
                -e "s|{{TAG}}|$TAG|g" \
                "Formula/workflow.rb.template" > "$FORMULA_FILE"
            echo "âœ… Formula file generated from template"
          else
            # ç›´æ¥æ›´æ–°ç°æœ‰æ–‡ä»¶ä¸­çš„ç‰ˆæœ¬å·
            echo "ğŸ“ Updating version in Formula file..."
            # è¿™é‡Œéœ€è¦æ ¹æ®å®é™…çš„ Formula æ–‡ä»¶æ ¼å¼æ¥æ›´æ–°
            # é€šå¸¸éœ€è¦æ›´æ–° version å’Œ url å­—æ®µ
            sed -i.bak "s/version \".*\"/version \"$VERSION\"/" "$FORMULA_FILE" || true
            sed -i.bak "s|url \".*\"|url \"https://github.com/${{ github.repository }}/releases/download/$TAG/workflow-$VERSION-x86_64-apple-darwin.tar.gz\"|" "$FORMULA_FILE" || true
            echo "âœ… Formula file updated"
          fi

          # éªŒè¯æ–‡ä»¶ç»“æ„ï¼ˆç¡®ä¿æ²¡æœ‰è¯­æ³•é”™è¯¯ï¼‰
          echo "ğŸ” Validating Formula file structure..."
          if ! ruby -c "$FORMULA_FILE" 2>/dev/null; then
            echo "âŒ Error: Formula file has syntax errors"
            ruby -c "$FORMULA_FILE" || true
            exit 1
          fi
          echo "âœ… Formula file syntax is valid"

          # æ˜¾ç¤ºç”Ÿæˆçš„ Formula æ–‡ä»¶
          echo ""
          echo "ğŸ“„ Generated Formula file:"
          echo "--- Formula/workflow.rb ---"
          cat "$FORMULA_FILE"
          echo ""

          # æ˜¾ç¤ºæ›´æ”¹ï¼ˆå¦‚æœæœ‰å¤‡ä»½ï¼‰
          if [ -f "$FORMULA_FILE.bak" ]; then
            echo "--- Diff (Before vs After) ---"
            diff "$FORMULA_FILE.bak" "$FORMULA_FILE" || true
          fi

      - name: âš™ï¸ Configure Git for Homebrew update
        shell: bash
        run: |
          cd homebrew-workflow
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: ğŸ“¤ Commit and push changes
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.WORKFLOW_PAT }}
        run: |
          cd homebrew-workflow

          # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹
          git add Formula/workflow.rb

          if git diff --staged --quiet; then
            echo "No changes to commit. Formula file is already up to date."
            exit 0
          fi

          # éªŒè¯ Formula æ–‡ä»¶æ ¼å¼
          if ! brew audit --strict Formula/workflow.rb 2>/dev/null; then
            echo "Warning: brew audit failed, but continuing..."
          fi

          # æäº¤æ›´æ”¹
          git commit -m "Update workflow to ${{ steps.version.outputs.tag }}"

          # æ£€æµ‹å½“å‰åˆ†æ”¯åç§°
          CURRENT_BRANCH=$(git branch --show-current)
          echo "Current branch: $CURRENT_BRANCH"

          # actions/checkout@v4 å·²ç»è®¾ç½®äº†æ­£ç¡®çš„è¿œç¨‹ URLï¼Œç›´æ¥æ¨é€å³å¯
          # æ¨é€æ›´æ”¹åˆ°å½“å‰åˆ†æ”¯
          echo "Pushing to branch: $CURRENT_BRANCH"
          if git push origin "$CURRENT_BRANCH"; then
            echo "âœ… Successfully pushed to $CURRENT_BRANCH branch"
          else
            echo "âŒ Error: Failed to push changes to $CURRENT_BRANCH"
            echo "Remote URL: $(git remote get-url origin | sed 's|://.*@|://***@|')"
            echo "Branch: $CURRENT_BRANCH"
            echo "Git status:"
            git status
            echo "Git log:"
            git log --oneline -5
            echo ""
            echo "Possible issues:"
            echo "1. WORKFLOW_PAT may not have write access to ${{ github.repository_owner }}/homebrew-workflow"
            echo "2. Token may have expired or been revoked"
            echo "3. Repository may not exist or be accessible"
            exit 1
          fi

          echo "âœ… Homebrew Formula updated successfully!"

  # æ¸…ç†å·²åˆå¹¶åˆ†æ”¯çš„ alpha tag
  # å½“ PR åˆå¹¶åˆ° master åï¼Œæ¸…ç†æŒ‡å‘å·²åˆå¹¶æäº¤çš„ alpha tag
  cleanup-alpha-tags:
    name: ğŸ§¹ Cleanup Alpha Tags
    runs-on: ubuntu-latest
    needs: [create-tag]
    # åªåœ¨ master åˆ†æ”¯çš„ push äº‹ä»¶æ—¶è¿è¡Œï¼Œä¸” create-tag job æˆåŠŸ
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/master' &&
      needs.create-tag.result == 'success' &&
      needs.create-tag.outputs.pr_merged == 'true'
    permissions:
      contents: write
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          # ä½¿ç”¨ PAT ä»¥æ”¯æŒåˆ é™¤ tag
          token: ${{ secrets.WORKFLOW_PAT }}

      - name: ğŸ§¹ Cleanup Alpha Tags
        id: cleanup
        shell: bash
        run: |
          set -e

          echo "ğŸ” Starting alpha tag cleanup..."

          # è·å–åˆå¹¶æäº¤çš„ SHA
          MERGE_COMMIT_SHA="${{ needs.create-tag.outputs.merge_commit_sha }}"

          if [ -z "$MERGE_COMMIT_SHA" ]; then
            echo "âš ï¸  No merge commit SHA found, skipping cleanup"
            exit 0
          fi

          echo "ğŸ“Œ Merge commit SHA: $MERGE_COMMIT_SHA"

          # è·å–å½“å‰å‘å¸ƒçš„ç‰ˆæœ¬å·ï¼ˆä¾‹å¦‚ï¼š1.6.0ï¼‰
          CURRENT_VERSION="${{ needs.create-tag.outputs.version }}"
          # ç§»é™¤ç‰ˆæœ¬å·ä¸­çš„ 'v' å‰ç¼€å’Œå¯èƒ½çš„ alpha åç¼€ï¼Œåªä¿ç•™åŸºç¡€ç‰ˆæœ¬å·
          CURRENT_VERSION=$(echo "$CURRENT_VERSION" | sed -E 's/^v?([0-9]+\.[0-9]+\.[0-9]+).*/\1/')
          echo "ğŸ“Œ Current release version: $CURRENT_VERSION"

          # è·å–åˆå¹¶æäº¤çš„ç¬¬ä¸€ä¸ªçˆ¶æäº¤ï¼ˆmaster åˆ†æ”¯çš„ previous commitï¼‰
          # è¿™æ˜¯ master åˆ†æ”¯åœ¨åˆå¹¶å‰çš„æœ€åä¸€ä¸ªæäº¤
          FIRST_PARENT=$(git rev-parse ${MERGE_COMMIT_SHA}^1)
          echo "   First parent (master before merge): $FIRST_PARENT"

          # è·å– master åˆ†æ”¯çš„å½“å‰ HEADï¼ˆåˆå¹¶åçš„çŠ¶æ€ï¼‰
          MASTER_HEAD=$(git rev-parse HEAD)
          echo "   Master HEAD (after merge): $MASTER_HEAD"

          # å¯¹äº squash mergeï¼Œåˆå¹¶æäº¤åªæœ‰ä¸€ä¸ªçˆ¶æäº¤
          # å¯¹äºå¸¸è§„ mergeï¼Œåˆå¹¶æäº¤æœ‰ä¸¤ä¸ªçˆ¶æäº¤
          # æˆ‘ä»¬é€šè¿‡æ£€æŸ¥ tag æ˜¯å¦åœ¨ master çš„ first-parent è·¯å¾„ä¸Šæ¥åˆ¤æ–­
          # å¦‚æœ tag ä¸åœ¨ first-parent è·¯å¾„ä¸Šï¼Œè¯´æ˜å®ƒæ¥è‡ªå·²åˆå¹¶çš„åˆ†æ”¯

          # æŸ¥æ‰¾æ‰€æœ‰ alpha tag
          echo ""
          echo "ğŸ·ï¸  Finding alpha tags..."
          ALPHA_TAGS=$(git tag -l '*.alpha-*' | sort -V || echo "")

          if [ -z "$ALPHA_TAGS" ]; then
            echo "âœ… No alpha tags found, nothing to clean up"
            exit 0
          fi

          echo "ğŸ“‹ Found alpha tags:"
          echo "$ALPHA_TAGS" | while read tag; do
            echo "   - $tag"
          done

          # æ£€æŸ¥æ¯ä¸ª alpha tag æ˜¯å¦æŒ‡å‘å·²åˆå¹¶çš„æäº¤
          TAGS_TO_DELETE=""
          DELETED_COUNT=0

          echo ""
          echo "ğŸ” Checking which alpha tags point to merged commits..."

          for tag in $ALPHA_TAGS; do
            TAG_COMMIT=$(git rev-parse "$tag" 2>/dev/null || echo "")

            if [ -z "$TAG_COMMIT" ]; then
              echo "   âš ï¸  Tag $tag: Could not resolve commit"
              continue
            fi

            # æå– tag çš„ç‰ˆæœ¬å·ï¼ˆä¾‹å¦‚ï¼šv1.6.0.alpha-001 -> 1.6.0ï¼‰
            # ä½¿ç”¨ sed æå–ç‰ˆæœ¬å·ï¼Œå¦‚æœå¤±è´¥åˆ™è®¾ç½®ä¸ºç©ºå­—ç¬¦ä¸²
            TAG_VERSION=$(echo "$tag" | sed -E 's/^v?([0-9]+\.[0-9]+\.[0-9]+)\.alpha-.*/\1/' 2>/dev/null || echo "")
            # éªŒè¯æå–çš„ç‰ˆæœ¬å·æ ¼å¼æ˜¯å¦æ­£ç¡®ï¼ˆåº”è¯¥æ˜¯ x.y.z æ ¼å¼ï¼‰
            if [ -n "$TAG_VERSION" ] && ! echo "$TAG_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              TAG_VERSION=""
            fi

            # æ£€æŸ¥ tag æ˜¯å¦åœ¨ master åˆ†æ”¯çš„ first-parent è·¯å¾„ä¸Š
            # å¦‚æœä¸åœ¨ï¼Œè¯´æ˜å®ƒæ¥è‡ªå·²åˆå¹¶çš„åˆ†æ”¯ï¼ˆåŒ…æ‹¬ squash merge çš„æƒ…å†µï¼‰
            if git merge-base --is-ancestor "$TAG_COMMIT" "$FIRST_PARENT" 2>/dev/null; then
              # Tag åœ¨ master çš„ first-parent è·¯å¾„ä¸Šï¼Œä¿ç•™å®ƒ
              echo "   â­ï¸  Tag $tag ($TAG_COMMIT) is in master branch first-parent path, keeping"
            elif git merge-base --is-ancestor "$TAG_COMMIT" "$MASTER_HEAD" 2>/dev/null; then
              # Tag åœ¨åˆå¹¶æäº¤çš„ç¥–å…ˆä¸­ï¼Œä½†ä¸åœ¨ first-parent è·¯å¾„ä¸Š
              # è¯´æ˜å®ƒæ¥è‡ªå·²åˆå¹¶çš„åˆ†æ”¯ï¼Œåº”è¯¥åˆ é™¤
              if [ -n "$TAG_VERSION" ] && [ "$TAG_VERSION" == "$CURRENT_VERSION" ]; then
                echo "   âœ… Tag $tag ($TAG_COMMIT) version $TAG_VERSION matches current version $CURRENT_VERSION and is from merged branch, will delete"
              else
                echo "   âœ… Tag $tag ($TAG_COMMIT) is from merged branch, will delete"
              fi
              TAGS_TO_DELETE="$TAGS_TO_DELETE $tag"
            else
              # Tag ä¸åœ¨åˆå¹¶æäº¤çš„ç¥–å…ˆä¸­ï¼Œæ£€æŸ¥ç‰ˆæœ¬å·æ˜¯å¦åŒ¹é…
              if [ -n "$TAG_VERSION" ] && [ "$TAG_VERSION" == "$CURRENT_VERSION" ]; then
                # ç‰ˆæœ¬å·åŒ¹é…ä½† commit ä¸åœ¨ç¥–å…ˆä¸­ï¼Œå¯èƒ½æ˜¯ç‰¹æ®Šæƒ…å†µ
                # ä¾‹å¦‚ï¼štag æŒ‡å‘çš„ commit åœ¨åˆå¹¶ä¹‹ååˆ›å»ºï¼Œæˆ–è€…æ¥è‡ªä¸åŒçš„åˆ†æ”¯
                # ç”±äºç‰ˆæœ¬å·åŒ¹é…ï¼Œæˆ‘ä»¬ä»ç„¶è€ƒè™‘åˆ é™¤å®ƒ
                echo "   âš ï¸  Tag $tag ($TAG_COMMIT) version $TAG_VERSION matches current version $CURRENT_VERSION but commit is not in merge ancestry"
                echo "   ğŸ’¡ Considering deletion due to version match..."
                TAGS_TO_DELETE="$TAGS_TO_DELETE $tag"
              else
                # Tag ä¸åœ¨åˆå¹¶æäº¤çš„ç¥–å…ˆä¸­ï¼Œä¸”ç‰ˆæœ¬å·ä¸åŒ¹é…ï¼Œå¯èƒ½æ˜¯å…¶ä»–åˆ†æ”¯çš„ tagï¼Œä¿ç•™
                echo "   â­ï¸  Tag $tag ($TAG_COMMIT) is not related to this merge, keeping"
              fi
            fi
          done

          if [ -z "$TAGS_TO_DELETE" ]; then
            echo ""
            echo "âœ… No alpha tags to delete"
            exit 0
          fi

          echo ""
          echo "ğŸ—‘ï¸  Deleting alpha tags..."

          # åˆ é™¤æœ¬åœ° tag
          for tag in $TAGS_TO_DELETE; do
            echo "   Deleting local tag: $tag"
            git tag -d "$tag" || echo "   âš ï¸  Failed to delete local tag $tag (may not exist)"
          done

          # åˆ é™¤è¿œç¨‹ tag
          echo ""
          echo "ğŸ—‘ï¸  Deleting remote tags..."
          for tag in $TAGS_TO_DELETE; do
            echo "   Deleting remote tag: $tag"
            git push origin --delete "$tag" || echo "   âš ï¸  Failed to delete remote tag $tag (may not exist or already deleted)"
            DELETED_COUNT=$((DELETED_COUNT + 1))
          done

          echo ""
          echo "âœ… Cleanup completed: Deleted $DELETED_COUNT alpha tag(s)"
          echo "deleted_count=$DELETED_COUNT" >> $GITHUB_OUTPUT
          echo "deleted_tags<<EOF" >> $GITHUB_OUTPUT
          echo "$TAGS_TO_DELETE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

