name: CI

on:
  pull_request:
    branches:
      - master
      - main

env:
  CARGO_TERM_COLOR: always

jobs:
  # 检查是否应该跳过 CI（检查 [skip ci] 标记）
  check-skip-ci:
    name: Check skip CI
    runs-on: ubuntu-latest
    outputs:
      should_skip: ${{ steps.check.outputs.should_skip }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取所有历史记录以检查所有提交

      - name: Fetch remote branches
        run: |
          # 获取所有远程分支信息，以便正确比较
          git fetch --all --depth=1 || true

      - name: Check for [skip ci] in PR
        id: check
        run: |
          # 默认设置为 false，如果找到 [skip ci] 则改为 true
          # 使用 set +e 确保即使命令失败也能继续执行
          set +e
          SHOULD_SKIP="false"

          echo "=== Checking for [skip ci] ==="
          echo "Event: ${{ github.event_name }}"
          echo "Head ref: ${{ github.head_ref }}"
          echo "Base ref: ${{ github.base_ref }}"
          echo "PR number: ${{ github.event.pull_request.number }}"

          # 检查 PR 标题和正文中是否包含 [skip ci]（如果 PR 信息可用）
          if [ -n "${{ github.event.pull_request.title }}" ]; then
            PR_TITLE="${{ github.event.pull_request.title }}"
            PR_BODY="${{ github.event.pull_request.body || '' }}"
            echo "PR Title: $PR_TITLE"
            echo "PR Body: ${PR_BODY:0:100}..." # 只显示前100个字符

            # 检查 PR 标题和正文
            if echo "$PR_TITLE $PR_BODY" | grep -qiE '\[skip\s*ci\]|\[ci\s*skip\]'; then
              echo "✅ Found [skip ci] in PR title or body, skipping CI checks"
              SHOULD_SKIP="true"
            fi
          fi

          # 检查所有提交消息中是否包含 [skip ci]
          if [ "$SHOULD_SKIP" != "true" ]; then
            # 获取 PR 的 base 和 head 分支
            BASE_REF="${{ github.event.pull_request.base.ref }}"
            HEAD_REF="${{ github.event.pull_request.head.ref }}"

            # 如果 PR 信息不可用，尝试从当前分支获取
            if [ -z "$BASE_REF" ]; then
              BASE_REF="${{ github.base_ref }}"
            fi
            if [ -z "$HEAD_REF" ]; then
              HEAD_REF="${{ github.head_ref }}"
            fi

            echo "Base ref: $BASE_REF"
            echo "Head ref: $HEAD_REF"

            # 尝试多种方式获取提交消息
            # 方法1: 使用 git log 比较分支（如果 base 分支存在）
            if [ -n "$BASE_REF" ] && [ -n "$HEAD_REF" ] && [ "$BASE_REF" != "$HEAD_REF" ]; then
              # 获取所有提交消息（从 base 到 head）
              echo "Checking commits between $BASE_REF and $HEAD_REF..."
              COMMIT_MESSAGES=$(git log origin/$BASE_REF..HEAD --format=%B 2>/dev/null || git log origin/$BASE_REF..origin/$HEAD_REF --format=%B 2>/dev/null || git log $BASE_REF..HEAD --format=%B 2>/dev/null || echo "")
              if [ -n "$COMMIT_MESSAGES" ]; then
                if echo "$COMMIT_MESSAGES" | grep -qiE '\[skip\s*ci\]|\[ci\s*skip\]'; then
                  echo "✅ Found [skip ci] in commit message, skipping CI checks"
                  SHOULD_SKIP="true"
                fi
              fi
            fi

            # 方法2: 检查当前 HEAD 的提交消息（作为备选）
            if [ "$SHOULD_SKIP" != "true" ]; then
              HEAD_COMMIT_MSG=$(git log -1 --format=%B HEAD 2>/dev/null || echo "")
              if [ -n "$HEAD_COMMIT_MSG" ]; then
                echo "HEAD commit message: ${HEAD_COMMIT_MSG:0:100}..."
                if echo "$HEAD_COMMIT_MSG" | grep -qiE '\[skip\s*ci\]|\[ci\s*skip\]'; then
                  echo "✅ Found [skip ci] in HEAD commit message, skipping CI checks"
                  SHOULD_SKIP="true"
                fi
              fi
            fi

            # 方法3: 检查最近几个提交的消息（作为额外备选）
            if [ "$SHOULD_SKIP" != "true" ]; then
              RECENT_COMMITS=$(git log -5 --format=%B 2>/dev/null || echo "")
              if [ -n "$RECENT_COMMITS" ]; then
                if echo "$RECENT_COMMITS" | grep -qiE '\[skip\s*ci\]|\[ci\s*skip\]'; then
                  echo "✅ Found [skip ci] in recent commit messages, skipping CI checks"
                  SHOULD_SKIP="true"
                fi
              fi
            fi

            # 检查是否是版本更新分支
            if [ "$SHOULD_SKIP" != "true" ] && [[ "${{ github.head_ref }}" =~ ^bump-version- ]]; then
              echo "✅ Version bump branch detected, skipping CI checks"
              SHOULD_SKIP="true"
            fi
          fi

          # 设置输出（无论成功还是失败都要设置）
          echo "should_skip=$SHOULD_SKIP" >> $GITHUB_OUTPUT
          echo "=== Final decision: should_skip=$SHOULD_SKIP ==="

  # 代码质量检查（Lint）
  check-lint:
    name: Run check-lint
    runs-on: ubuntu-latest
    needs: check-skip-ci
    # 跳过版本更新分支和包含 [skip ci] 的 PR
    if: needs.check-skip-ci.outputs.should_skip != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install system dependencies (Linux)
        run: |
          sudo apt-get update
          # 安装 XCB 开发库（clipboard 依赖）
          # xcb crate 需要 xcb-proto 来生成代码模块
          # xcb-proto 需要 Python 来运行代码生成脚本
          sudo apt-get install -y \
            python3 \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev
          # 验证 xcb-proto 和 Python 已正确安装
          which xcb-proto || echo "⚠️  xcb-proto not found in PATH"
          python3 --version || echo "⚠️  Python3 not found"

      - name: Check code format
        run: cargo fmt --check

      - name: Run Clippy
        run: cargo clippy -- -D warnings

      - name: Run cargo check
        run: cargo check

  # 运行测试
  tests:
    name: Run tests
    runs-on: ubuntu-latest
    needs: check-skip-ci
    # 跳过版本更新分支和包含 [skip ci] 的 PR
    if: needs.check-skip-ci.outputs.should_skip != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install system dependencies (Linux)
        run: |
          sudo apt-get update
          # 安装 XCB 开发库（clipboard 依赖）
          # xcb crate 需要 xcb-proto 来生成代码模块
          # xcb-proto 需要 Python 来运行代码生成脚本
          sudo apt-get install -y \
            python3 \
            libxcb1-dev \
            libxcb-render0-dev \
            libxcb-shape0-dev \
            libxcb-xfixes0-dev \
            xcb-proto \
            libxcb-keysyms1-dev \
            libxcb-image0-dev \
            libxcb-util-dev \
            libxcb-icccm4-dev \
            libxcb-sync-dev \
            libxcb-xinerama0-dev \
            libxcb-randr0-dev \
            libxcb-xinput-dev \
            libxcb-dri3-dev \
            libxcb-present-dev \
            libxcb-xv0-dev \
            libxcb-glx0-dev \
            libxcb-shm0-dev \
            libxcb-composite0-dev \
            libxcb-damage0-dev \
            libxcb-record0-dev \
            libxcb-screensaver0-dev \
            libxcb-res0-dev \
            libxkbcommon-dev \
            libxkbcommon-x11-dev
          # 验证 xcb-proto 和 Python 已正确安装
          which xcb-proto || echo "⚠️  xcb-proto not found in PATH"
          python3 --version || echo "⚠️  Python3 not found"

      - name: Run tests
        run: cargo test --verbose

  # 确保所有检查都通过（汇总 job）
  # 这个 job 依赖于 check-lint 和 tests，检查所有必需检查的状态
  # 如果任何检查失败，此 job 会失败，从而阻止 PR 合并
  # 注意：需要在 GitHub 仓库设置中配置分支保护规则，将此工作流设为必需的状态检查
  check-status:
    name: Run check-status
    runs-on: ubuntu-latest
    needs: [check-skip-ci, check-lint, tests]
    # 对于所有 PR 都运行此 job，包括版本更新分支和 [skip ci] 的情况
    # 这样 GitHub 会报告状态，满足分支保护规则的要求
    if: always()
    steps:
      - name: Check lint and test status
        id: status_check
        run: |
          set +e  # 允许错误继续执行，确保总是设置退出码

          # 获取所有相关 job 的结果
          SKIP_CI_RESULT="${{ needs.check-skip-ci.result }}"
          SKIP_CI_SHOULD_SKIP="${{ needs.check-skip-ci.outputs.should_skip }}"
          LINT_RESULT="${{ needs.check-lint.result }}"
          TEST_RESULT="${{ needs.tests.result }}"

          echo "=== Job Status Check ==="
          echo "Event: ${{ github.event_name }}"
          echo "PR Number: ${{ github.event.pull_request.number }}"
          echo "Head Ref: ${{ github.head_ref }}"
          echo "Base Ref: ${{ github.base_ref }}"
          echo "check-skip-ci result: $SKIP_CI_RESULT"
          echo "check-skip-ci should_skip: $SKIP_CI_SHOULD_SKIP"
          echo "check-lint result: $LINT_RESULT"
          echo "tests result: $TEST_RESULT"
          echo "========================"

          EXIT_CODE=0

          # 优先级1: 如果 check-lint 和 tests 都被跳过，说明应该跳过 CI
          # 这是最可靠的判断方式，因为即使 check-skip-ci 失败，这两个 job 的状态也能反映实际情况
          if [ "$LINT_RESULT" == "skipped" ] && [ "$TEST_RESULT" == "skipped" ]; then
            echo "✅ Both lint and test jobs were skipped"
            echo "   This PR does not require CI checks (likely contains [skip ci] or is a version bump branch)"
            EXIT_CODE=0
          # 优先级2: 如果 check-skip-ci 成功且 should_skip 为 true，直接通过
          elif [ "$SKIP_CI_RESULT" == "success" ] && [ "$SKIP_CI_SHOULD_SKIP" == "true" ]; then
            echo "✅ CI checks skipped (found [skip ci] or version bump branch)"
            echo "   This PR does not require CI checks"
            EXIT_CODE=0
          # 如果 check-skip-ci 失败，记录警告但继续检查其他结果
          elif [ "$SKIP_CI_RESULT" != "success" ] && [ "$SKIP_CI_RESULT" != "skipped" ] && [ -n "$SKIP_CI_RESULT" ]; then
            echo "⚠️  check-skip-ci job failed ($SKIP_CI_RESULT), but continuing with normal checks"
            # 继续检查其他结果
            if [ "$LINT_RESULT" != "success" ] && [ "$LINT_RESULT" != "skipped" ]; then
              echo "❌ Lint check failed: $LINT_RESULT"
              EXIT_CODE=1
            elif [ "$TEST_RESULT" != "success" ] && [ "$TEST_RESULT" != "skipped" ]; then
              echo "❌ Test check failed: $TEST_RESULT"
              EXIT_CODE=1
            else
              echo "✅ All checks passed (despite check-skip-ci failure)"
              EXIT_CODE=0
            fi
          # 检查是否有失败的检查（failure, cancelled, 等）
          elif [ "$LINT_RESULT" != "success" ] && [ "$LINT_RESULT" != "skipped" ]; then
            echo "❌ Lint check failed: $LINT_RESULT"
            EXIT_CODE=1
          elif [ "$TEST_RESULT" != "success" ] && [ "$TEST_RESULT" != "skipped" ]; then
            echo "❌ Test check failed: $TEST_RESULT"
            EXIT_CODE=1
          # 如果所有检查都成功或跳过，则通过
          else
            echo "✅ All checks passed!"
            EXIT_CODE=0
          fi

          echo "=== Final Status: $EXIT_CODE ==="
          exit $EXIT_CODE
