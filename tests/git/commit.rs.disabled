//! Git æäº¤ç®¡ç†æµ‹è¯•
//!
//! æµ‹è¯• Git æäº¤çŠ¶æ€æ£€æŸ¥ã€æš‚å­˜æ“ä½œå’Œæäº¤åˆ›å»ºåŠŸèƒ½ã€‚

use pretty_assertions::assert_eq;
use rstest::{fixture, rstest};
use std::fs;
use tempfile::TempDir;
use workflow::git::{GitCommit, WorktreeStatus};

// ==================== Fixtures ====================

/// åˆ›å»ºå¸¦æœ‰åˆå§‹æäº¤çš„ Git ä»“åº“
#[fixture]
fn git_repo_with_commit() -> TempDir {
    let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");

    std::env::set_current_dir(&temp_dir).expect("Failed to change dir");

    // åˆå§‹åŒ– Git ä»“åº“
    std::process::Command::new("git")
        .args(["init"])
        .output()
        .expect("Failed to init git repo");

    // é…ç½® Git ç”¨æˆ·
    std::process::Command::new("git")
        .args(["config", "user.name", "Test User"])
        .output()
        .expect("Failed to set git user name");

    std::process::Command::new("git")
        .args(["config", "user.email", "test@example.com"])
        .output()
        .expect("Failed to set git user email");

    // åˆ›å»ºåˆå§‹æäº¤
    fs::write("README.md", "# Test Repository").expect("Failed to write file");

    std::process::Command::new("git")
        .args(["add", "README.md"])
        .output()
        .expect("Failed to add file");

    std::process::Command::new("git")
        .args(["commit", "-m", "Initial commit"])
        .output()
        .expect("Failed to commit");

    temp_dir
}

/// åˆ›å»ºå¹²å‡€çš„ Git ä»“åº“ï¼ˆæ— æäº¤ï¼‰
#[fixture]
fn clean_git_repo() -> TempDir {
    let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");

    std::env::set_current_dir(&temp_dir).expect("Failed to change dir");

    // åˆå§‹åŒ– Git ä»“åº“
    std::process::Command::new("git")
        .args(["init"])
        .output()
        .expect("Failed to init git repo");

    // é…ç½® Git ç”¨æˆ·
    std::process::Command::new("git")
        .args(["config", "user.name", "Test User"])
        .output()
        .expect("Failed to set git user name");

    std::process::Command::new("git")
        .args(["config", "user.email", "test@example.com"])
        .output()
        .expect("Failed to set git user email");

    temp_dir
}

// ==================== å·¥ä½œæ ‘çŠ¶æ€æ£€æŸ¥æµ‹è¯• ====================

#[rstest]
fn test_worktree_status_clean(git_repo_with_commit: TempDir) {
    // æµ‹è¯•å¹²å‡€çš„å·¥ä½œæ ‘çŠ¶æ€
    let result = GitCommit::worktree_status();
    assert!(
        result.is_ok(),
        "Failed to get worktree status: {:?}",
        result
    );

    let status = result.unwrap();

    // å¹²å‡€çš„å·¥ä½œæ ‘åº”è¯¥æ²¡æœ‰æœªè·Ÿè¸ªæˆ–ä¿®æ”¹çš„æ–‡ä»¶
    assert!(
        status.untracked_files.is_empty(),
        "Expected no untracked files"
    );
    assert!(
        status.modified_files.is_empty(),
        "Expected no modified files"
    );
    assert!(status.staged_files.is_empty(), "Expected no staged files");
}

#[rstest]
fn test_worktree_status_with_untracked_files(git_repo_with_commit: TempDir) {
    // åˆ›å»ºæœªè·Ÿè¸ªçš„æ–‡ä»¶
    fs::write("untracked.txt", "This file is not tracked").expect("Failed to write file");

    let result = GitCommit::worktree_status();
    assert!(result.is_ok());

    let status = result.unwrap();

    // åº”è¯¥æ£€æµ‹åˆ°æœªè·Ÿè¸ªçš„æ–‡ä»¶
    assert!(
        !status.untracked_files.is_empty(),
        "Expected untracked files"
    );
    assert!(status.untracked_files.contains(&"untracked.txt".to_string()));
}

#[rstest]
fn test_worktree_status_with_modified_files(git_repo_with_commit: TempDir) {
    // ä¿®æ”¹å·²è·Ÿè¸ªçš„æ–‡ä»¶
    fs::write("README.md", "# Modified Test Repository").expect("Failed to write file");

    let result = GitCommit::worktree_status();
    assert!(result.is_ok());

    let status = result.unwrap();

    // åº”è¯¥æ£€æµ‹åˆ°ä¿®æ”¹çš„æ–‡ä»¶
    assert!(!status.modified_files.is_empty(), "Expected modified files");
    assert!(status.modified_files.contains(&"README.md".to_string()));
}

#[rstest]
fn test_worktree_status_with_staged_files(git_repo_with_commit: TempDir) {
    // åˆ›å»ºå¹¶æš‚å­˜æ–°æ–‡ä»¶
    fs::write("staged.txt", "This file is staged").expect("Failed to write file");

    std::process::Command::new("git")
        .args(["add", "staged.txt"])
        .output()
        .expect("Failed to stage file");

    let result = GitCommit::worktree_status();
    assert!(result.is_ok());

    let status = result.unwrap();

    // åº”è¯¥æ£€æµ‹åˆ°æš‚å­˜çš„æ–‡ä»¶
    assert!(!status.staged_files.is_empty(), "Expected staged files");
    assert!(status.staged_files.contains(&"staged.txt".to_string()));
}

#[rstest]
fn test_worktree_status_mixed_changes(git_repo_with_commit: TempDir) {
    // åˆ›å»ºæ··åˆçŠ¶æ€ï¼šæœªè·Ÿè¸ªã€ä¿®æ”¹ã€æš‚å­˜
    fs::write("untracked.txt", "Untracked file").expect("Failed to write file");
    fs::write("README.md", "# Modified README").expect("Failed to write file");
    fs::write("staged.txt", "Staged file").expect("Failed to write file");

    std::process::Command::new("git")
        .args(["add", "staged.txt"])
        .output()
        .expect("Failed to stage file");

    let result = GitCommit::worktree_status();
    assert!(result.is_ok());

    let status = result.unwrap();

    // éªŒè¯æ‰€æœ‰ç±»å‹çš„æ›´æ”¹éƒ½è¢«æ£€æµ‹åˆ°
    assert!(status.untracked_files.contains(&"untracked.txt".to_string()));
    assert!(status.modified_files.contains(&"README.md".to_string()));
    assert!(status.staged_files.contains(&"staged.txt".to_string()));
}

// ==================== æ›´æ”¹æ£€æŸ¥æµ‹è¯• ====================

#[rstest]
fn test_has_changes_clean_repo(git_repo_with_commit: TempDir) {
    // å¹²å‡€çš„ä»“åº“åº”è¯¥æ²¡æœ‰æ›´æ”¹
    let result = GitCommit::has_changes();
    assert!(result.is_ok());
    assert!(!result.unwrap(), "Clean repo should have no changes");
}

#[rstest]
fn test_has_changes_with_untracked_files(git_repo_with_commit: TempDir) {
    // åˆ›å»ºæœªè·Ÿè¸ªæ–‡ä»¶
    fs::write("new_file.txt", "New content").expect("Failed to write file");

    let result = GitCommit::has_changes();
    assert!(result.is_ok());
    assert!(
        result.unwrap(),
        "Repo with untracked files should have changes"
    );
}

#[rstest]
fn test_has_changes_with_modified_files(git_repo_with_commit: TempDir) {
    // ä¿®æ”¹ç°æœ‰æ–‡ä»¶
    fs::write("README.md", "# Updated README").expect("Failed to write file");

    let result = GitCommit::has_changes();
    assert!(result.is_ok());
    assert!(
        result.unwrap(),
        "Repo with modified files should have changes"
    );
}

// ==================== æš‚å­˜æ“ä½œæµ‹è¯• ====================

#[rstest]
fn test_stage_all_changes(git_repo_with_commit: TempDir) {
    // åˆ›å»ºä¸€äº›æ›´æ”¹
    fs::write("new_file.txt", "New file content").expect("Failed to write file");
    fs::write("README.md", "# Updated README").expect("Failed to write file");

    // æš‚å­˜æ‰€æœ‰æ›´æ”¹
    let result = GitCommit::stage_all();
    assert!(result.is_ok(), "Failed to stage all changes: {:?}", result);

    // éªŒè¯æ–‡ä»¶å·²æš‚å­˜
    let status = GitCommit::worktree_status().expect("Failed to get status");
    assert!(status.staged_files.contains(&"new_file.txt".to_string()));
    assert!(status.staged_files.contains(&"README.md".to_string()));
}

#[rstest]
fn test_stage_specific_file(git_repo_with_commit: TempDir) {
    // åˆ›å»ºå¤šä¸ªæ–‡ä»¶
    fs::write("file1.txt", "Content 1").expect("Failed to write file");
    fs::write("file2.txt", "Content 2").expect("Failed to write file");

    // åªæš‚å­˜ä¸€ä¸ªæ–‡ä»¶
    let result = GitCommit::stage_file("file1.txt");
    assert!(result.is_ok(), "Failed to stage file: {:?}", result);

    // éªŒè¯åªæœ‰æŒ‡å®šæ–‡ä»¶è¢«æš‚å­˜
    let status = GitCommit::worktree_status().expect("Failed to get status");
    assert!(status.staged_files.contains(&"file1.txt".to_string()));
    assert!(status.untracked_files.contains(&"file2.txt".to_string()));
}

#[rstest]
fn test_stage_nonexistent_file(git_repo_with_commit: TempDir) {
    // å°è¯•æš‚å­˜ä¸å­˜åœ¨çš„æ–‡ä»¶
    let result = GitCommit::stage_file("nonexistent.txt");
    assert!(result.is_err(), "Staging nonexistent file should fail");
}

// ==================== æäº¤åˆ›å»ºæµ‹è¯• ====================

#[rstest]
fn test_create_commit_with_staged_changes(git_repo_with_commit: TempDir) {
    // åˆ›å»ºå¹¶æš‚å­˜æ›´æ”¹
    fs::write("feature.txt", "New feature implementation").expect("Failed to write file");
    GitCommit::stage_file("feature.txt").expect("Failed to stage file");

    // åˆ›å»ºæäº¤
    let commit_message = "Add new feature";
    let result = GitCommit::commit(commit_message);
    assert!(result.is_ok(), "Failed to create commit: {:?}", result);

    // éªŒè¯æäº¤å·²åˆ›å»ºï¼ˆå·¥ä½œæ ‘åº”è¯¥æ˜¯å¹²å‡€çš„ï¼‰
    let has_changes = GitCommit::has_changes().expect("Failed to check changes");
    assert!(!has_changes, "Worktree should be clean after commit");
}

#[rstest]
fn test_create_commit_without_staged_changes(git_repo_with_commit: TempDir) {
    // å°è¯•åœ¨æ²¡æœ‰æš‚å­˜æ›´æ”¹çš„æƒ…å†µä¸‹æäº¤
    let result = GitCommit::commit("Empty commit");
    assert!(result.is_err(), "Commit without staged changes should fail");
}

#[rstest]
fn test_create_commit_with_empty_message(git_repo_with_commit: TempDir) {
    // åˆ›å»ºå¹¶æš‚å­˜æ›´æ”¹
    fs::write("test.txt", "Test content").expect("Failed to write file");
    GitCommit::stage_file("test.txt").expect("Failed to stage file");

    // å°è¯•ä½¿ç”¨ç©ºæäº¤æ¶ˆæ¯
    let result = GitCommit::commit("");
    assert!(result.is_err(), "Commit with empty message should fail");
}

// ==================== æäº¤ä¿¡æ¯è·å–æµ‹è¯• ====================

#[rstest]
fn test_get_latest_commit_info(git_repo_with_commit: TempDir) {
    let result = GitCommit::get_latest_commit_info();
    assert!(
        result.is_ok(),
        "Failed to get latest commit info: {:?}",
        result
    );

    let commit_info = result.unwrap();

    // éªŒè¯æäº¤ä¿¡æ¯çš„åŸºæœ¬å­—æ®µ
    assert!(
        !commit_info.hash.is_empty(),
        "Commit hash should not be empty"
    );
    assert!(!commit_info.author.is_empty(), "Author should not be empty");
    assert!(
        !commit_info.message.is_empty(),
        "Message should not be empty"
    );
    assert_eq!(commit_info.message, "Initial commit");
}

#[rstest]
fn test_get_commit_info_empty_repo(clean_git_repo: TempDir) {
    // åœ¨æ²¡æœ‰æäº¤çš„ä»“åº“ä¸­è·å–æäº¤ä¿¡æ¯åº”è¯¥å¤±è´¥
    let result = GitCommit::get_latest_commit_info();
    assert!(
        result.is_err(),
        "Getting commit info from empty repo should fail"
    );
}

// ==================== WorktreeStatus ç»“æ„ä½“æµ‹è¯• ====================

#[test]
fn test_worktree_status_default() {
    // æµ‹è¯• WorktreeStatus çš„é»˜è®¤å€¼
    let status = WorktreeStatus::default();

    assert!(status.untracked_files.is_empty());
    assert!(status.modified_files.is_empty());
    assert!(status.staged_files.is_empty());
}

#[test]
fn test_worktree_status_has_changes() {
    // æµ‹è¯• has_changes æ–¹æ³•
    let mut status = WorktreeStatus::default();
    assert!(!status.has_changes());

    status.untracked_files.push("file1.txt".to_string());
    assert!(status.has_changes());

    status = WorktreeStatus::default();
    status.modified_files.push("file2.txt".to_string());
    assert!(status.has_changes());

    status = WorktreeStatus::default();
    status.staged_files.push("file3.txt".to_string());
    assert!(status.has_changes());
}

// ==================== è¾¹ç•Œæ¡ä»¶æµ‹è¯• ====================

#[rstest]
fn test_very_long_commit_message(git_repo_with_commit: TempDir) {
    // åˆ›å»ºå¹¶æš‚å­˜æ›´æ”¹
    fs::write("test.txt", "Test content").expect("Failed to write file");
    GitCommit::stage_file("test.txt").expect("Failed to stage file");

    // æµ‹è¯•å¾ˆé•¿çš„æäº¤æ¶ˆæ¯
    let long_message = "A".repeat(1000);
    let result = GitCommit::commit(&long_message);

    // å¾ˆé•¿çš„æäº¤æ¶ˆæ¯åº”è¯¥è¢«æ¥å—
    assert!(result.is_ok(), "Long commit message should be accepted");
}

#[rstest]
fn test_commit_message_with_special_characters(git_repo_with_commit: TempDir) {
    // åˆ›å»ºå¹¶æš‚å­˜æ›´æ”¹
    fs::write("test.txt", "Test content").expect("Failed to write file");
    GitCommit::stage_file("test.txt").expect("Failed to stage file");

    // æµ‹è¯•åŒ…å«ç‰¹æ®Šå­—ç¬¦çš„æäº¤æ¶ˆæ¯
    let special_message = "Fix: ä¿®å¤äº†ä¸€ä¸ª bug ğŸ› (issue #123)";
    let result = GitCommit::commit(special_message);

    assert!(
        result.is_ok(),
        "Commit message with special characters should be accepted"
    );
}

#[rstest]
fn test_stage_file_with_spaces(git_repo_with_commit: TempDir) {
    // åˆ›å»ºæ–‡ä»¶ååŒ…å«ç©ºæ ¼çš„æ–‡ä»¶
    let filename = "file with spaces.txt";
    fs::write(filename, "Content").expect("Failed to write file");

    // æš‚å­˜æ–‡ä»¶
    let result = GitCommit::stage_file(filename);
    assert!(
        result.is_ok(),
        "Should be able to stage file with spaces in name"
    );

    // éªŒè¯æ–‡ä»¶å·²æš‚å­˜
    let status = GitCommit::worktree_status().expect("Failed to get status");
    assert!(status.staged_files.contains(&filename.to_string()));
}

// ==================== é”™è¯¯å¤„ç†æµ‹è¯• ====================

#[test]
fn test_operations_outside_git_repo() {
    // åœ¨é Git ç›®å½•ä¸­æµ‹è¯•æ“ä½œ
    let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");
    std::env::set_current_dir(&temp_dir).expect("Failed to change dir");

    // æ‰€æœ‰ Git æ“ä½œéƒ½åº”è¯¥å¤±è´¥
    assert!(GitCommit::worktree_status().is_err());
    assert!(GitCommit::has_changes().is_err());
    assert!(GitCommit::stage_all().is_err());
    assert!(GitCommit::commit("test").is_err());
    assert!(GitCommit::get_latest_commit_info().is_err());
}

// ==================== é›†æˆæµ‹è¯• ====================

#[rstest]
fn test_complete_commit_workflow(git_repo_with_commit: TempDir) {
    // 1. éªŒè¯åˆå§‹çŠ¶æ€æ˜¯å¹²å‡€çš„
    let initial_status = GitCommit::worktree_status().expect("Failed to get status");
    assert!(!initial_status.has_changes());

    // 2. åˆ›å»ºä¸€äº›æ›´æ”¹
    fs::write("feature1.txt", "Feature 1 implementation").expect("Failed to write file");
    fs::write("feature2.txt", "Feature 2 implementation").expect("Failed to write file");
    fs::write("README.md", "# Updated README with new features").expect("Failed to write file");

    // 3. éªŒè¯æœ‰æœªæš‚å­˜çš„æ›´æ”¹
    assert!(GitCommit::has_changes().expect("Failed to check changes"));

    // 4. æš‚å­˜æ‰€æœ‰æ›´æ”¹
    GitCommit::stage_all().expect("Failed to stage all");

    // 5. éªŒè¯æ›´æ”¹å·²æš‚å­˜
    let staged_status = GitCommit::worktree_status().expect("Failed to get status");
    assert!(staged_status.staged_files.len() >= 3);

    // 6. åˆ›å»ºæäº¤
    let commit_message = "Add new features and update README";
    GitCommit::commit(commit_message).expect("Failed to commit");

    // 7. éªŒè¯å·¥ä½œæ ‘ç°åœ¨æ˜¯å¹²å‡€çš„
    assert!(!GitCommit::has_changes().expect("Failed to check changes"));

    // 8. éªŒè¯æäº¤ä¿¡æ¯
    let commit_info = GitCommit::get_latest_commit_info().expect("Failed to get commit info");
    assert_eq!(commit_info.message, commit_message);
}

// ==================== æ€§èƒ½æµ‹è¯• ====================

#[rstest]
fn test_status_check_performance(git_repo_with_commit: TempDir) {
    use std::time::Instant;

    // åˆ›å»ºä¸€äº›æ–‡ä»¶
    for i in 0..10 {
        fs::write(format!("file_{}.txt", i), format!("Content {}", i))
            .expect("Failed to write file");
    }

    let start = Instant::now();

    // æ‰§è¡Œå¤šæ¬¡çŠ¶æ€æ£€æŸ¥
    for _ in 0..5 {
        let _ = GitCommit::worktree_status();
        let _ = GitCommit::has_changes();
    }

    let duration = start.elapsed();

    // çŠ¶æ€æ£€æŸ¥åº”è¯¥ç›¸å¯¹å¿«é€Ÿ
    assert!(
        duration.as_millis() < 1000,
        "Status checks too slow: {:?}",
        duration
    );
}
