//! 回滚模块集成测试
//!
//! 测试回滚模块的端到端功能和与其他模块的集成。

use pretty_assertions::assert_eq;
use rstest::{fixture, rstest};
use std::fs;
use std::path::PathBuf;
use tempfile::TempDir;
use workflow::rollback::{BackupInfo, RollbackManager};

// ==================== Fixtures ====================

/// 创建完整的测试环境
#[fixture]
fn test_environment() -> TempDir {
    let temp_dir = tempfile::tempdir().expect("Failed to create temp dir");

    // 创建模拟的系统目录结构
    let bin_dir = temp_dir.path().join("usr/local/bin");
    let completion_dir = temp_dir.path().join("usr/local/share/bash-completion/completions");

    fs::create_dir_all(&bin_dir).expect("Failed to create bin dir");
    fs::create_dir_all(&completion_dir).expect("Failed to create completion dir");

    // 创建模拟的二进制文件
    for binary in &["workflow", "wf"] {
        let binary_path = bin_dir.join(binary);
        fs::write(
            &binary_path,
            format!("#!/bin/bash\necho 'Original {}'", binary),
        )
        .expect("Failed to write binary");

        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = fs::metadata(&binary_path).unwrap().permissions();
            perms.set_mode(0o755);
            fs::set_permissions(&binary_path, perms).unwrap();
        }
    }

    // 创建模拟的补全脚本
    for completion in &["workflow", "_workflow"] {
        let completion_path = completion_dir.join(completion);
        fs::write(
            &completion_path,
            format!("# Original completion for {}", completion),
        )
        .expect("Failed to write completion");
    }

    temp_dir
}

/// 创建更新后的文件内容
fn create_updated_files(test_env: &TempDir) {
    let bin_dir = test_env.path().join("usr/local/bin");
    let completion_dir = test_env.path().join("usr/local/share/bash-completion/completions");

    // 更新二进制文件
    for binary in &["workflow", "wf"] {
        let binary_path = bin_dir.join(binary);
        fs::write(
            &binary_path,
            format!("#!/bin/bash\necho 'Updated {}'", binary),
        )
        .expect("Failed to update binary");
    }

    // 更新补全脚本
    for completion in &["workflow", "_workflow"] {
        let completion_path = completion_dir.join(completion);
        fs::write(
            &completion_path,
            format!("# Updated completion for {}", completion),
        )
        .expect("Failed to update completion");
    }
}

/// 验证文件内容
fn verify_file_content(path: &PathBuf, expected_content: &str) -> bool {
    if let Ok(content) = fs::read_to_string(path) {
        content.contains(expected_content)
    } else {
        false
    }
}

// ==================== 完整工作流集成测试 ====================

#[rstest]
fn test_complete_backup_update_rollback_workflow(test_environment: TempDir) {
    /// 测试完整的备份-更新-回滚工作流
    let bin_dir = test_environment.path().join("usr/local/bin");
    let completion_dir =
        test_environment.path().join("usr/local/share/bash-completion/completions");

    // 1. 验证原始文件存在且内容正确
    let workflow_binary = bin_dir.join("workflow");
    let workflow_completion = completion_dir.join("workflow");

    assert!(workflow_binary.exists());
    assert!(workflow_completion.exists());
    assert!(verify_file_content(&workflow_binary, "Original workflow"));
    assert!(verify_file_content(
        &workflow_completion,
        "Original completion"
    ));

    // 2. 执行备份
    let binaries = vec!["workflow", "wf"];
    let completions = vec!["workflow", "_workflow"];

    let backup_result = RollbackManager::backup(&binaries, &completions);

    match backup_result {
        Ok(backup_result) => {
            // 验证备份结果
            assert!(backup_result.binary_count > 0 || backup_result.binary_count == 0); // 取决于实现
            assert!(backup_result.completion_count > 0 || backup_result.completion_count == 0);

            // 3. 模拟更新操作（修改文件内容）
            create_updated_files(&test_environment);

            // 验证文件已被更新
            assert!(verify_file_content(&workflow_binary, "Updated workflow"));
            assert!(verify_file_content(
                &workflow_completion,
                "Updated completion"
            ));

            // 4. 执行回滚
            let rollback_result = RollbackManager::rollback(&backup_result.backup_info);

            match rollback_result {
                Ok(rollback_result) => {
                    // 验证回滚结果
                    println!("Rollback completed:");
                    println!(
                        "  Restored binaries: {:?}",
                        rollback_result.restored_binaries
                    );
                    println!(
                        "  Restored completions: {:?}",
                        rollback_result.restored_completions
                    );
                    println!("  Failed binaries: {:?}", rollback_result.failed_binaries);
                    println!(
                        "  Failed completions: {:?}",
                        rollback_result.failed_completions
                    );

                    // 5. 清理备份
                    let cleanup_result = RollbackManager::cleanup(&backup_result.backup_info);

                    match cleanup_result {
                        Ok(_) => {
                            println!("Cleanup completed successfully");
                        }
                        Err(e) => {
                            println!("Cleanup failed: {}", e);
                        }
                    }
                }
                Err(e) => {
                    println!("Rollback failed: {}", e);
                }
            }
        }
        Err(e) => {
            println!("Backup failed: {}", e);
        }
    }
}

// ==================== 部分失败场景测试 ====================

#[rstest]
fn test_partial_backup_scenario(test_environment: TempDir) {
    /// 测试部分备份场景（某些文件不存在）
    // 包含存在和不存在的文件
    let binaries = vec!["workflow", "nonexistent_binary"];
    let completions = vec!["workflow", "nonexistent_completion"];

    let backup_result = RollbackManager::backup(&binaries, &completions);

    match backup_result {
        Ok(backup_result) => {
            // 部分备份应该成功
            println!("Partial backup completed:");
            println!("  Binary count: {}", backup_result.binary_count);
            println!("  Completion count: {}", backup_result.completion_count);

            // 尝试回滚
            let rollback_result = RollbackManager::rollback(&backup_result.backup_info);

            match rollback_result {
                Ok(rollback_result) => {
                    println!("Partial rollback completed:");
                    println!(
                        "  Restored: {} binaries, {} completions",
                        rollback_result.restored_binaries.len(),
                        rollback_result.restored_completions.len()
                    );
                }
                Err(e) => {
                    println!("Partial rollback failed: {}", e);
                }
            }
        }
        Err(e) => {
            println!("Partial backup failed: {}", e);
        }
    }
}

// ==================== 权限和访问测试 ====================

#[test]
fn test_backup_with_permission_issues() {
    /// 测试权限问题的处理
    // 尝试备份系统目录中的文件（可能没有权限）
    let system_binaries = vec!["ls", "cat", "echo"]; // 系统二进制文件
    let system_completions = vec!["bash_completion"]; // 系统补全脚本

    let backup_result = RollbackManager::backup(&system_binaries, &system_completions);

    match backup_result {
        Ok(backup_result) => {
            println!("System backup completed (unexpected):");
            println!("  Binary count: {}", backup_result.binary_count);
            println!("  Completion count: {}", backup_result.completion_count);
        }
        Err(e) => {
            println!("System backup failed as expected: {}", e);
        }
    }
}

// ==================== 并发安全测试 ====================

#[test]
fn test_concurrent_backup_operations() {
    use std::sync::Arc;
    /// 测试并发备份操作的安全性
    use std::thread;

    let binaries = Arc::new(vec!["test_binary"]);
    let completions = Arc::new(vec!["test_completion.sh"]);

    let mut handles = vec![];

    // 启动多个并发备份操作
    for i in 0..5 {
        let binaries_clone = Arc::clone(&binaries);
        let completions_clone = Arc::clone(&completions);

        let handle = thread::spawn(move || {
            let result = RollbackManager::backup(&binaries_clone, &completions_clone);
            println!("Concurrent backup {} result: {:?}", i, result.is_ok());
            result
        });

        handles.push(handle);
    }

    // 等待所有线程完成
    let mut success_count = 0;
    for handle in handles {
        match handle.join() {
            Ok(result) => {
                if result.is_ok() {
                    success_count += 1;
                }
            }
            Err(e) => {
                println!("Thread panicked: {:?}", e);
            }
        }
    }

    println!(
        "Concurrent operations completed: {} successful",
        success_count
    );
}

// ==================== 资源清理测试 ====================

#[rstest]
fn test_resource_cleanup_after_failure(test_environment: TempDir) {
    /// 测试失败后的资源清理
    let binaries = vec!["workflow"];
    let completions = vec!["workflow"];

    // 执行备份
    let backup_result = RollbackManager::backup(&binaries, &completions);

    match backup_result {
        Ok(backup_result) => {
            // 人为破坏备份目录（模拟异常情况）
            let backup_dir = &backup_result.backup_info.backup_dir;
            if backup_dir.exists() {
                // 删除备份目录中的某些文件
                if let Ok(entries) = fs::read_dir(backup_dir) {
                    for entry in entries.flatten() {
                        let _ = fs::remove_file(entry.path());
                    }
                }
            }

            // 尝试回滚（应该处理缺失的备份文件）
            let rollback_result = RollbackManager::rollback(&backup_result.backup_info);

            match rollback_result {
                Ok(rollback_result) => {
                    println!("Rollback with missing files:");
                    println!("  Failed binaries: {:?}", rollback_result.failed_binaries);
                    println!(
                        "  Failed completions: {:?}",
                        rollback_result.failed_completions
                    );
                }
                Err(e) => {
                    println!("Rollback failed as expected: {}", e);
                }
            }

            // 清理（应该处理已损坏的备份）
            let cleanup_result = RollbackManager::cleanup(&backup_result.backup_info);

            match cleanup_result {
                Ok(_) => {
                    println!("Cleanup after failure completed");
                }
                Err(e) => {
                    println!("Cleanup after failure failed: {}", e);
                }
            }
        }
        Err(e) => {
            println!("Initial backup failed: {}", e);
        }
    }
}

// ==================== 性能和压力测试 ====================

#[test]
fn test_large_scale_operations() {
    /// 测试大规模操作的性能
    let mut large_binaries = Vec::new();
    let mut large_completions = Vec::new();

    // 生成大量文件名
    for i in 0..100 {
        large_binaries.push(format!("binary_{}", i));
        large_completions.push(format!("completion_{}.sh", i));
    }

    let start_time = std::time::Instant::now();

    let backup_result = RollbackManager::backup(&large_binaries, &large_completions);

    let backup_duration = start_time.elapsed();
    println!("Large scale backup took: {:?}", backup_duration);

    match backup_result {
        Ok(backup_result) => {
            let rollback_start = std::time::Instant::now();

            let rollback_result = RollbackManager::rollback(&backup_result.backup_info);

            let rollback_duration = rollback_start.elapsed();
            println!("Large scale rollback took: {:?}", rollback_duration);

            match rollback_result {
                Ok(_) => {
                    let cleanup_start = std::time::Instant::now();

                    let _ = RollbackManager::cleanup(&backup_result.backup_info);

                    let cleanup_duration = cleanup_start.elapsed();
                    println!("Large scale cleanup took: {:?}", cleanup_duration);
                }
                Err(e) => {
                    println!("Large scale rollback failed: {}", e);
                }
            }
        }
        Err(e) => {
            println!("Large scale backup failed: {}", e);
        }
    }
}

// ==================== 边界条件集成测试 ====================

#[test]
fn test_edge_cases_integration() {
    /// 测试各种边界条件的集成场景
    let test_cases = vec![
        // (描述, 二进制文件列表, 补全脚本列表)
        ("Empty lists", vec![], vec![]),
        ("Only binaries", vec!["test"], vec![]),
        ("Only completions", vec![], vec!["test.sh"]),
        ("Single files", vec!["single"], vec!["single.sh"]),
        (
            "Special characters",
            vec!["test-binary_123"],
            vec!["test-completion_456.sh"],
        ),
    ];

    for (description, binaries, completions) in test_cases {
        println!("Testing edge case: {}", description);

        let backup_result = RollbackManager::backup(&binaries, &completions);

        match backup_result {
            Ok(backup_result) => {
                println!(
                    "  Backup successful: {} binaries, {} completions",
                    backup_result.binary_count, backup_result.completion_count
                );

                // 尝试回滚
                let rollback_result = RollbackManager::rollback(&backup_result.backup_info);

                match rollback_result {
                    Ok(_) => {
                        println!("  Rollback successful");
                    }
                    Err(e) => {
                        println!("  Rollback failed: {}", e);
                    }
                }

                // 清理
                let _ = RollbackManager::cleanup(&backup_result.backup_info);
            }
            Err(e) => {
                println!("  Backup failed: {}", e);
            }
        }
    }
}

// ==================== 错误恢复集成测试 ====================

#[test]
fn test_error_recovery_integration() {
    /// 测试错误恢复的集成场景
    // 测试各种可能导致错误的情况
    let error_scenarios = vec![
        vec![""], // 空字符串文件名
        vec!["../../../etc/passwd"], // 危险路径
        vec!["file\0with\0null"], // 包含空字节的文件名
        vec!["very_long_filename_that_exceeds_normal_filesystem_limits_and_might_cause_issues_with_path_handling_in_various_operating_systems"], // 超长文件名
    ];

    for (i, scenario) in error_scenarios.iter().enumerate() {
        println!("Testing error scenario {}: {:?}", i + 1, scenario);

        let backup_result = RollbackManager::backup(scenario, &[]);

        match backup_result {
            Ok(backup_result) => {
                println!("  Unexpected success for error scenario");

                // 如果备份成功，尝试回滚和清理
                let _ = RollbackManager::rollback(&backup_result.backup_info);
                let _ = RollbackManager::cleanup(&backup_result.backup_info);
            }
            Err(e) => {
                println!("  Error handled appropriately: {}", e);
            }
        }
    }
}
