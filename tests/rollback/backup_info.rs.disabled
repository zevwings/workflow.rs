//! 备份信息测试
//!
//! 测试备份信息结构体的创建、管理和序列化功能。

use pretty_assertions::assert_eq;
use rstest::{fixture, rstest};
use std::path::PathBuf;
use workflow::rollback::{BackupInfo, BackupResult, RollbackResult};

// ==================== Fixtures ====================

/// 创建测试用的备份目录路径
#[fixture]
fn sample_backup_dir() -> PathBuf {
    PathBuf::from("/tmp/workflow-backup-test")
}

/// 创建测试用的备份信息
#[fixture]
fn sample_backup_info(sample_backup_dir: PathBuf) -> BackupInfo {
    BackupInfo {
        backup_dir: sample_backup_dir.clone(),
        binary_backups: vec![
            (
                "workflow".to_string(),
                sample_backup_dir.join("workflow.bak"),
            ),
            ("wf".to_string(), sample_backup_dir.join("wf.bak")),
        ],
        completion_backups: vec![
            (
                "workflow.bash".to_string(),
                sample_backup_dir.join("workflow.bash.bak"),
            ),
            (
                "workflow.zsh".to_string(),
                sample_backup_dir.join("workflow.zsh.bak"),
            ),
        ],
    }
}

// ==================== BackupInfo 基础测试 ====================

#[rstest]
fn test_backup_info_creation(sample_backup_dir: PathBuf) {
    /// 测试备份信息的创建
    let backup_info = BackupInfo {
        backup_dir: sample_backup_dir.clone(),
        binary_backups: vec![],
        completion_backups: vec![],
    };

    assert_eq!(backup_info.backup_dir, sample_backup_dir);
    assert!(backup_info.binary_backups.is_empty());
    assert!(backup_info.completion_backups.is_empty());
}

#[rstest]
fn test_backup_info_with_backups(sample_backup_info: BackupInfo) {
    /// 测试包含备份文件的备份信息
    assert_eq!(sample_backup_info.binary_backups.len(), 2);
    assert_eq!(sample_backup_info.completion_backups.len(), 2);

    // 验证二进制文件备份
    let (binary_name, binary_path) = &sample_backup_info.binary_backups[0];
    assert_eq!(binary_name, "workflow");
    assert!(binary_path.to_string_lossy().contains("workflow.bak"));

    // 验证补全脚本备份
    let (completion_name, completion_path) = &sample_backup_info.completion_backups[0];
    assert_eq!(completion_name, "workflow.bash");
    assert!(completion_path.to_string_lossy().contains("workflow.bash.bak"));
}

#[test]
fn test_backup_info_clone() {
    /// 测试备份信息的克隆
    let original = BackupInfo {
        backup_dir: PathBuf::from("/test/backup"),
        binary_backups: vec![("test".to_string(), PathBuf::from("/test/test.bak"))],
        completion_backups: vec![("test.sh".to_string(), PathBuf::from("/test/test.sh.bak"))],
    };

    let cloned = original.clone();

    assert_eq!(cloned.backup_dir, original.backup_dir);
    assert_eq!(cloned.binary_backups, original.binary_backups);
    assert_eq!(cloned.completion_backups, original.completion_backups);
}

#[test]
fn test_backup_info_debug() {
    /// 测试备份信息的 Debug 输出
    let backup_info = BackupInfo {
        backup_dir: PathBuf::from("/debug/test"),
        binary_backups: vec![("debug".to_string(), PathBuf::from("/debug/debug.bak"))],
        completion_backups: vec![],
    };

    let debug_output = format!("{:?}", backup_info);

    assert!(debug_output.contains("BackupInfo"));
    assert!(debug_output.contains("/debug/test"));
    assert!(debug_output.contains("debug"));
}

// ==================== BackupResult 测试 ====================

#[rstest]
fn test_backup_result_creation(sample_backup_info: BackupInfo) {
    /// 测试备份结果的创建
    let backup_result = BackupResult {
        backup_info: sample_backup_info.clone(),
        binary_count: 2,
        completion_count: 2,
    };

    assert_eq!(backup_result.binary_count, 2);
    assert_eq!(backup_result.completion_count, 2);
    assert_eq!(
        backup_result.backup_info.backup_dir,
        sample_backup_info.backup_dir
    );
}

#[test]
fn test_backup_result_empty() {
    /// 测试空的备份结果
    let backup_result = BackupResult {
        backup_info: BackupInfo {
            backup_dir: PathBuf::from("/empty/backup"),
            binary_backups: vec![],
            completion_backups: vec![],
        },
        binary_count: 0,
        completion_count: 0,
    };

    assert_eq!(backup_result.binary_count, 0);
    assert_eq!(backup_result.completion_count, 0);
    assert!(backup_result.backup_info.binary_backups.is_empty());
    assert!(backup_result.backup_info.completion_backups.is_empty());
}

#[rstest]
#[case(0, 0)]
#[case(1, 0)]
#[case(0, 1)]
#[case(5, 3)]
#[case(10, 10)]
fn test_backup_result_parametrized(#[case] binary_count: usize, #[case] completion_count: usize) {
    /// 参数化测试备份结果的各种计数组合
    let backup_result = BackupResult {
        backup_info: BackupInfo {
            backup_dir: PathBuf::from("/param/test"),
            binary_backups: vec![],
            completion_backups: vec![],
        },
        binary_count,
        completion_count,
    };

    assert_eq!(backup_result.binary_count, binary_count);
    assert_eq!(backup_result.completion_count, completion_count);
}

#[test]
fn test_backup_result_clone() {
    /// 测试备份结果的克隆
    let original = BackupResult {
        backup_info: BackupInfo {
            backup_dir: PathBuf::from("/clone/test"),
            binary_backups: vec![("test".to_string(), PathBuf::from("/clone/test.bak"))],
            completion_backups: vec![],
        },
        binary_count: 1,
        completion_count: 0,
    };

    let cloned = original.clone();

    assert_eq!(cloned.binary_count, original.binary_count);
    assert_eq!(cloned.completion_count, original.completion_count);
    assert_eq!(
        cloned.backup_info.backup_dir,
        original.backup_info.backup_dir
    );
}

// ==================== RollbackResult 测试 ====================

#[test]
fn test_rollback_result_creation() {
    /// 测试回滚结果的创建
    let rollback_result = RollbackResult {
        restored_binaries: vec!["workflow".to_string(), "wf".to_string()],
        restored_completions: vec!["workflow.bash".to_string()],
        failed_binaries: vec![("failed_binary".to_string(), "Permission denied".to_string())],
        failed_completions: vec![],
        shell_reload_success: Some(true),
        shell_config_file: Some(PathBuf::from("/home/user/.bashrc")),
    };

    assert_eq!(rollback_result.restored_binaries.len(), 2);
    assert_eq!(rollback_result.restored_completions.len(), 1);
    assert_eq!(rollback_result.failed_binaries.len(), 1);
    assert_eq!(rollback_result.failed_completions.len(), 0);
    assert_eq!(rollback_result.shell_reload_success, Some(true));
    assert!(rollback_result.shell_config_file.is_some());
}

#[test]
fn test_rollback_result_empty() {
    /// 测试空的回滚结果
    let rollback_result = RollbackResult {
        restored_binaries: vec![],
        restored_completions: vec![],
        failed_binaries: vec![],
        failed_completions: vec![],
        shell_reload_success: None,
        shell_config_file: None,
    };

    assert!(rollback_result.restored_binaries.is_empty());
    assert!(rollback_result.restored_completions.is_empty());
    assert!(rollback_result.failed_binaries.is_empty());
    assert!(rollback_result.failed_completions.is_empty());
    assert_eq!(rollback_result.shell_reload_success, None);
    assert_eq!(rollback_result.shell_config_file, None);
}

#[test]
fn test_rollback_result_partial_success() {
    /// 测试部分成功的回滚结果
    let rollback_result = RollbackResult {
        restored_binaries: vec!["workflow".to_string()],
        restored_completions: vec![],
        failed_binaries: vec![("wf".to_string(), "File not found".to_string())],
        failed_completions: vec![("workflow.zsh".to_string(), "Permission denied".to_string())],
        shell_reload_success: Some(false),
        shell_config_file: Some(PathBuf::from("/home/user/.zshrc")),
    };

    // 验证部分成功的情况
    assert_eq!(rollback_result.restored_binaries.len(), 1);
    assert_eq!(rollback_result.restored_completions.len(), 0);
    assert_eq!(rollback_result.failed_binaries.len(), 1);
    assert_eq!(rollback_result.failed_completions.len(), 1);
    assert_eq!(rollback_result.shell_reload_success, Some(false));

    // 验证错误信息
    let (failed_binary, binary_error) = &rollback_result.failed_binaries[0];
    assert_eq!(failed_binary, "wf");
    assert_eq!(binary_error, "File not found");

    let (failed_completion, completion_error) = &rollback_result.failed_completions[0];
    assert_eq!(failed_completion, "workflow.zsh");
    assert_eq!(completion_error, "Permission denied");
}

#[test]
fn test_rollback_result_clone() {
    /// 测试回滚结果的克隆
    let original = RollbackResult {
        restored_binaries: vec!["test".to_string()],
        restored_completions: vec!["test.sh".to_string()],
        failed_binaries: vec![],
        failed_completions: vec![],
        shell_reload_success: Some(true),
        shell_config_file: Some(PathBuf::from("/test/.bashrc")),
    };

    let cloned = original.clone();

    assert_eq!(cloned.restored_binaries, original.restored_binaries);
    assert_eq!(cloned.restored_completions, original.restored_completions);
    assert_eq!(cloned.failed_binaries, original.failed_binaries);
    assert_eq!(cloned.failed_completions, original.failed_completions);
    assert_eq!(cloned.shell_reload_success, original.shell_reload_success);
    assert_eq!(cloned.shell_config_file, original.shell_config_file);
}

#[test]
fn test_rollback_result_debug() {
    /// 测试回滚结果的 Debug 输出
    let rollback_result = RollbackResult {
        restored_binaries: vec!["debug_binary".to_string()],
        restored_completions: vec![],
        failed_binaries: vec![],
        failed_completions: vec![],
        shell_reload_success: Some(true),
        shell_config_file: None,
    };

    let debug_output = format!("{:?}", rollback_result);

    assert!(debug_output.contains("RollbackResult"));
    assert!(debug_output.contains("debug_binary"));
    assert!(debug_output.contains("true"));
}

// ==================== 边界条件和特殊情况测试 ====================

#[test]
fn test_backup_info_with_long_paths() {
    /// 测试包含长路径的备份信息
    let long_path = "/very/long/path/to/backup/directory/with/many/nested/subdirectories/and/a/very/long/filename";

    let backup_info = BackupInfo {
        backup_dir: PathBuf::from(long_path),
        binary_backups: vec![(
            "binary_with_very_long_name".to_string(),
            PathBuf::from(format!("{}/binary_with_very_long_name.backup", long_path)),
        )],
        completion_backups: vec![(
            "completion_with_very_long_name.bash".to_string(),
            PathBuf::from(format!(
                "{}/completion_with_very_long_name.bash.backup",
                long_path
            )),
        )],
    };

    // 长路径应该能正常处理
    assert!(backup_info.backup_dir.to_string_lossy().len() > 50);
    assert_eq!(backup_info.binary_backups.len(), 1);
    assert_eq!(backup_info.completion_backups.len(), 1);
}

#[test]
fn test_backup_info_with_special_characters() {
    /// 测试包含特殊字符的备份信息
    let backup_info = BackupInfo {
        backup_dir: PathBuf::from("/tmp/backup-with-special-chars_123"),
        binary_backups: vec![
            (
                "binary-with-dashes".to_string(),
                PathBuf::from("/tmp/binary-with-dashes.bak"),
            ),
            (
                "binary_with_underscores".to_string(),
                PathBuf::from("/tmp/binary_with_underscores.bak"),
            ),
        ],
        completion_backups: vec![(
            "completion-script.bash".to_string(),
            PathBuf::from("/tmp/completion-script.bash.bak"),
        )],
    };

    // 特殊字符应该能正常处理
    assert!(backup_info.backup_dir.to_string_lossy().contains("special-chars"));
    assert_eq!(backup_info.binary_backups.len(), 2);
    assert_eq!(backup_info.completion_backups.len(), 1);

    // 验证特殊字符在文件名中的处理
    let (binary_name, _) = &backup_info.binary_backups[0];
    assert!(binary_name.contains("-"));

    let (binary_name, _) = &backup_info.binary_backups[1];
    assert!(binary_name.contains("_"));
}

#[test]
fn test_rollback_result_with_many_failures() {
    /// 测试包含大量失败项的回滚结果
    let mut failed_binaries = Vec::new();
    let mut failed_completions = Vec::new();

    // 生成大量失败项
    for i in 0..100 {
        failed_binaries.push((format!("binary_{}", i), format!("Error {}", i)));
        failed_completions.push((
            format!("completion_{}.sh", i),
            format!("Completion error {}", i),
        ));
    }

    let rollback_result = RollbackResult {
        restored_binaries: vec![],
        restored_completions: vec![],
        failed_binaries,
        failed_completions,
        shell_reload_success: Some(false),
        shell_config_file: None,
    };

    // 验证大量失败项能正常处理
    assert_eq!(rollback_result.failed_binaries.len(), 100);
    assert_eq!(rollback_result.failed_completions.len(), 100);

    // 验证第一个和最后一个失败项
    assert_eq!(rollback_result.failed_binaries[0].0, "binary_0");
    assert_eq!(rollback_result.failed_binaries[99].0, "binary_99");
    assert_eq!(rollback_result.failed_completions[0].0, "completion_0.sh");
    assert_eq!(rollback_result.failed_completions[99].0, "completion_99.sh");
}

#[rstest]
#[case(vec![], vec![], 0, 0)]
#[case(vec!["a".to_string()], vec![], 1, 0)]
#[case(vec![], vec!["b.sh".to_string()], 0, 1)]
#[case(vec!["a".to_string(), "b".to_string()], vec!["c.sh".to_string(), "d.zsh".to_string()], 2, 2)]
fn test_results_parametrized(
    #[case] restored_binaries: Vec<String>,
    #[case] restored_completions: Vec<String>,
    #[case] expected_binary_count: usize,
    #[case] expected_completion_count: usize,
) {
    /// 参数化测试各种结果组合
    let rollback_result = RollbackResult {
        restored_binaries: restored_binaries.clone(),
        restored_completions: restored_completions.clone(),
        failed_binaries: vec![],
        failed_completions: vec![],
        shell_reload_success: None,
        shell_config_file: None,
    };

    assert_eq!(
        rollback_result.restored_binaries.len(),
        expected_binary_count
    );
    assert_eq!(
        rollback_result.restored_completions.len(),
        expected_completion_count
    );
    assert_eq!(rollback_result.restored_binaries, restored_binaries);
    assert_eq!(rollback_result.restored_completions, restored_completions);
}
