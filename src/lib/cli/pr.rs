//! Pull Request operations subcommands

use clap::Subcommand;

use super::args::{DryRunArgs, ForceArgs, JiraIdArg, PaginationArgs};

/// PR commands enumeration
///
/// Defines all PR-related subcommands.
#[derive(Subcommand)]
pub enum PRCommands {
    /// Create a new Pull Request
    ///
    /// Supports auto-detection of repository type (GitHub), and optionally uses AI to generate PR title.
    /// If a Jira ticket is provided, will automatically update Jira status.
    Create {
        #[command(flatten)]
        jira_id: JiraIdArg,

        /// PR title (optional, will use AI generation if not provided)
        #[arg(short, long)]
        title: Option<String>,

        /// Short description (optional)
        #[arg(short, long)]
        description: Option<String>,

        #[command(flatten)]
        dry_run: DryRunArgs,
    },
    /// Merge a Pull Request
    ///
    /// Auto-detect PR corresponding to current branch, or manually specify PR ID.
    /// Will automatically update corresponding Jira ticket status after merging.
    Merge {
        /// PR ID (optional, auto-detect from current branch if not provided)
        #[arg(value_name = "PR_ID")]
        pull_request_id: Option<String>,

        #[command(flatten)]
        force: ForceArgs,
    },
    /// Show PR status information
    ///
    /// Display detailed information about a specific PR, including status, author, comments, etc.
    Status {
        /// PR ID or branch name (optional, auto-detect from current branch if not provided)
        #[arg(value_name = "PR_ID_OR_BRANCH")]
        pull_request_id_or_branch: Option<String>,
    },
    /// List Pull Requests
    ///
    /// List all PRs in the repository, supports filtering by status and limiting the number of results.
    List {
        /// Filter by state (open, closed, merged)
        #[arg(short, long)]
        state: Option<String>,

        #[command(flatten)]
        pagination: PaginationArgs,
    },
    /// Update code (use PR title as commit message)
    ///
    /// Commit current changes to PR branch using PR title as commit message.
    Update,
    /// Sync branch into current branch
    ///
    /// Sync specified branch into current branch, supporting merge, rebase, or squash.
    /// This is a local Git operation, different from the `merge` command (which merges PR via API).
    /// Merged functionality from `integrate` and `sync` commands.
    /// Will prompt for confirmation before pushing to remote.
    Sync {
        /// Source branch name to sync (required)
        #[arg(value_name = "SOURCE_BRANCH")]
        source_branch: String,

        /// Use rebase instead of merge (default: merge)
        #[arg(long, action = clap::ArgAction::SetTrue)]
        rebase: bool,

        /// Only allow fast-forward merge (fail if not possible)
        #[arg(long, action = clap::ArgAction::SetTrue)]
        ff_only: bool,

        /// Use squash merge (compress all commits into one)
        #[arg(long, action = clap::ArgAction::SetTrue)]
        squash: bool,
    },
    /// Rebase current branch onto target branch and update PR base
    ///
    /// Rebase the current branch onto the specified target branch,
    /// and update the PR's base branch if a PR exists (with user confirmation).
    /// PR ID is automatically detected from the current branch.
    Rebase {
        /// Target branch to rebase onto (required)
        #[arg(value_name = "TARGET_BRANCH")]
        target_branch: String,

        /// Don't push to remote (only rebase locally)
        #[arg(long, action = clap::ArgAction::SetTrue)]
        no_push: bool,

        #[command(flatten)]
        dry_run: DryRunArgs,
    },
    /// Close a Pull Request
    ///
    /// Close PR corresponding to current branch, delete remote branch, and switch to default branch.
    Close {
        /// PR ID (optional, auto-detect from current branch if not provided)
        #[arg(value_name = "PR_ID")]
        pull_request_id: Option<String>,
    },
    /// Summarize a Pull Request
    ///
    /// Read PR changes and generate a summary document using LLM.
    /// The document will be saved to ~/Documents/Workflow/{PR_ID}/{filename}.md
    /// where filename is automatically generated by AI based on PR content.
    /// Language is determined by the config file (defaults to "en" if not configured).
    Summarize {
        /// PR ID (optional, auto-detect from current branch if not provided)
        #[arg(value_name = "PR_ID")]
        pull_request_id: Option<String>,
    },
    /// Approve a Pull Request
    ///
    /// Approve a PR by adding a üëç comment.
    Approve {
        /// PR ID (optional, auto-detect from current branch if not provided)
        #[arg(value_name = "PR_ID")]
        pull_request_id: Option<String>,
    },
    /// Add a comment to a Pull Request
    ///
    /// Add a comment to a PR.
    Comment {
        /// PR ID (optional, auto-detect from current branch if not provided)
        #[arg(value_name = "PR_ID")]
        pull_request_id: Option<String>,

        /// Comment message (required, can be multiple words)
        #[arg(value_name = "MESSAGE", trailing_var_arg = true)]
        message: Vec<String>,
    },
    /// Pick commits from one branch to another and create a new PR
    ///
    /// Cherry-pick all commits from the source branch to the target branch,
    /// then interactively create a new branch and PR (similar to `pr create`).
    /// This is similar to backport/forwardport but supports any direction.
    ///
    /// The command will:
    /// 1. Switch to the target branch
    /// 2. Cherry-pick commits (without committing)
    /// 3. Interactively create PR (with LLM-generated branch name, Jira integration, etc.)
    Pick {
        /// Source branch name (branch to cherry-pick from)
        #[arg(value_name = "FROM_BRANCH")]
        from_branch: String,

        /// Target branch name (base branch for the new PR)
        #[arg(value_name = "TO_BRANCH")]
        to_branch: String,

        #[command(flatten)]
        dry_run: DryRunArgs,
    },
    /// Reword PR title and description from diff
    ///
    /// Automatically generate and update PR title and description based on PR diff.
    /// Uses LLM to analyze code changes and generate concise title and description.
    Reword {
        /// PR ID (optional, auto-detect from current branch if not provided)
        #[arg(value_name = "PR_ID")]
        pull_request_id: Option<String>,

        /// Update title (can be combined with --description to update both)
        #[arg(long, action = clap::ArgAction::SetTrue)]
        title: bool,

        /// Update description (can be combined with --title to update both)
        #[arg(long, action = clap::ArgAction::SetTrue)]
        description: bool,

        #[command(flatten)]
        dry_run: DryRunArgs,
    },
}
